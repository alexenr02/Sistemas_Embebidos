
RTOS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002104  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  00002104  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004070  2000043c  00002540  0002043c  2**2
                  ALLOC
  3 .stack        00002004  200044ac  000065b0  0002043c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  6 .debug_info   00012cbb  00000000  00000000  000204bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000019c1  00000000  00000000  00033178  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000067a7  00000000  00000000  00034b39  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000640  00000000  00000000  0003b2e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000007a0  00000000  00000000  0003b920  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000119c4  00000000  00000000  0003c0c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000527d  00000000  00000000  0004da84  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00079fb4  00000000  00000000  00052d01  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001298  00000000  00000000  000cccb8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	b0 64 00 20 19 01 00 00 15 01 00 00 15 01 00 00     .d. ............
	...
      2c:	15 01 00 00 00 00 00 00 00 00 00 00 71 08 00 00     ............q...
      3c:	b5 08 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      4c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      5c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      6c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      7c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      8c:	15 01 00 00 15 01 00 00 00 00 00 00 00 00 00 00     ................
      9c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      ac:	15 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000043c 	.word	0x2000043c
      d4:	00000000 	.word	0x00000000
      d8:	00002104 	.word	0x00002104

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000440 	.word	0x20000440
     108:	00002104 	.word	0x00002104
     10c:	00002104 	.word	0x00002104
     110:	00000000 	.word	0x00000000

00000114 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     114:	e7fe      	b.n	114 <Dummy_Handler>
	...

00000118 <Reset_Handler>:
{
     118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     11a:	4a23      	ldr	r2, [pc, #140]	; (1a8 <Reset_Handler+0x90>)
     11c:	4b23      	ldr	r3, [pc, #140]	; (1ac <Reset_Handler+0x94>)
     11e:	429a      	cmp	r2, r3
     120:	d009      	beq.n	136 <Reset_Handler+0x1e>
     122:	4b22      	ldr	r3, [pc, #136]	; (1ac <Reset_Handler+0x94>)
     124:	4a20      	ldr	r2, [pc, #128]	; (1a8 <Reset_Handler+0x90>)
     126:	e003      	b.n	130 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     128:	6811      	ldr	r1, [r2, #0]
     12a:	6019      	str	r1, [r3, #0]
     12c:	3304      	adds	r3, #4
     12e:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     130:	491f      	ldr	r1, [pc, #124]	; (1b0 <Reset_Handler+0x98>)
     132:	428b      	cmp	r3, r1
     134:	d3f8      	bcc.n	128 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     136:	4b1f      	ldr	r3, [pc, #124]	; (1b4 <Reset_Handler+0x9c>)
     138:	e002      	b.n	140 <Reset_Handler+0x28>
                *pDest++ = 0;
     13a:	2200      	movs	r2, #0
     13c:	601a      	str	r2, [r3, #0]
     13e:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     140:	4a1d      	ldr	r2, [pc, #116]	; (1b8 <Reset_Handler+0xa0>)
     142:	4293      	cmp	r3, r2
     144:	d3f9      	bcc.n	13a <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     146:	4a1d      	ldr	r2, [pc, #116]	; (1bc <Reset_Handler+0xa4>)
     148:	21ff      	movs	r1, #255	; 0xff
     14a:	4b1d      	ldr	r3, [pc, #116]	; (1c0 <Reset_Handler+0xa8>)
     14c:	438b      	bics	r3, r1
     14e:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     150:	39fd      	subs	r1, #253	; 0xfd
     152:	2390      	movs	r3, #144	; 0x90
     154:	005b      	lsls	r3, r3, #1
     156:	4a1b      	ldr	r2, [pc, #108]	; (1c4 <Reset_Handler+0xac>)
     158:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     15a:	4a1b      	ldr	r2, [pc, #108]	; (1c8 <Reset_Handler+0xb0>)
     15c:	78d3      	ldrb	r3, [r2, #3]
     15e:	2503      	movs	r5, #3
     160:	43ab      	bics	r3, r5
     162:	2402      	movs	r4, #2
     164:	4323      	orrs	r3, r4
     166:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     168:	78d3      	ldrb	r3, [r2, #3]
     16a:	270c      	movs	r7, #12
     16c:	43bb      	bics	r3, r7
     16e:	2608      	movs	r6, #8
     170:	4333      	orrs	r3, r6
     172:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     174:	4b15      	ldr	r3, [pc, #84]	; (1cc <Reset_Handler+0xb4>)
     176:	7b98      	ldrb	r0, [r3, #14]
     178:	2230      	movs	r2, #48	; 0x30
     17a:	4390      	bics	r0, r2
     17c:	2220      	movs	r2, #32
     17e:	4310      	orrs	r0, r2
     180:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     182:	7b99      	ldrb	r1, [r3, #14]
     184:	43b9      	bics	r1, r7
     186:	4331      	orrs	r1, r6
     188:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     18a:	7b9a      	ldrb	r2, [r3, #14]
     18c:	43aa      	bics	r2, r5
     18e:	4322      	orrs	r2, r4
     190:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     192:	4a0f      	ldr	r2, [pc, #60]	; (1d0 <Reset_Handler+0xb8>)
     194:	6851      	ldr	r1, [r2, #4]
     196:	2380      	movs	r3, #128	; 0x80
     198:	430b      	orrs	r3, r1
     19a:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     19c:	4b0d      	ldr	r3, [pc, #52]	; (1d4 <Reset_Handler+0xbc>)
     19e:	4798      	blx	r3
        main();
     1a0:	4b0d      	ldr	r3, [pc, #52]	; (1d8 <Reset_Handler+0xc0>)
     1a2:	4798      	blx	r3
     1a4:	e7fe      	b.n	1a4 <Reset_Handler+0x8c>
     1a6:	46c0      	nop			; (mov r8, r8)
     1a8:	00002104 	.word	0x00002104
     1ac:	20000000 	.word	0x20000000
     1b0:	2000043c 	.word	0x2000043c
     1b4:	2000043c 	.word	0x2000043c
     1b8:	200044ac 	.word	0x200044ac
     1bc:	e000ed00 	.word	0xe000ed00
     1c0:	00000000 	.word	0x00000000
     1c4:	41007000 	.word	0x41007000
     1c8:	41005000 	.word	0x41005000
     1cc:	41004800 	.word	0x41004800
     1d0:	41004000 	.word	0x41004000
     1d4:	00001d59 	.word	0x00001d59
     1d8:	00000439 	.word	0x00000439

000001dc <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
     1dc:	4a01      	ldr	r2, [pc, #4]	; (1e4 <SystemInit+0x8>)
     1de:	4b02      	ldr	r3, [pc, #8]	; (1e8 <SystemInit+0xc>)
     1e0:	601a      	str	r2, [r3, #0]
        return;
}
     1e2:	4770      	bx	lr
     1e4:	000f4240 	.word	0x000f4240
     1e8:	20000000 	.word	0x20000000

000001ec <prvHeapInit>:
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     1ec:	2207      	movs	r2, #7
     1ee:	4b07      	ldr	r3, [pc, #28]	; (20c <prvHeapInit+0x20>)
     1f0:	3308      	adds	r3, #8
     1f2:	4393      	bics	r3, r2

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     1f4:	4a06      	ldr	r2, [pc, #24]	; (210 <prvHeapInit+0x24>)
     1f6:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
     1f8:	2000      	movs	r0, #0
     1fa:	6050      	str	r0, [r2, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     1fc:	4905      	ldr	r1, [pc, #20]	; (214 <prvHeapInit+0x28>)
     1fe:	60d1      	str	r1, [r2, #12]
	xEnd.pxNextFreeBlock = NULL;
     200:	6090      	str	r0, [r2, #8]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     202:	6059      	str	r1, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     204:	3208      	adds	r2, #8
     206:	601a      	str	r2, [r3, #0]
}
     208:	4770      	bx	lr
     20a:	46c0      	nop			; (mov r8, r8)
     20c:	20000458 	.word	0x20000458
     210:	200042d8 	.word	0x200042d8
     214:	00003e78 	.word	0x00003e78

00000218 <pvPortMalloc>:
{
     218:	b570      	push	{r4, r5, r6, lr}
     21a:	0004      	movs	r4, r0
	vTaskSuspendAll();
     21c:	4b24      	ldr	r3, [pc, #144]	; (2b0 <pvPortMalloc+0x98>)
     21e:	4798      	blx	r3
		if( xHeapHasBeenInitialised == pdFALSE )
     220:	4b24      	ldr	r3, [pc, #144]	; (2b4 <pvPortMalloc+0x9c>)
     222:	691b      	ldr	r3, [r3, #16]
     224:	2b00      	cmp	r3, #0
     226:	d00e      	beq.n	246 <pvPortMalloc+0x2e>
		if( xWantedSize > 0 )
     228:	2c00      	cmp	r4, #0
     22a:	d005      	beq.n	238 <pvPortMalloc+0x20>
			xWantedSize += heapSTRUCT_SIZE;
     22c:	3408      	adds	r4, #8
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
     22e:	0763      	lsls	r3, r4, #29
     230:	d002      	beq.n	238 <pvPortMalloc+0x20>
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
     232:	2307      	movs	r3, #7
     234:	439c      	bics	r4, r3
     236:	3408      	adds	r4, #8
		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     238:	1e63      	subs	r3, r4, #1
     23a:	4a1f      	ldr	r2, [pc, #124]	; (2b8 <pvPortMalloc+0xa0>)
     23c:	4293      	cmp	r3, r2
     23e:	d832      	bhi.n	2a6 <pvPortMalloc+0x8e>
			pxBlock = xStart.pxNextFreeBlock;
     240:	491c      	ldr	r1, [pc, #112]	; (2b4 <pvPortMalloc+0x9c>)
     242:	680b      	ldr	r3, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     244:	e007      	b.n	256 <pvPortMalloc+0x3e>
			prvHeapInit();
     246:	4b1d      	ldr	r3, [pc, #116]	; (2bc <pvPortMalloc+0xa4>)
     248:	4798      	blx	r3
			xHeapHasBeenInitialised = pdTRUE;
     24a:	2201      	movs	r2, #1
     24c:	4b19      	ldr	r3, [pc, #100]	; (2b4 <pvPortMalloc+0x9c>)
     24e:	611a      	str	r2, [r3, #16]
     250:	e7ea      	b.n	228 <pvPortMalloc+0x10>
				pxPreviousBlock = pxBlock;
     252:	0019      	movs	r1, r3
				pxBlock = pxBlock->pxNextFreeBlock;
     254:	0013      	movs	r3, r2
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     256:	685a      	ldr	r2, [r3, #4]
     258:	4294      	cmp	r4, r2
     25a:	d902      	bls.n	262 <pvPortMalloc+0x4a>
     25c:	681a      	ldr	r2, [r3, #0]
     25e:	2a00      	cmp	r2, #0
     260:	d1f7      	bne.n	252 <pvPortMalloc+0x3a>
			if( pxBlock != &xEnd )
     262:	4a14      	ldr	r2, [pc, #80]	; (2b4 <pvPortMalloc+0x9c>)
     264:	3208      	adds	r2, #8
     266:	4293      	cmp	r3, r2
     268:	d01f      	beq.n	2aa <pvPortMalloc+0x92>
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     26a:	680d      	ldr	r5, [r1, #0]
     26c:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     26e:	681a      	ldr	r2, [r3, #0]
     270:	600a      	str	r2, [r1, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     272:	685a      	ldr	r2, [r3, #4]
     274:	1b12      	subs	r2, r2, r4
     276:	2a10      	cmp	r2, #16
     278:	d90c      	bls.n	294 <pvPortMalloc+0x7c>
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     27a:	191e      	adds	r6, r3, r4
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     27c:	6072      	str	r2, [r6, #4]
					pxBlock->xBlockSize = xWantedSize;
     27e:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     280:	6870      	ldr	r0, [r6, #4]
     282:	490c      	ldr	r1, [pc, #48]	; (2b4 <pvPortMalloc+0x9c>)
     284:	e000      	b.n	288 <pvPortMalloc+0x70>
     286:	0011      	movs	r1, r2
     288:	680a      	ldr	r2, [r1, #0]
     28a:	6854      	ldr	r4, [r2, #4]
     28c:	42a0      	cmp	r0, r4
     28e:	d8fa      	bhi.n	286 <pvPortMalloc+0x6e>
     290:	6032      	str	r2, [r6, #0]
     292:	600e      	str	r6, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     294:	685b      	ldr	r3, [r3, #4]
     296:	4a0a      	ldr	r2, [pc, #40]	; (2c0 <pvPortMalloc+0xa8>)
     298:	6811      	ldr	r1, [r2, #0]
     29a:	1acb      	subs	r3, r1, r3
     29c:	6013      	str	r3, [r2, #0]
	( void ) xTaskResumeAll();
     29e:	4b09      	ldr	r3, [pc, #36]	; (2c4 <pvPortMalloc+0xac>)
     2a0:	4798      	blx	r3
}
     2a2:	0028      	movs	r0, r5
     2a4:	bd70      	pop	{r4, r5, r6, pc}
void *pvReturn = NULL;
     2a6:	2500      	movs	r5, #0
     2a8:	e7f9      	b.n	29e <pvPortMalloc+0x86>
     2aa:	2500      	movs	r5, #0
     2ac:	e7f7      	b.n	29e <pvPortMalloc+0x86>
     2ae:	46c0      	nop			; (mov r8, r8)
     2b0:	000013d9 	.word	0x000013d9
     2b4:	200042d8 	.word	0x200042d8
     2b8:	00003e76 	.word	0x00003e76
     2bc:	000001ed 	.word	0x000001ed
     2c0:	20000004 	.word	0x20000004
     2c4:	00001501 	.word	0x00001501

000002c8 <vPortFree>:
{
     2c8:	b570      	push	{r4, r5, r6, lr}
     2ca:	1e04      	subs	r4, r0, #0
	if( pv != NULL )
     2cc:	d016      	beq.n	2fc <vPortFree+0x34>
		puc -= heapSTRUCT_SIZE;
     2ce:	0005      	movs	r5, r0
     2d0:	3d08      	subs	r5, #8
		vTaskSuspendAll();
     2d2:	4b0b      	ldr	r3, [pc, #44]	; (300 <vPortFree+0x38>)
     2d4:	4798      	blx	r3
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     2d6:	6869      	ldr	r1, [r5, #4]
     2d8:	4a0a      	ldr	r2, [pc, #40]	; (304 <vPortFree+0x3c>)
     2da:	e000      	b.n	2de <vPortFree+0x16>
     2dc:	001a      	movs	r2, r3
     2de:	6813      	ldr	r3, [r2, #0]
     2e0:	6858      	ldr	r0, [r3, #4]
     2e2:	4281      	cmp	r1, r0
     2e4:	d8fa      	bhi.n	2dc <vPortFree+0x14>
     2e6:	3c08      	subs	r4, #8
     2e8:	6023      	str	r3, [r4, #0]
     2ea:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
     2ec:	6863      	ldr	r3, [r4, #4]
     2ee:	4a06      	ldr	r2, [pc, #24]	; (308 <vPortFree+0x40>)
     2f0:	6811      	ldr	r1, [r2, #0]
     2f2:	468c      	mov	ip, r1
     2f4:	4463      	add	r3, ip
     2f6:	6013      	str	r3, [r2, #0]
		( void ) xTaskResumeAll();
     2f8:	4b04      	ldr	r3, [pc, #16]	; (30c <vPortFree+0x44>)
     2fa:	4798      	blx	r3
}
     2fc:	bd70      	pop	{r4, r5, r6, pc}
     2fe:	46c0      	nop			; (mov r8, r8)
     300:	000013d9 	.word	0x000013d9
     304:	200042d8 	.word	0x200042d8
     308:	20000004 	.word	0x20000004
     30c:	00001501 	.word	0x00001501

00000310 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     310:	0003      	movs	r3, r0
     312:	3308      	adds	r3, #8
     314:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     316:	2201      	movs	r2, #1
     318:	4252      	negs	r2, r2
     31a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     31c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     31e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     320:	2300      	movs	r3, #0
     322:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     324:	4770      	bx	lr

00000326 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     326:	2300      	movs	r3, #0
     328:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     32a:	4770      	bx	lr

0000032c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     32c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     32e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     330:	689a      	ldr	r2, [r3, #8]
     332:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     334:	689a      	ldr	r2, [r3, #8]
     336:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     338:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     33a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     33c:	6803      	ldr	r3, [r0, #0]
     33e:	3301      	adds	r3, #1
     340:	6003      	str	r3, [r0, #0]
}
     342:	4770      	bx	lr

00000344 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     344:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     346:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     348:	1c63      	adds	r3, r4, #1
     34a:	d002      	beq.n	352 <vListInsert+0xe>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     34c:	0002      	movs	r2, r0
     34e:	3208      	adds	r2, #8
     350:	e002      	b.n	358 <vListInsert+0x14>
		pxIterator = pxList->xListEnd.pxPrevious;
     352:	6902      	ldr	r2, [r0, #16]
     354:	e004      	b.n	360 <vListInsert+0x1c>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     356:	001a      	movs	r2, r3
     358:	6853      	ldr	r3, [r2, #4]
     35a:	681d      	ldr	r5, [r3, #0]
     35c:	42ac      	cmp	r4, r5
     35e:	d2fa      	bcs.n	356 <vListInsert+0x12>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     360:	6853      	ldr	r3, [r2, #4]
     362:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     364:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
     366:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
     368:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     36a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     36c:	6803      	ldr	r3, [r0, #0]
     36e:	3301      	adds	r3, #1
     370:	6003      	str	r3, [r0, #0]
}
     372:	bd30      	pop	{r4, r5, pc}

00000374 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     374:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     376:	6842      	ldr	r2, [r0, #4]
     378:	6881      	ldr	r1, [r0, #8]
     37a:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     37c:	6882      	ldr	r2, [r0, #8]
     37e:	6841      	ldr	r1, [r0, #4]
     380:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     382:	685a      	ldr	r2, [r3, #4]
     384:	4290      	cmp	r0, r2
     386:	d006      	beq.n	396 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     388:	2200      	movs	r2, #0
     38a:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     38c:	681a      	ldr	r2, [r3, #0]
     38e:	3a01      	subs	r2, #1
     390:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     392:	6818      	ldr	r0, [r3, #0]
}
     394:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     396:	6882      	ldr	r2, [r0, #8]
     398:	605a      	str	r2, [r3, #4]
     39a:	e7f5      	b.n	388 <uxListRemove+0x14>

0000039c <sender_task>:
/* Priorities at which the tasks are created. */
#define myTASK_TASK_PRIORITY         	( tskIDLE_PRIORITY + 1 )


xQueueHandle Global_Queue_Handle = 0;
void sender_task(void *p) {
     39c:	b510      	push	{r4, lr}
     39e:	b082      	sub	sp, #8
	uint32_t i = 0;
     3a0:	2300      	movs	r3, #0
     3a2:	9301      	str	r3, [sp, #4]
     3a4:	e006      	b.n	3b4 <sender_task+0x18>
		if(!xQueueSend(Global_Queue_Handle,&i,100))
		{
			myprintf("\nFailed to send to the Queue \n");
			
		}
		i++;
     3a6:	9b01      	ldr	r3, [sp, #4]
     3a8:	3301      	adds	r3, #1
     3aa:	9301      	str	r3, [sp, #4]
		
		vTaskDelay(300);
     3ac:	2096      	movs	r0, #150	; 0x96
     3ae:	0040      	lsls	r0, r0, #1
     3b0:	4b09      	ldr	r3, [pc, #36]	; (3d8 <sender_task+0x3c>)
     3b2:	4798      	blx	r3
		myprintf("\nSend %d to receiver task\n", i);
     3b4:	9901      	ldr	r1, [sp, #4]
     3b6:	4809      	ldr	r0, [pc, #36]	; (3dc <sender_task+0x40>)
     3b8:	4b09      	ldr	r3, [pc, #36]	; (3e0 <sender_task+0x44>)
     3ba:	4798      	blx	r3
		if(!xQueueSend(Global_Queue_Handle,&i,100))
     3bc:	4b09      	ldr	r3, [pc, #36]	; (3e4 <sender_task+0x48>)
     3be:	6818      	ldr	r0, [r3, #0]
     3c0:	2300      	movs	r3, #0
     3c2:	2264      	movs	r2, #100	; 0x64
     3c4:	a901      	add	r1, sp, #4
     3c6:	4c08      	ldr	r4, [pc, #32]	; (3e8 <sender_task+0x4c>)
     3c8:	47a0      	blx	r4
     3ca:	2800      	cmp	r0, #0
     3cc:	d1eb      	bne.n	3a6 <sender_task+0xa>
			myprintf("\nFailed to send to the Queue \n");
     3ce:	4807      	ldr	r0, [pc, #28]	; (3ec <sender_task+0x50>)
     3d0:	4b03      	ldr	r3, [pc, #12]	; (3e0 <sender_task+0x44>)
     3d2:	4798      	blx	r3
     3d4:	e7e7      	b.n	3a6 <sender_task+0xa>
     3d6:	46c0      	nop			; (mov r8, r8)
     3d8:	000015f5 	.word	0x000015f5
     3dc:	00002010 	.word	0x00002010
     3e0:	0000056d 	.word	0x0000056d
     3e4:	200042ec 	.word	0x200042ec
     3e8:	00000be1 	.word	0x00000be1
     3ec:	0000202c 	.word	0x0000202c

000003f0 <receiver_task>:
	}
}

void receiver_task(void *p) {
     3f0:	b500      	push	{lr}
     3f2:	b083      	sub	sp, #12
	int rx_int=0;
     3f4:	2300      	movs	r3, #0
     3f6:	9301      	str	r3, [sp, #4]
     3f8:	e005      	b.n	406 <receiver_task+0x16>
		if(xQueueReceive(Global_Queue_Handle, &rx_int,100))
		{
			myprintf("\nReceived %d\n", rx_int);
		}
		else{
		myprintf("\nFailed to receive data from the Queue\n");
     3fa:	4809      	ldr	r0, [pc, #36]	; (420 <receiver_task+0x30>)
     3fc:	4b09      	ldr	r3, [pc, #36]	; (424 <receiver_task+0x34>)
     3fe:	4798      	blx	r3
		}
		vTaskDelay(100);
     400:	2064      	movs	r0, #100	; 0x64
     402:	4b09      	ldr	r3, [pc, #36]	; (428 <receiver_task+0x38>)
     404:	4798      	blx	r3
		if(xQueueReceive(Global_Queue_Handle, &rx_int,100))
     406:	4b09      	ldr	r3, [pc, #36]	; (42c <receiver_task+0x3c>)
     408:	6818      	ldr	r0, [r3, #0]
     40a:	2264      	movs	r2, #100	; 0x64
     40c:	a901      	add	r1, sp, #4
     40e:	4b08      	ldr	r3, [pc, #32]	; (430 <receiver_task+0x40>)
     410:	4798      	blx	r3
     412:	2800      	cmp	r0, #0
     414:	d0f1      	beq.n	3fa <receiver_task+0xa>
			myprintf("\nReceived %d\n", rx_int);
     416:	9901      	ldr	r1, [sp, #4]
     418:	4806      	ldr	r0, [pc, #24]	; (434 <receiver_task+0x44>)
     41a:	4b02      	ldr	r3, [pc, #8]	; (424 <receiver_task+0x34>)
     41c:	4798      	blx	r3
     41e:	e7ef      	b.n	400 <receiver_task+0x10>
     420:	0000205c 	.word	0x0000205c
     424:	0000056d 	.word	0x0000056d
     428:	000015f5 	.word	0x000015f5
     42c:	200042ec 	.word	0x200042ec
     430:	00000e5d 	.word	0x00000e5d
     434:	0000204c 	.word	0x0000204c

00000438 <main>:
	}
}


int main()
{
     438:	b5f0      	push	{r4, r5, r6, r7, lr}
     43a:	b083      	sub	sp, #12
	SystemInit();
     43c:	4b12      	ldr	r3, [pc, #72]	; (488 <main+0x50>)
     43e:	4798      	blx	r3
	/* Switch to 8MHz clock (disable prescaler) */
	SYSCTRL->OSC8M.bit.PRESC = 0;
     440:	4a12      	ldr	r2, [pc, #72]	; (48c <main+0x54>)
     442:	6a11      	ldr	r1, [r2, #32]
     444:	4b12      	ldr	r3, [pc, #72]	; (490 <main+0x58>)
     446:	400b      	ands	r3, r1
     448:	6213      	str	r3, [r2, #32]
	initUART();
     44a:	4b12      	ldr	r3, [pc, #72]	; (494 <main+0x5c>)
     44c:	4798      	blx	r3

	Global_Queue_Handle = xQueueCreate(3,sizeof(int));
     44e:	2200      	movs	r2, #0
     450:	2104      	movs	r1, #4
     452:	2003      	movs	r0, #3
     454:	4b10      	ldr	r3, [pc, #64]	; (498 <main+0x60>)
     456:	4798      	blx	r3
     458:	4b10      	ldr	r3, [pc, #64]	; (49c <main+0x64>)
     45a:	6018      	str	r0, [r3, #0]
	
	xTaskCreate(sender_task,(signed char* )"tx",512,NULL,1,NULL);
     45c:	2580      	movs	r5, #128	; 0x80
     45e:	00ad      	lsls	r5, r5, #2
     460:	2700      	movs	r7, #0
     462:	9701      	str	r7, [sp, #4]
     464:	2601      	movs	r6, #1
     466:	9600      	str	r6, [sp, #0]
     468:	2300      	movs	r3, #0
     46a:	002a      	movs	r2, r5
     46c:	490c      	ldr	r1, [pc, #48]	; (4a0 <main+0x68>)
     46e:	480d      	ldr	r0, [pc, #52]	; (4a4 <main+0x6c>)
     470:	4c0d      	ldr	r4, [pc, #52]	; (4a8 <main+0x70>)
     472:	47a0      	blx	r4
	xTaskCreate(receiver_task,(signed char* )"rx",512,NULL,1,NULL);
     474:	9701      	str	r7, [sp, #4]
     476:	9600      	str	r6, [sp, #0]
     478:	2300      	movs	r3, #0
     47a:	002a      	movs	r2, r5
     47c:	490b      	ldr	r1, [pc, #44]	; (4ac <main+0x74>)
     47e:	480c      	ldr	r0, [pc, #48]	; (4b0 <main+0x78>)
     480:	47a0      	blx	r4
	NULL,           	    /* The parameter passed to the task  
	myTASK_TASK_PRIORITY,   /* The priority assigned to the task. 
	NULL );         	    /* The task handle is not required, so NULL is passed.                  */
    
	// Start the tasks and timer running. */
	vTaskStartScheduler();
     482:	4b0c      	ldr	r3, [pc, #48]	; (4b4 <main+0x7c>)
     484:	4798      	blx	r3
     486:	e7fe      	b.n	486 <main+0x4e>
     488:	000001dd 	.word	0x000001dd
     48c:	40000800 	.word	0x40000800
     490:	fffffcff 	.word	0xfffffcff
     494:	00001cbd 	.word	0x00001cbd
     498:	00000b99 	.word	0x00000b99
     49c:	200042ec 	.word	0x200042ec
     4a0:	00002084 	.word	0x00002084
     4a4:	0000039d 	.word	0x0000039d
     4a8:	00001301 	.word	0x00001301
     4ac:	00002088 	.word	0x00002088
     4b0:	000003f1 	.word	0x000003f1
     4b4:	00001371 	.word	0x00001371

000004b8 <sendUART1char>:
static char uc;
static char zs;

static void sendUART1char(char s)
{
  while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     4b8:	4b03      	ldr	r3, [pc, #12]	; (4c8 <sendUART1char+0x10>)
     4ba:	7e1b      	ldrb	r3, [r3, #24]
     4bc:	07db      	lsls	r3, r3, #31
     4be:	d5fb      	bpl.n	4b8 <sendUART1char>
  SERCOM0->USART.DATA.reg = s;
     4c0:	b280      	uxth	r0, r0
     4c2:	4b01      	ldr	r3, [pc, #4]	; (4c8 <sendUART1char+0x10>)
     4c4:	8518      	strh	r0, [r3, #40]	; 0x28
}
     4c6:	4770      	bx	lr
     4c8:	42000800 	.word	0x42000800

000004cc <myputchar>:

/* "print.h" uses this function for is's printf implementation */
static void myputchar(char c)
{
     4cc:	b510      	push	{r4, lr}
     4ce:	0004      	movs	r4, r0
  if(c=='\n')
     4d0:	280a      	cmp	r0, #10
     4d2:	d003      	beq.n	4dc <myputchar+0x10>
    sendUART1char('\r');
  sendUART1char(c);
     4d4:	0020      	movs	r0, r4
     4d6:	4b03      	ldr	r3, [pc, #12]	; (4e4 <myputchar+0x18>)
     4d8:	4798      	blx	r3
}
     4da:	bd10      	pop	{r4, pc}
    sendUART1char('\r');
     4dc:	200d      	movs	r0, #13
     4de:	4b01      	ldr	r3, [pc, #4]	; (4e4 <myputchar+0x18>)
     4e0:	4798      	blx	r3
     4e2:	e7f7      	b.n	4d4 <myputchar+0x8>
     4e4:	000004b9 	.word	0x000004b9

000004e8 <out>:
    //return 0;
//}


static void out(char c) {
    *bf++ = c;
     4e8:	4a02      	ldr	r2, [pc, #8]	; (4f4 <out+0xc>)
     4ea:	6813      	ldr	r3, [r2, #0]
     4ec:	1c59      	adds	r1, r3, #1
     4ee:	6011      	str	r1, [r2, #0]
     4f0:	7018      	strb	r0, [r3, #0]
    }
     4f2:	4770      	bx	lr
     4f4:	200042f0 	.word	0x200042f0

000004f8 <outDgt>:

static void outDgt(char dgt) {
     4f8:	b510      	push	{r4, lr}
     4fa:	0003      	movs	r3, r0
	out(dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10));
     4fc:	2809      	cmp	r0, #9
     4fe:	d907      	bls.n	510 <outDgt+0x18>
     500:	4a08      	ldr	r2, [pc, #32]	; (524 <outDgt+0x2c>)
     502:	7912      	ldrb	r2, [r2, #4]
     504:	2a00      	cmp	r2, #0
     506:	d101      	bne.n	50c <outDgt+0x14>
     508:	2057      	movs	r0, #87	; 0x57
     50a:	e002      	b.n	512 <outDgt+0x1a>
     50c:	2037      	movs	r0, #55	; 0x37
     50e:	e000      	b.n	512 <outDgt+0x1a>
     510:	2030      	movs	r0, #48	; 0x30
     512:	18c0      	adds	r0, r0, r3
     514:	b2c0      	uxtb	r0, r0
     516:	4b04      	ldr	r3, [pc, #16]	; (528 <outDgt+0x30>)
     518:	4798      	blx	r3
	zs=1;
     51a:	2201      	movs	r2, #1
     51c:	4b01      	ldr	r3, [pc, #4]	; (524 <outDgt+0x2c>)
     51e:	715a      	strb	r2, [r3, #5]
    }
     520:	bd10      	pop	{r4, pc}
     522:	46c0      	nop			; (mov r8, r8)
     524:	200042f0 	.word	0x200042f0
     528:	000004e9 	.word	0x000004e9

0000052c <divOut>:
	
static void divOut(unsigned int div) {
     52c:	b510      	push	{r4, lr}
    unsigned char dgt=0;
	num &= 0xffff; // just for testing the code  with 32 bit ints
     52e:	4a0d      	ldr	r2, [pc, #52]	; (564 <divOut+0x38>)
     530:	6893      	ldr	r3, [r2, #8]
     532:	041b      	lsls	r3, r3, #16
     534:	0c1b      	lsrs	r3, r3, #16
     536:	6093      	str	r3, [r2, #8]
    unsigned char dgt=0;
     538:	2200      	movs	r2, #0
	while (num>=div) {
     53a:	e004      	b.n	546 <divOut+0x1a>
		num -= div;
     53c:	1a1b      	subs	r3, r3, r0
     53e:	4909      	ldr	r1, [pc, #36]	; (564 <divOut+0x38>)
     540:	608b      	str	r3, [r1, #8]
		dgt++;
     542:	3201      	adds	r2, #1
     544:	b2d2      	uxtb	r2, r2
	while (num>=div) {
     546:	4b07      	ldr	r3, [pc, #28]	; (564 <divOut+0x38>)
     548:	689b      	ldr	r3, [r3, #8]
     54a:	4283      	cmp	r3, r0
     54c:	d2f6      	bcs.n	53c <divOut+0x10>
		}
	if (zs || dgt>0) 
     54e:	4b05      	ldr	r3, [pc, #20]	; (564 <divOut+0x38>)
     550:	795b      	ldrb	r3, [r3, #5]
     552:	2b00      	cmp	r3, #0
     554:	d101      	bne.n	55a <divOut+0x2e>
     556:	2a00      	cmp	r2, #0
     558:	d002      	beq.n	560 <divOut+0x34>
		outDgt(dgt);
     55a:	0010      	movs	r0, r2
     55c:	4b02      	ldr	r3, [pc, #8]	; (568 <divOut+0x3c>)
     55e:	4798      	blx	r3
    }	
     560:	bd10      	pop	{r4, pc}
     562:	46c0      	nop			; (mov r8, r8)
     564:	200042f0 	.word	0x200042f0
     568:	000004f9 	.word	0x000004f9

0000056c <tfp_printf>:

void tfp_printf(char *fmt, ...)
	{
     56c:	b40f      	push	{r0, r1, r2, r3}
     56e:	b5f0      	push	{r4, r5, r6, r7, lr}
     570:	46c6      	mov	lr, r8
     572:	b500      	push	{lr}
     574:	b082      	sub	sp, #8
     576:	ab08      	add	r3, sp, #32
     578:	cb10      	ldmia	r3!, {r4}
	va_list va;
	char ch;
	char* p;
	
	va_start(va,fmt);
     57a:	9301      	str	r3, [sp, #4]
	
	while ((ch=*(fmt++))) {
     57c:	e0b0      	b.n	6e0 <tfp_printf+0x174>
			myputchar(ch);
			}
		else {
			char lz=0;
			char w=0;
			ch=*(fmt++);
     57e:	3402      	adds	r4, #2
     580:	7829      	ldrb	r1, [r5, #0]
			if (ch=='0') {
     582:	2930      	cmp	r1, #48	; 0x30
     584:	d019      	beq.n	5ba <tfp_printf+0x4e>
			char lz=0;
     586:	2500      	movs	r5, #0
				ch=*(fmt++);
				lz=1;
				}
			if (ch>='0' && ch<='9') {
     588:	000b      	movs	r3, r1
     58a:	3b30      	subs	r3, #48	; 0x30
     58c:	b2db      	uxtb	r3, r3
     58e:	2b09      	cmp	r3, #9
     590:	d929      	bls.n	5e6 <tfp_printf+0x7a>
			char w=0;
     592:	2600      	movs	r6, #0
				while (ch>='0' && ch<='9') {
					w=(((w<<2)+w)<<1)+ch-'0';
					ch=*fmt++;
					}
				}
			bf=buf;
     594:	4b5b      	ldr	r3, [pc, #364]	; (704 <tfp_printf+0x198>)
     596:	001a      	movs	r2, r3
     598:	320c      	adds	r2, #12
     59a:	601a      	str	r2, [r3, #0]
			p=bf;
			zs=0;
     59c:	2200      	movs	r2, #0
     59e:	715a      	strb	r2, [r3, #5]
			switch (ch) {
     5a0:	2963      	cmp	r1, #99	; 0x63
     5a2:	d069      	beq.n	678 <tfp_printf+0x10c>
     5a4:	d821      	bhi.n	5ea <tfp_printf+0x7e>
     5a6:	2925      	cmp	r1, #37	; 0x25
     5a8:	d074      	beq.n	694 <tfp_printf+0x128>
     5aa:	2958      	cmp	r1, #88	; 0x58
     5ac:	d024      	beq.n	5f8 <tfp_printf+0x8c>
     5ae:	2900      	cmp	r1, #0
     5b0:	d100      	bne.n	5b4 <tfp_printf+0x48>
     5b2:	e0a0      	b.n	6f6 <tfp_printf+0x18a>
			p=bf;
     5b4:	4f53      	ldr	r7, [pc, #332]	; (704 <tfp_printf+0x198>)
     5b6:	370c      	adds	r7, #12
     5b8:	e050      	b.n	65c <tfp_printf+0xf0>
				ch=*(fmt++);
     5ba:	1cac      	adds	r4, r5, #2
     5bc:	7869      	ldrb	r1, [r5, #1]
				lz=1;
     5be:	2501      	movs	r5, #1
     5c0:	e7e2      	b.n	588 <tfp_printf+0x1c>
					w=(((w<<2)+w)<<1)+ch-'0';
     5c2:	00b2      	lsls	r2, r6, #2
     5c4:	b2d2      	uxtb	r2, r2
     5c6:	18b2      	adds	r2, r6, r2
     5c8:	b2d3      	uxtb	r3, r2
     5ca:	005b      	lsls	r3, r3, #1
     5cc:	b2db      	uxtb	r3, r3
     5ce:	18cb      	adds	r3, r1, r3
     5d0:	b2db      	uxtb	r3, r3
     5d2:	3b30      	subs	r3, #48	; 0x30
     5d4:	b2de      	uxtb	r6, r3
					ch=*fmt++;
     5d6:	7821      	ldrb	r1, [r4, #0]
     5d8:	3401      	adds	r4, #1
				while (ch>='0' && ch<='9') {
     5da:	000b      	movs	r3, r1
     5dc:	3b30      	subs	r3, #48	; 0x30
     5de:	b2db      	uxtb	r3, r3
     5e0:	2b09      	cmp	r3, #9
     5e2:	d9ee      	bls.n	5c2 <tfp_printf+0x56>
     5e4:	e7d6      	b.n	594 <tfp_printf+0x28>
     5e6:	2600      	movs	r6, #0
     5e8:	e7f7      	b.n	5da <tfp_printf+0x6e>
			switch (ch) {
     5ea:	2973      	cmp	r1, #115	; 0x73
     5ec:	d04d      	beq.n	68a <tfp_printf+0x11e>
     5ee:	d91c      	bls.n	62a <tfp_printf+0xbe>
     5f0:	2975      	cmp	r1, #117	; 0x75
     5f2:	d01c      	beq.n	62e <tfp_printf+0xc2>
     5f4:	2978      	cmp	r1, #120	; 0x78
     5f6:	d1dd      	bne.n	5b4 <tfp_printf+0x48>
					divOut(10);
					outDgt(num);
					break;
				case 'x': 
				case 'X' : 
				    uc= ch=='X';
     5f8:	3958      	subs	r1, #88	; 0x58
     5fa:	424b      	negs	r3, r1
     5fc:	414b      	adcs	r3, r1
     5fe:	4f41      	ldr	r7, [pc, #260]	; (704 <tfp_printf+0x198>)
     600:	713b      	strb	r3, [r7, #4]
					num=va_arg(va, unsigned int);
     602:	9b01      	ldr	r3, [sp, #4]
     604:	1d1a      	adds	r2, r3, #4
     606:	9201      	str	r2, [sp, #4]
     608:	681b      	ldr	r3, [r3, #0]
     60a:	60bb      	str	r3, [r7, #8]
					divOut(0x1000);
     60c:	2080      	movs	r0, #128	; 0x80
     60e:	0140      	lsls	r0, r0, #5
     610:	4b3d      	ldr	r3, [pc, #244]	; (708 <tfp_printf+0x19c>)
     612:	4698      	mov	r8, r3
     614:	4798      	blx	r3
					divOut(0x100);
     616:	2080      	movs	r0, #128	; 0x80
     618:	0040      	lsls	r0, r0, #1
     61a:	47c0      	blx	r8
					divOut(0x10);
     61c:	2010      	movs	r0, #16
     61e:	47c0      	blx	r8
					outDgt(num);
     620:	7a38      	ldrb	r0, [r7, #8]
     622:	4b3a      	ldr	r3, [pc, #232]	; (70c <tfp_printf+0x1a0>)
     624:	4798      	blx	r3
			p=bf;
     626:	370c      	adds	r7, #12
					break;
     628:	e018      	b.n	65c <tfp_printf+0xf0>
			switch (ch) {
     62a:	2964      	cmp	r1, #100	; 0x64
     62c:	d1c2      	bne.n	5b4 <tfp_printf+0x48>
					num=va_arg(va, unsigned int);
     62e:	9b01      	ldr	r3, [sp, #4]
     630:	1d1a      	adds	r2, r3, #4
     632:	9201      	str	r2, [sp, #4]
     634:	681b      	ldr	r3, [r3, #0]
     636:	4a33      	ldr	r2, [pc, #204]	; (704 <tfp_printf+0x198>)
     638:	6093      	str	r3, [r2, #8]
					if (ch=='d' && (int)num<0) {
     63a:	2964      	cmp	r1, #100	; 0x64
     63c:	d014      	beq.n	668 <tfp_printf+0xfc>
					divOut(10000);
     63e:	4834      	ldr	r0, [pc, #208]	; (710 <tfp_printf+0x1a4>)
     640:	4f31      	ldr	r7, [pc, #196]	; (708 <tfp_printf+0x19c>)
     642:	47b8      	blx	r7
					divOut(1000);
     644:	20fa      	movs	r0, #250	; 0xfa
     646:	0080      	lsls	r0, r0, #2
     648:	47b8      	blx	r7
					divOut(100);
     64a:	2064      	movs	r0, #100	; 0x64
     64c:	47b8      	blx	r7
					divOut(10);
     64e:	200a      	movs	r0, #10
     650:	47b8      	blx	r7
					outDgt(num);
     652:	4f2c      	ldr	r7, [pc, #176]	; (704 <tfp_printf+0x198>)
     654:	7a38      	ldrb	r0, [r7, #8]
     656:	4b2d      	ldr	r3, [pc, #180]	; (70c <tfp_printf+0x1a0>)
     658:	4798      	blx	r3
			p=bf;
     65a:	370c      	adds	r7, #12
				case '%' :
					out('%');
				default:
					break;
				}
			*bf=0;
     65c:	4b29      	ldr	r3, [pc, #164]	; (704 <tfp_printf+0x198>)
     65e:	2200      	movs	r2, #0
     660:	6819      	ldr	r1, [r3, #0]
     662:	700a      	strb	r2, [r1, #0]
			bf=p;
     664:	601f      	str	r7, [r3, #0]
			while (*bf++ && w > 0)
     666:	e01d      	b.n	6a4 <tfp_printf+0x138>
					if (ch=='d' && (int)num<0) {
     668:	2b00      	cmp	r3, #0
     66a:	dae8      	bge.n	63e <tfp_printf+0xd2>
						num = -(int)num;
     66c:	425b      	negs	r3, r3
     66e:	6093      	str	r3, [r2, #8]
						out('-');
     670:	202d      	movs	r0, #45	; 0x2d
     672:	4b28      	ldr	r3, [pc, #160]	; (714 <tfp_printf+0x1a8>)
     674:	4798      	blx	r3
     676:	e7e2      	b.n	63e <tfp_printf+0xd2>
					out((char)(va_arg(va, int)));
     678:	9b01      	ldr	r3, [sp, #4]
     67a:	1d1a      	adds	r2, r3, #4
     67c:	9201      	str	r2, [sp, #4]
     67e:	7818      	ldrb	r0, [r3, #0]
     680:	4b24      	ldr	r3, [pc, #144]	; (714 <tfp_printf+0x1a8>)
     682:	4798      	blx	r3
			p=bf;
     684:	4f1f      	ldr	r7, [pc, #124]	; (704 <tfp_printf+0x198>)
     686:	370c      	adds	r7, #12
					break;
     688:	e7e8      	b.n	65c <tfp_printf+0xf0>
					p=va_arg(va, char*);
     68a:	9b01      	ldr	r3, [sp, #4]
     68c:	1d1a      	adds	r2, r3, #4
     68e:	9201      	str	r2, [sp, #4]
     690:	681f      	ldr	r7, [r3, #0]
					break;
     692:	e7e3      	b.n	65c <tfp_printf+0xf0>
					out('%');
     694:	2025      	movs	r0, #37	; 0x25
     696:	4b1f      	ldr	r3, [pc, #124]	; (714 <tfp_printf+0x1a8>)
     698:	4798      	blx	r3
			p=bf;
     69a:	4f1a      	ldr	r7, [pc, #104]	; (704 <tfp_printf+0x198>)
     69c:	370c      	adds	r7, #12
     69e:	e7dd      	b.n	65c <tfp_printf+0xf0>
				w--;
     6a0:	3e01      	subs	r6, #1
     6a2:	b2f6      	uxtb	r6, r6
			while (*bf++ && w > 0)
     6a4:	4a17      	ldr	r2, [pc, #92]	; (704 <tfp_printf+0x198>)
     6a6:	6813      	ldr	r3, [r2, #0]
     6a8:	1c59      	adds	r1, r3, #1
     6aa:	6011      	str	r1, [r2, #0]
     6ac:	781b      	ldrb	r3, [r3, #0]
     6ae:	2b00      	cmp	r3, #0
     6b0:	d006      	beq.n	6c0 <tfp_printf+0x154>
     6b2:	2e00      	cmp	r6, #0
     6b4:	d1f4      	bne.n	6a0 <tfp_printf+0x134>
     6b6:	e003      	b.n	6c0 <tfp_printf+0x154>
			while (w-- > 0) 
				myputchar(lz ? '0' : ' ');
     6b8:	2020      	movs	r0, #32
     6ba:	4b17      	ldr	r3, [pc, #92]	; (718 <tfp_printf+0x1ac>)
     6bc:	4798      	blx	r3
			while (w-- > 0) 
     6be:	4646      	mov	r6, r8
     6c0:	1e73      	subs	r3, r6, #1
     6c2:	b2db      	uxtb	r3, r3
     6c4:	4698      	mov	r8, r3
     6c6:	2e00      	cmp	r6, #0
     6c8:	d006      	beq.n	6d8 <tfp_printf+0x16c>
				myputchar(lz ? '0' : ' ');
     6ca:	2d00      	cmp	r5, #0
     6cc:	d0f4      	beq.n	6b8 <tfp_printf+0x14c>
     6ce:	2030      	movs	r0, #48	; 0x30
     6d0:	e7f3      	b.n	6ba <tfp_printf+0x14e>
			while ((ch= *p++))
				myputchar(ch);
     6d2:	4b11      	ldr	r3, [pc, #68]	; (718 <tfp_printf+0x1ac>)
     6d4:	4798      	blx	r3
			while ((ch= *p++))
     6d6:	002f      	movs	r7, r5
     6d8:	1c7d      	adds	r5, r7, #1
     6da:	7838      	ldrb	r0, [r7, #0]
     6dc:	2800      	cmp	r0, #0
     6de:	d1f8      	bne.n	6d2 <tfp_printf+0x166>
	while ((ch=*(fmt++))) {
     6e0:	1c65      	adds	r5, r4, #1
     6e2:	7820      	ldrb	r0, [r4, #0]
     6e4:	2800      	cmp	r0, #0
     6e6:	d006      	beq.n	6f6 <tfp_printf+0x18a>
		if (ch!='%') {
     6e8:	2825      	cmp	r0, #37	; 0x25
     6ea:	d100      	bne.n	6ee <tfp_printf+0x182>
     6ec:	e747      	b.n	57e <tfp_printf+0x12>
			myputchar(ch);
     6ee:	4b0a      	ldr	r3, [pc, #40]	; (718 <tfp_printf+0x1ac>)
     6f0:	4798      	blx	r3
	while ((ch=*(fmt++))) {
     6f2:	002c      	movs	r4, r5
     6f4:	e7f4      	b.n	6e0 <tfp_printf+0x174>
			}
		}
	abort:;
	va_end(va);
	}
     6f6:	b002      	add	sp, #8
     6f8:	bc04      	pop	{r2}
     6fa:	4690      	mov	r8, r2
     6fc:	bcf0      	pop	{r4, r5, r6, r7}
     6fe:	bc08      	pop	{r3}
     700:	b004      	add	sp, #16
     702:	4718      	bx	r3
     704:	200042f0 	.word	0x200042f0
     708:	0000052d 	.word	0x0000052d
     70c:	000004f9 	.word	0x000004f9
     710:	00002710 	.word	0x00002710
     714:	000004e9 	.word	0x000004e9
     718:	000004cd 	.word	0x000004cd

0000071c <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
     71c:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
     71e:	2300      	movs	r3, #0
     720:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
     722:	4b06      	ldr	r3, [pc, #24]	; (73c <prvTaskExitError+0x20>)
     724:	681b      	ldr	r3, [r3, #0]
     726:	3301      	adds	r3, #1
     728:	d001      	beq.n	72e <prvTaskExitError+0x12>
     72a:	b672      	cpsid	i
     72c:	e7fe      	b.n	72c <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     72e:	b672      	cpsid	i
	while( ulDummy == 0 )
     730:	9b01      	ldr	r3, [sp, #4]
     732:	2b00      	cmp	r3, #0
     734:	d0fc      	beq.n	730 <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     736:	b002      	add	sp, #8
     738:	4770      	bx	lr
     73a:	46c0      	nop			; (mov r8, r8)
     73c:	20000008 	.word	0x20000008

00000740 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     740:	4a0b      	ldr	r2, [pc, #44]	; (770 <pxCurrentTCBConst2>)
     742:	6813      	ldr	r3, [r2, #0]
     744:	6818      	ldr	r0, [r3, #0]
     746:	3020      	adds	r0, #32
     748:	f380 8809 	msr	PSP, r0
     74c:	2002      	movs	r0, #2
     74e:	f380 8814 	msr	CONTROL, r0
     752:	f3bf 8f6f 	isb	sy
     756:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     758:	46ae      	mov	lr, r5
     75a:	bc08      	pop	{r3}
     75c:	bc04      	pop	{r2}
     75e:	b662      	cpsie	i
     760:	4718      	bx	r3
     762:	46c0      	nop			; (mov r8, r8)
     764:	46c0      	nop			; (mov r8, r8)
     766:	46c0      	nop			; (mov r8, r8)
     768:	46c0      	nop			; (mov r8, r8)
     76a:	46c0      	nop			; (mov r8, r8)
     76c:	46c0      	nop			; (mov r8, r8)
     76e:	46c0      	nop			; (mov r8, r8)

00000770 <pxCurrentTCBConst2>:
     770:	200043e0 	.word	0x200043e0

00000774 <prvSetupTimerInterrupt>:
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
     774:	4b05      	ldr	r3, [pc, #20]	; (78c <prvSetupTimerInterrupt+0x18>)
     776:	2200      	movs	r2, #0
     778:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     77a:	4905      	ldr	r1, [pc, #20]	; (790 <prvSetupTimerInterrupt+0x1c>)
     77c:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
     77e:	4905      	ldr	r1, [pc, #20]	; (794 <prvSetupTimerInterrupt+0x20>)
     780:	4a05      	ldr	r2, [pc, #20]	; (798 <prvSetupTimerInterrupt+0x24>)
     782:	6011      	str	r1, [r2, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     784:	2207      	movs	r2, #7
     786:	601a      	str	r2, [r3, #0]
}
     788:	4770      	bx	lr
     78a:	46c0      	nop			; (mov r8, r8)
     78c:	e000e010 	.word	0xe000e010
     790:	e000e018 	.word	0xe000e018
     794:	000176ff 	.word	0x000176ff
     798:	e000e014 	.word	0xe000e014

0000079c <pxPortInitialiseStack>:
{
     79c:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
     79e:	1f03      	subs	r3, r0, #4
     7a0:	2480      	movs	r4, #128	; 0x80
     7a2:	0464      	lsls	r4, r4, #17
     7a4:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
     7a6:	3b04      	subs	r3, #4
     7a8:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
     7aa:	3b04      	subs	r3, #4
     7ac:	4902      	ldr	r1, [pc, #8]	; (7b8 <pxPortInitialiseStack+0x1c>)
     7ae:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
     7b0:	3b14      	subs	r3, #20
     7b2:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
     7b4:	3840      	subs	r0, #64	; 0x40
}
     7b6:	bd10      	pop	{r4, pc}
     7b8:	0000071d 	.word	0x0000071d

000007bc <xPortStartScheduler>:
{
     7bc:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     7be:	4b0c      	ldr	r3, [pc, #48]	; (7f0 <xPortStartScheduler+0x34>)
     7c0:	6819      	ldr	r1, [r3, #0]
     7c2:	22ff      	movs	r2, #255	; 0xff
     7c4:	0412      	lsls	r2, r2, #16
     7c6:	430a      	orrs	r2, r1
     7c8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     7ca:	6819      	ldr	r1, [r3, #0]
     7cc:	22ff      	movs	r2, #255	; 0xff
     7ce:	0612      	lsls	r2, r2, #24
     7d0:	430a      	orrs	r2, r1
     7d2:	601a      	str	r2, [r3, #0]
	prvSetupTimerInterrupt();
     7d4:	4b07      	ldr	r3, [pc, #28]	; (7f4 <xPortStartScheduler+0x38>)
     7d6:	4798      	blx	r3
	uxCriticalNesting = 0;
     7d8:	2200      	movs	r2, #0
     7da:	4b07      	ldr	r3, [pc, #28]	; (7f8 <xPortStartScheduler+0x3c>)
     7dc:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
     7de:	4b07      	ldr	r3, [pc, #28]	; (7fc <xPortStartScheduler+0x40>)
     7e0:	4798      	blx	r3
	vTaskSwitchContext();
     7e2:	4b07      	ldr	r3, [pc, #28]	; (800 <xPortStartScheduler+0x44>)
     7e4:	4798      	blx	r3
	prvTaskExitError();
     7e6:	4b07      	ldr	r3, [pc, #28]	; (804 <xPortStartScheduler+0x48>)
     7e8:	4798      	blx	r3
}
     7ea:	2000      	movs	r0, #0
     7ec:	bd10      	pop	{r4, pc}
     7ee:	46c0      	nop			; (mov r8, r8)
     7f0:	e000ed20 	.word	0xe000ed20
     7f4:	00000775 	.word	0x00000775
     7f8:	20000008 	.word	0x20000008
     7fc:	00000741 	.word	0x00000741
     800:	00001639 	.word	0x00001639
     804:	0000071d 	.word	0x0000071d

00000808 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
     808:	2280      	movs	r2, #128	; 0x80
     80a:	0552      	lsls	r2, r2, #21
     80c:	4b03      	ldr	r3, [pc, #12]	; (81c <vPortYield+0x14>)
     80e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
     810:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     814:	f3bf 8f6f 	isb	sy
}
     818:	4770      	bx	lr
     81a:	46c0      	nop			; (mov r8, r8)
     81c:	e000ed04 	.word	0xe000ed04

00000820 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
     820:	b672      	cpsid	i
    uxCriticalNesting++;
     822:	4a04      	ldr	r2, [pc, #16]	; (834 <vPortEnterCritical+0x14>)
     824:	6813      	ldr	r3, [r2, #0]
     826:	3301      	adds	r3, #1
     828:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
     82a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     82e:	f3bf 8f6f 	isb	sy
}
     832:	4770      	bx	lr
     834:	20000008 	.word	0x20000008

00000838 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
     838:	4b06      	ldr	r3, [pc, #24]	; (854 <vPortExitCritical+0x1c>)
     83a:	681b      	ldr	r3, [r3, #0]
     83c:	2b00      	cmp	r3, #0
     83e:	d101      	bne.n	844 <vPortExitCritical+0xc>
     840:	b672      	cpsid	i
     842:	e7fe      	b.n	842 <vPortExitCritical+0xa>
    uxCriticalNesting--;
     844:	3b01      	subs	r3, #1
     846:	4a03      	ldr	r2, [pc, #12]	; (854 <vPortExitCritical+0x1c>)
     848:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
     84a:	2b00      	cmp	r3, #0
     84c:	d100      	bne.n	850 <vPortExitCritical+0x18>
        portENABLE_INTERRUPTS();
     84e:	b662      	cpsie	i
}
     850:	4770      	bx	lr
     852:	46c0      	nop			; (mov r8, r8)
     854:	20000008 	.word	0x20000008

00000858 <ulSetInterruptMaskFromISR>:
	__asm volatile(
     858:	f3ef 8010 	mrs	r0, PRIMASK
     85c:	b672      	cpsid	i
     85e:	4770      	bx	lr

00000860 <vClearInterruptMaskFromISR>:
	__asm volatile(
     860:	f380 8810 	msr	PRIMASK, r0
     864:	4770      	bx	lr
	...

00000870 <PendSV_Handler>:
	__asm volatile
     870:	f3ef 8009 	mrs	r0, PSP
     874:	4b0e      	ldr	r3, [pc, #56]	; (8b0 <pxCurrentTCBConst>)
     876:	681a      	ldr	r2, [r3, #0]
     878:	3820      	subs	r0, #32
     87a:	6010      	str	r0, [r2, #0]
     87c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     87e:	4644      	mov	r4, r8
     880:	464d      	mov	r5, r9
     882:	4656      	mov	r6, sl
     884:	465f      	mov	r7, fp
     886:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     888:	b508      	push	{r3, lr}
     88a:	b672      	cpsid	i
     88c:	f000 fed4 	bl	1638 <vTaskSwitchContext>
     890:	b662      	cpsie	i
     892:	bc0c      	pop	{r2, r3}
     894:	6811      	ldr	r1, [r2, #0]
     896:	6808      	ldr	r0, [r1, #0]
     898:	3010      	adds	r0, #16
     89a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     89c:	46a0      	mov	r8, r4
     89e:	46a9      	mov	r9, r5
     8a0:	46b2      	mov	sl, r6
     8a2:	46bb      	mov	fp, r7
     8a4:	f380 8809 	msr	PSP, r0
     8a8:	3820      	subs	r0, #32
     8aa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     8ac:	4718      	bx	r3
     8ae:	46c0      	nop			; (mov r8, r8)

000008b0 <pxCurrentTCBConst>:
     8b0:	200043e0 	.word	0x200043e0

000008b4 <SysTick_Handler>:
{
     8b4:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     8b6:	4b07      	ldr	r3, [pc, #28]	; (8d4 <SysTick_Handler+0x20>)
     8b8:	4798      	blx	r3
     8ba:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
     8bc:	4b06      	ldr	r3, [pc, #24]	; (8d8 <SysTick_Handler+0x24>)
     8be:	4798      	blx	r3
     8c0:	2800      	cmp	r0, #0
     8c2:	d003      	beq.n	8cc <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     8c4:	2280      	movs	r2, #128	; 0x80
     8c6:	0552      	lsls	r2, r2, #21
     8c8:	4b04      	ldr	r3, [pc, #16]	; (8dc <SysTick_Handler+0x28>)
     8ca:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     8cc:	0020      	movs	r0, r4
     8ce:	4b04      	ldr	r3, [pc, #16]	; (8e0 <SysTick_Handler+0x2c>)
     8d0:	4798      	blx	r3
}
     8d2:	bd10      	pop	{r4, pc}
     8d4:	00000859 	.word	0x00000859
     8d8:	000013f5 	.word	0x000013f5
     8dc:	e000ed04 	.word	0xe000ed04
     8e0:	00000861 	.word	0x00000861

000008e4 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
     8e4:	b510      	push	{r4, lr}
     8e6:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
     8e8:	4b06      	ldr	r3, [pc, #24]	; (904 <prvIsQueueFull+0x20>)
     8ea:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     8ec:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     8ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     8f0:	429a      	cmp	r2, r3
     8f2:	d004      	beq.n	8fe <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
     8f4:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
     8f6:	4b04      	ldr	r3, [pc, #16]	; (908 <prvIsQueueFull+0x24>)
     8f8:	4798      	blx	r3

	return xReturn;
}
     8fa:	0020      	movs	r0, r4
     8fc:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     8fe:	2401      	movs	r4, #1
     900:	e7f9      	b.n	8f6 <prvIsQueueFull+0x12>
     902:	46c0      	nop			; (mov r8, r8)
     904:	00000821 	.word	0x00000821
     908:	00000839 	.word	0x00000839

0000090c <prvIsQueueEmpty>:
{
     90c:	b510      	push	{r4, lr}
     90e:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
     910:	4b05      	ldr	r3, [pc, #20]	; (928 <prvIsQueueEmpty+0x1c>)
     912:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     914:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     916:	2b00      	cmp	r3, #0
     918:	d004      	beq.n	924 <prvIsQueueEmpty+0x18>
			xReturn = pdFALSE;
     91a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
     91c:	4b03      	ldr	r3, [pc, #12]	; (92c <prvIsQueueEmpty+0x20>)
     91e:	4798      	blx	r3
}
     920:	0020      	movs	r0, r4
     922:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     924:	2401      	movs	r4, #1
     926:	e7f9      	b.n	91c <prvIsQueueEmpty+0x10>
     928:	00000821 	.word	0x00000821
     92c:	00000839 	.word	0x00000839

00000930 <prvCopyDataToQueue>:
{
     930:	b570      	push	{r4, r5, r6, lr}
     932:	0004      	movs	r4, r0
     934:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     936:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     938:	6c02      	ldr	r2, [r0, #64]	; 0x40
     93a:	2a00      	cmp	r2, #0
     93c:	d10a      	bne.n	954 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     93e:	6803      	ldr	r3, [r0, #0]
     940:	2b00      	cmp	r3, #0
     942:	d12e      	bne.n	9a2 <prvCopyDataToQueue+0x72>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     944:	6840      	ldr	r0, [r0, #4]
     946:	4b1b      	ldr	r3, [pc, #108]	; (9b4 <prvCopyDataToQueue+0x84>)
     948:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     94a:	2300      	movs	r3, #0
     94c:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     94e:	3501      	adds	r5, #1
     950:	63a5      	str	r5, [r4, #56]	; 0x38
}
     952:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
     954:	2e00      	cmp	r6, #0
     956:	d10e      	bne.n	976 <prvCopyDataToQueue+0x46>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     958:	6880      	ldr	r0, [r0, #8]
     95a:	4b17      	ldr	r3, [pc, #92]	; (9b8 <prvCopyDataToQueue+0x88>)
     95c:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     95e:	68a3      	ldr	r3, [r4, #8]
     960:	6c22      	ldr	r2, [r4, #64]	; 0x40
     962:	4694      	mov	ip, r2
     964:	4463      	add	r3, ip
     966:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     968:	6862      	ldr	r2, [r4, #4]
     96a:	4293      	cmp	r3, r2
     96c:	d31b      	bcc.n	9a6 <prvCopyDataToQueue+0x76>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     96e:	6823      	ldr	r3, [r4, #0]
     970:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
     972:	2000      	movs	r0, #0
     974:	e7eb      	b.n	94e <prvCopyDataToQueue+0x1e>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     976:	68c0      	ldr	r0, [r0, #12]
     978:	4b0f      	ldr	r3, [pc, #60]	; (9b8 <prvCopyDataToQueue+0x88>)
     97a:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     97c:	6c23      	ldr	r3, [r4, #64]	; 0x40
     97e:	425b      	negs	r3, r3
     980:	68e2      	ldr	r2, [r4, #12]
     982:	18d2      	adds	r2, r2, r3
     984:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     986:	6821      	ldr	r1, [r4, #0]
     988:	428a      	cmp	r2, r1
     98a:	d203      	bcs.n	994 <prvCopyDataToQueue+0x64>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     98c:	6862      	ldr	r2, [r4, #4]
     98e:	4694      	mov	ip, r2
     990:	4463      	add	r3, ip
     992:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
     994:	2e02      	cmp	r6, #2
     996:	d108      	bne.n	9aa <prvCopyDataToQueue+0x7a>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     998:	2d00      	cmp	r5, #0
     99a:	d008      	beq.n	9ae <prvCopyDataToQueue+0x7e>
				--uxMessagesWaiting;
     99c:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
     99e:	2000      	movs	r0, #0
     9a0:	e7d5      	b.n	94e <prvCopyDataToQueue+0x1e>
     9a2:	2000      	movs	r0, #0
     9a4:	e7d3      	b.n	94e <prvCopyDataToQueue+0x1e>
     9a6:	2000      	movs	r0, #0
     9a8:	e7d1      	b.n	94e <prvCopyDataToQueue+0x1e>
     9aa:	2000      	movs	r0, #0
     9ac:	e7cf      	b.n	94e <prvCopyDataToQueue+0x1e>
     9ae:	2000      	movs	r0, #0
     9b0:	e7cd      	b.n	94e <prvCopyDataToQueue+0x1e>
     9b2:	46c0      	nop			; (mov r8, r8)
     9b4:	00001851 	.word	0x00001851
     9b8:	00001da1 	.word	0x00001da1

000009bc <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
     9bc:	b570      	push	{r4, r5, r6, lr}
     9be:	b082      	sub	sp, #8
     9c0:	9001      	str	r0, [sp, #4]
     9c2:	000a      	movs	r2, r1
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     9c4:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
     9c6:	2c00      	cmp	r4, #0
     9c8:	d005      	beq.n	9d6 <prvNotifyQueueSetContainer+0x1a>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     9ca:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     9cc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     9ce:	4299      	cmp	r1, r3
     9d0:	d303      	bcc.n	9da <prvNotifyQueueSetContainer+0x1e>
     9d2:	b672      	cpsid	i
     9d4:	e7fe      	b.n	9d4 <prvNotifyQueueSetContainer+0x18>
		configASSERT( pxQueueSetContainer );
     9d6:	b672      	cpsid	i
     9d8:	e7fe      	b.n	9d8 <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     9da:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     9dc:	428b      	cmp	r3, r1
     9de:	d803      	bhi.n	9e8 <prvNotifyQueueSetContainer+0x2c>
	BaseType_t xReturn = pdFALSE;
     9e0:	2600      	movs	r6, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     9e2:	0030      	movs	r0, r6
     9e4:	b002      	add	sp, #8
     9e6:	bd70      	pop	{r4, r5, r6, pc}
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     9e8:	2345      	movs	r3, #69	; 0x45
     9ea:	5ce5      	ldrb	r5, [r4, r3]
     9ec:	b26d      	sxtb	r5, r5
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     9ee:	a901      	add	r1, sp, #4
     9f0:	0020      	movs	r0, r4
     9f2:	4b0a      	ldr	r3, [pc, #40]	; (a1c <prvNotifyQueueSetContainer+0x60>)
     9f4:	4798      	blx	r3
     9f6:	0006      	movs	r6, r0
			if( cTxLock == queueUNLOCKED )
     9f8:	1c6b      	adds	r3, r5, #1
     9fa:	d10a      	bne.n	a12 <prvNotifyQueueSetContainer+0x56>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     9fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
     9fe:	2b00      	cmp	r3, #0
     a00:	d0ef      	beq.n	9e2 <prvNotifyQueueSetContainer+0x26>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     a02:	0020      	movs	r0, r4
     a04:	3024      	adds	r0, #36	; 0x24
     a06:	4b06      	ldr	r3, [pc, #24]	; (a20 <prvNotifyQueueSetContainer+0x64>)
     a08:	4798      	blx	r3
     a0a:	2800      	cmp	r0, #0
     a0c:	d0e9      	beq.n	9e2 <prvNotifyQueueSetContainer+0x26>
						xReturn = pdTRUE;
     a0e:	2601      	movs	r6, #1
		return xReturn;
     a10:	e7e7      	b.n	9e2 <prvNotifyQueueSetContainer+0x26>
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
     a12:	3501      	adds	r5, #1
     a14:	b26d      	sxtb	r5, r5
     a16:	2345      	movs	r3, #69	; 0x45
     a18:	54e5      	strb	r5, [r4, r3]
     a1a:	e7e2      	b.n	9e2 <prvNotifyQueueSetContainer+0x26>
     a1c:	00000931 	.word	0x00000931
     a20:	00001721 	.word	0x00001721

00000a24 <prvCopyDataFromQueue>:
{
     a24:	b510      	push	{r4, lr}
     a26:	000c      	movs	r4, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     a28:	6c02      	ldr	r2, [r0, #64]	; 0x40
     a2a:	2a00      	cmp	r2, #0
     a2c:	d00b      	beq.n	a46 <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     a2e:	68c3      	ldr	r3, [r0, #12]
     a30:	189b      	adds	r3, r3, r2
     a32:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     a34:	6841      	ldr	r1, [r0, #4]
     a36:	428b      	cmp	r3, r1
     a38:	d301      	bcc.n	a3e <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     a3a:	6803      	ldr	r3, [r0, #0]
     a3c:	60c3      	str	r3, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     a3e:	68c1      	ldr	r1, [r0, #12]
     a40:	0020      	movs	r0, r4
     a42:	4b01      	ldr	r3, [pc, #4]	; (a48 <prvCopyDataFromQueue+0x24>)
     a44:	4798      	blx	r3
}
     a46:	bd10      	pop	{r4, pc}
     a48:	00001da1 	.word	0x00001da1

00000a4c <prvUnlockQueue>:
{
     a4c:	b570      	push	{r4, r5, r6, lr}
     a4e:	0005      	movs	r5, r0
	taskENTER_CRITICAL();
     a50:	4b21      	ldr	r3, [pc, #132]	; (ad8 <prvUnlockQueue+0x8c>)
     a52:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
     a54:	2345      	movs	r3, #69	; 0x45
     a56:	5cec      	ldrb	r4, [r5, r3]
     a58:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     a5a:	e00a      	b.n	a72 <prvUnlockQueue+0x26>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a5c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     a5e:	2b00      	cmp	r3, #0
     a60:	d018      	beq.n	a94 <prvUnlockQueue+0x48>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a62:	0028      	movs	r0, r5
     a64:	3024      	adds	r0, #36	; 0x24
     a66:	4b1d      	ldr	r3, [pc, #116]	; (adc <prvUnlockQueue+0x90>)
     a68:	4798      	blx	r3
     a6a:	2800      	cmp	r0, #0
     a6c:	d10f      	bne.n	a8e <prvUnlockQueue+0x42>
			--cTxLock;
     a6e:	3c01      	subs	r4, #1
     a70:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     a72:	2c00      	cmp	r4, #0
     a74:	dd0e      	ble.n	a94 <prvUnlockQueue+0x48>
				if( pxQueue->pxQueueSetContainer != NULL )
     a76:	6cab      	ldr	r3, [r5, #72]	; 0x48
     a78:	2b00      	cmp	r3, #0
     a7a:	d0ef      	beq.n	a5c <prvUnlockQueue+0x10>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     a7c:	2100      	movs	r1, #0
     a7e:	0028      	movs	r0, r5
     a80:	4b17      	ldr	r3, [pc, #92]	; (ae0 <prvUnlockQueue+0x94>)
     a82:	4798      	blx	r3
     a84:	2800      	cmp	r0, #0
     a86:	d0f2      	beq.n	a6e <prvUnlockQueue+0x22>
						vTaskMissedYield();
     a88:	4b16      	ldr	r3, [pc, #88]	; (ae4 <prvUnlockQueue+0x98>)
     a8a:	4798      	blx	r3
     a8c:	e7ef      	b.n	a6e <prvUnlockQueue+0x22>
							vTaskMissedYield();
     a8e:	4b15      	ldr	r3, [pc, #84]	; (ae4 <prvUnlockQueue+0x98>)
     a90:	4798      	blx	r3
     a92:	e7ec      	b.n	a6e <prvUnlockQueue+0x22>
		pxQueue->cTxLock = queueUNLOCKED;
     a94:	22ff      	movs	r2, #255	; 0xff
     a96:	2345      	movs	r3, #69	; 0x45
     a98:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     a9a:	4b13      	ldr	r3, [pc, #76]	; (ae8 <prvUnlockQueue+0x9c>)
     a9c:	4798      	blx	r3
	taskENTER_CRITICAL();
     a9e:	4b0e      	ldr	r3, [pc, #56]	; (ad8 <prvUnlockQueue+0x8c>)
     aa0:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
     aa2:	2344      	movs	r3, #68	; 0x44
     aa4:	5cec      	ldrb	r4, [r5, r3]
     aa6:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     aa8:	e001      	b.n	aae <prvUnlockQueue+0x62>
				--cRxLock;
     aaa:	3c01      	subs	r4, #1
     aac:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     aae:	2c00      	cmp	r4, #0
     ab0:	dd0b      	ble.n	aca <prvUnlockQueue+0x7e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ab2:	692b      	ldr	r3, [r5, #16]
     ab4:	2b00      	cmp	r3, #0
     ab6:	d008      	beq.n	aca <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ab8:	0028      	movs	r0, r5
     aba:	3010      	adds	r0, #16
     abc:	4b07      	ldr	r3, [pc, #28]	; (adc <prvUnlockQueue+0x90>)
     abe:	4798      	blx	r3
     ac0:	2800      	cmp	r0, #0
     ac2:	d0f2      	beq.n	aaa <prvUnlockQueue+0x5e>
					vTaskMissedYield();
     ac4:	4b07      	ldr	r3, [pc, #28]	; (ae4 <prvUnlockQueue+0x98>)
     ac6:	4798      	blx	r3
     ac8:	e7ef      	b.n	aaa <prvUnlockQueue+0x5e>
		pxQueue->cRxLock = queueUNLOCKED;
     aca:	22ff      	movs	r2, #255	; 0xff
     acc:	2344      	movs	r3, #68	; 0x44
     ace:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     ad0:	4b05      	ldr	r3, [pc, #20]	; (ae8 <prvUnlockQueue+0x9c>)
     ad2:	4798      	blx	r3
}
     ad4:	bd70      	pop	{r4, r5, r6, pc}
     ad6:	46c0      	nop			; (mov r8, r8)
     ad8:	00000821 	.word	0x00000821
     adc:	00001721 	.word	0x00001721
     ae0:	000009bd 	.word	0x000009bd
     ae4:	00001825 	.word	0x00001825
     ae8:	00000839 	.word	0x00000839

00000aec <xQueueGenericReset>:
{
     aec:	b570      	push	{r4, r5, r6, lr}
     aee:	0004      	movs	r4, r0
     af0:	000d      	movs	r5, r1
	configASSERT( pxQueue );
     af2:	2800      	cmp	r0, #0
     af4:	d023      	beq.n	b3e <xQueueGenericReset+0x52>
	taskENTER_CRITICAL();
     af6:	4b18      	ldr	r3, [pc, #96]	; (b58 <xQueueGenericReset+0x6c>)
     af8:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     afa:	6822      	ldr	r2, [r4, #0]
     afc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     afe:	6c20      	ldr	r0, [r4, #64]	; 0x40
     b00:	0001      	movs	r1, r0
     b02:	4359      	muls	r1, r3
     b04:	1851      	adds	r1, r2, r1
     b06:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     b08:	2100      	movs	r1, #0
     b0a:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
     b0c:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     b0e:	3b01      	subs	r3, #1
     b10:	4343      	muls	r3, r0
     b12:	18d3      	adds	r3, r2, r3
     b14:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
     b16:	23ff      	movs	r3, #255	; 0xff
     b18:	2244      	movs	r2, #68	; 0x44
     b1a:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock = queueUNLOCKED;
     b1c:	3201      	adds	r2, #1
     b1e:	54a3      	strb	r3, [r4, r2]
		if( xNewQueue == pdFALSE )
     b20:	2d00      	cmp	r5, #0
     b22:	d111      	bne.n	b48 <xQueueGenericReset+0x5c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b24:	6923      	ldr	r3, [r4, #16]
     b26:	2b00      	cmp	r3, #0
     b28:	d005      	beq.n	b36 <xQueueGenericReset+0x4a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b2a:	0020      	movs	r0, r4
     b2c:	3010      	adds	r0, #16
     b2e:	4b0b      	ldr	r3, [pc, #44]	; (b5c <xQueueGenericReset+0x70>)
     b30:	4798      	blx	r3
     b32:	2800      	cmp	r0, #0
     b34:	d105      	bne.n	b42 <xQueueGenericReset+0x56>
	taskEXIT_CRITICAL();
     b36:	4b0a      	ldr	r3, [pc, #40]	; (b60 <xQueueGenericReset+0x74>)
     b38:	4798      	blx	r3
}
     b3a:	2001      	movs	r0, #1
     b3c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
     b3e:	b672      	cpsid	i
     b40:	e7fe      	b.n	b40 <xQueueGenericReset+0x54>
					queueYIELD_IF_USING_PREEMPTION();
     b42:	4b08      	ldr	r3, [pc, #32]	; (b64 <xQueueGenericReset+0x78>)
     b44:	4798      	blx	r3
     b46:	e7f6      	b.n	b36 <xQueueGenericReset+0x4a>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     b48:	0020      	movs	r0, r4
     b4a:	3010      	adds	r0, #16
     b4c:	4d06      	ldr	r5, [pc, #24]	; (b68 <xQueueGenericReset+0x7c>)
     b4e:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     b50:	0020      	movs	r0, r4
     b52:	3024      	adds	r0, #36	; 0x24
     b54:	47a8      	blx	r5
     b56:	e7ee      	b.n	b36 <xQueueGenericReset+0x4a>
     b58:	00000821 	.word	0x00000821
     b5c:	00001721 	.word	0x00001721
     b60:	00000839 	.word	0x00000839
     b64:	00000809 	.word	0x00000809
     b68:	00000311 	.word	0x00000311

00000b6c <prvInitialiseNewQueue>:
{
     b6c:	b570      	push	{r4, r5, r6, lr}
     b6e:	001d      	movs	r5, r3
     b70:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
     b72:	2900      	cmp	r1, #0
     b74:	d00b      	beq.n	b8e <prvInitialiseNewQueue+0x22>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     b76:	6022      	str	r2, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
     b78:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
     b7a:	6421      	str	r1, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     b7c:	2101      	movs	r1, #1
     b7e:	0020      	movs	r0, r4
     b80:	4b04      	ldr	r3, [pc, #16]	; (b94 <prvInitialiseNewQueue+0x28>)
     b82:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
     b84:	2350      	movs	r3, #80	; 0x50
     b86:	54e5      	strb	r5, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
     b88:	2300      	movs	r3, #0
     b8a:	64a3      	str	r3, [r4, #72]	; 0x48
}
     b8c:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     b8e:	6024      	str	r4, [r4, #0]
     b90:	e7f2      	b.n	b78 <prvInitialiseNewQueue+0xc>
     b92:	46c0      	nop			; (mov r8, r8)
     b94:	00000aed 	.word	0x00000aed

00000b98 <xQueueGenericCreate>:
	{
     b98:	b5f0      	push	{r4, r5, r6, r7, lr}
     b9a:	b083      	sub	sp, #12
     b9c:	0006      	movs	r6, r0
     b9e:	000f      	movs	r7, r1
     ba0:	0015      	movs	r5, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
     ba2:	2800      	cmp	r0, #0
     ba4:	d101      	bne.n	baa <xQueueGenericCreate+0x12>
     ba6:	b672      	cpsid	i
     ba8:	e7fe      	b.n	ba8 <xQueueGenericCreate+0x10>
		if( uxItemSize == ( UBaseType_t ) 0 )
     baa:	2900      	cmp	r1, #0
     bac:	d002      	beq.n	bb4 <xQueueGenericCreate+0x1c>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     bae:	0008      	movs	r0, r1
     bb0:	4370      	muls	r0, r6
     bb2:	e000      	b.n	bb6 <xQueueGenericCreate+0x1e>
			xQueueSizeInBytes = ( size_t ) 0;
     bb4:	2000      	movs	r0, #0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     bb6:	3054      	adds	r0, #84	; 0x54
     bb8:	4b07      	ldr	r3, [pc, #28]	; (bd8 <xQueueGenericCreate+0x40>)
     bba:	4798      	blx	r3
     bbc:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
     bbe:	d007      	beq.n	bd0 <xQueueGenericCreate+0x38>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
     bc0:	0002      	movs	r2, r0
     bc2:	3254      	adds	r2, #84	; 0x54
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     bc4:	9000      	str	r0, [sp, #0]
     bc6:	002b      	movs	r3, r5
     bc8:	0039      	movs	r1, r7
     bca:	0030      	movs	r0, r6
     bcc:	4d03      	ldr	r5, [pc, #12]	; (bdc <xQueueGenericCreate+0x44>)
     bce:	47a8      	blx	r5
	}
     bd0:	0020      	movs	r0, r4
     bd2:	b003      	add	sp, #12
     bd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
     bd6:	46c0      	nop			; (mov r8, r8)
     bd8:	00000219 	.word	0x00000219
     bdc:	00000b6d 	.word	0x00000b6d

00000be0 <xQueueGenericSend>:
{
     be0:	b5f0      	push	{r4, r5, r6, r7, lr}
     be2:	b085      	sub	sp, #20
     be4:	0004      	movs	r4, r0
     be6:	000f      	movs	r7, r1
     be8:	9201      	str	r2, [sp, #4]
     bea:	001e      	movs	r6, r3
	configASSERT( pxQueue );
     bec:	2800      	cmp	r0, #0
     bee:	d006      	beq.n	bfe <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     bf0:	2900      	cmp	r1, #0
     bf2:	d006      	beq.n	c02 <xQueueGenericSend+0x22>
     bf4:	2501      	movs	r5, #1
     bf6:	2d00      	cmp	r5, #0
     bf8:	d10a      	bne.n	c10 <xQueueGenericSend+0x30>
     bfa:	b672      	cpsid	i
     bfc:	e7fe      	b.n	bfc <xQueueGenericSend+0x1c>
	configASSERT( pxQueue );
     bfe:	b672      	cpsid	i
     c00:	e7fe      	b.n	c00 <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     c02:	6c03      	ldr	r3, [r0, #64]	; 0x40
     c04:	2b00      	cmp	r3, #0
     c06:	d101      	bne.n	c0c <xQueueGenericSend+0x2c>
     c08:	2501      	movs	r5, #1
     c0a:	e7f4      	b.n	bf6 <xQueueGenericSend+0x16>
     c0c:	2500      	movs	r5, #0
     c0e:	e7f2      	b.n	bf6 <xQueueGenericSend+0x16>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     c10:	2e02      	cmp	r6, #2
     c12:	d003      	beq.n	c1c <xQueueGenericSend+0x3c>
     c14:	2d00      	cmp	r5, #0
     c16:	d106      	bne.n	c26 <xQueueGenericSend+0x46>
     c18:	b672      	cpsid	i
     c1a:	e7fe      	b.n	c1a <xQueueGenericSend+0x3a>
     c1c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     c1e:	2b01      	cmp	r3, #1
     c20:	d0f8      	beq.n	c14 <xQueueGenericSend+0x34>
     c22:	2500      	movs	r5, #0
     c24:	e7f6      	b.n	c14 <xQueueGenericSend+0x34>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     c26:	4b44      	ldr	r3, [pc, #272]	; (d38 <xQueueGenericSend+0x158>)
     c28:	4798      	blx	r3
     c2a:	2800      	cmp	r0, #0
     c2c:	d103      	bne.n	c36 <xQueueGenericSend+0x56>
     c2e:	9b01      	ldr	r3, [sp, #4]
     c30:	2b00      	cmp	r3, #0
     c32:	d000      	beq.n	c36 <xQueueGenericSend+0x56>
     c34:	2500      	movs	r5, #0
     c36:	2d00      	cmp	r5, #0
     c38:	d101      	bne.n	c3e <xQueueGenericSend+0x5e>
     c3a:	b672      	cpsid	i
     c3c:	e7fe      	b.n	c3c <xQueueGenericSend+0x5c>
     c3e:	2500      	movs	r5, #0
     c40:	e042      	b.n	cc8 <xQueueGenericSend+0xe8>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     c42:	0032      	movs	r2, r6
     c44:	0039      	movs	r1, r7
     c46:	0020      	movs	r0, r4
     c48:	4b3c      	ldr	r3, [pc, #240]	; (d3c <xQueueGenericSend+0x15c>)
     c4a:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
     c4c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     c4e:	2b00      	cmp	r3, #0
     c50:	d00c      	beq.n	c6c <xQueueGenericSend+0x8c>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     c52:	0031      	movs	r1, r6
     c54:	0020      	movs	r0, r4
     c56:	4b3a      	ldr	r3, [pc, #232]	; (d40 <xQueueGenericSend+0x160>)
     c58:	4798      	blx	r3
     c5a:	2800      	cmp	r0, #0
     c5c:	d001      	beq.n	c62 <xQueueGenericSend+0x82>
							queueYIELD_IF_USING_PREEMPTION();
     c5e:	4b39      	ldr	r3, [pc, #228]	; (d44 <xQueueGenericSend+0x164>)
     c60:	4798      	blx	r3
				taskEXIT_CRITICAL();
     c62:	4b39      	ldr	r3, [pc, #228]	; (d48 <xQueueGenericSend+0x168>)
     c64:	4798      	blx	r3
				return pdPASS;
     c66:	2001      	movs	r0, #1
}
     c68:	b005      	add	sp, #20
     c6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c6c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     c6e:	2b00      	cmp	r3, #0
     c70:	d008      	beq.n	c84 <xQueueGenericSend+0xa4>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c72:	0020      	movs	r0, r4
     c74:	3024      	adds	r0, #36	; 0x24
     c76:	4b35      	ldr	r3, [pc, #212]	; (d4c <xQueueGenericSend+0x16c>)
     c78:	4798      	blx	r3
     c7a:	2800      	cmp	r0, #0
     c7c:	d0f1      	beq.n	c62 <xQueueGenericSend+0x82>
								queueYIELD_IF_USING_PREEMPTION();
     c7e:	4b31      	ldr	r3, [pc, #196]	; (d44 <xQueueGenericSend+0x164>)
     c80:	4798      	blx	r3
     c82:	e7ee      	b.n	c62 <xQueueGenericSend+0x82>
						else if( xYieldRequired != pdFALSE )
     c84:	2800      	cmp	r0, #0
     c86:	d0ec      	beq.n	c62 <xQueueGenericSend+0x82>
							queueYIELD_IF_USING_PREEMPTION();
     c88:	4b2e      	ldr	r3, [pc, #184]	; (d44 <xQueueGenericSend+0x164>)
     c8a:	4798      	blx	r3
     c8c:	e7e9      	b.n	c62 <xQueueGenericSend+0x82>
					taskEXIT_CRITICAL();
     c8e:	4b2e      	ldr	r3, [pc, #184]	; (d48 <xQueueGenericSend+0x168>)
     c90:	4798      	blx	r3
					return errQUEUE_FULL;
     c92:	2000      	movs	r0, #0
     c94:	e7e8      	b.n	c68 <xQueueGenericSend+0x88>
		prvLockQueue( pxQueue );
     c96:	4b2c      	ldr	r3, [pc, #176]	; (d48 <xQueueGenericSend+0x168>)
     c98:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c9a:	a901      	add	r1, sp, #4
     c9c:	a802      	add	r0, sp, #8
     c9e:	4b2c      	ldr	r3, [pc, #176]	; (d50 <xQueueGenericSend+0x170>)
     ca0:	4798      	blx	r3
     ca2:	2800      	cmp	r0, #0
     ca4:	d141      	bne.n	d2a <xQueueGenericSend+0x14a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     ca6:	0020      	movs	r0, r4
     ca8:	4b2a      	ldr	r3, [pc, #168]	; (d54 <xQueueGenericSend+0x174>)
     caa:	4798      	blx	r3
     cac:	2800      	cmp	r0, #0
     cae:	d036      	beq.n	d1e <xQueueGenericSend+0x13e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     cb0:	0020      	movs	r0, r4
     cb2:	3010      	adds	r0, #16
     cb4:	9901      	ldr	r1, [sp, #4]
     cb6:	4b28      	ldr	r3, [pc, #160]	; (d58 <xQueueGenericSend+0x178>)
     cb8:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     cba:	0020      	movs	r0, r4
     cbc:	4b27      	ldr	r3, [pc, #156]	; (d5c <xQueueGenericSend+0x17c>)
     cbe:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     cc0:	4b27      	ldr	r3, [pc, #156]	; (d60 <xQueueGenericSend+0x180>)
     cc2:	4798      	blx	r3
     cc4:	2800      	cmp	r0, #0
     cc6:	d027      	beq.n	d18 <xQueueGenericSend+0x138>
		taskENTER_CRITICAL();
     cc8:	4b26      	ldr	r3, [pc, #152]	; (d64 <xQueueGenericSend+0x184>)
     cca:	4798      	blx	r3
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     ccc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     cce:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     cd0:	4293      	cmp	r3, r2
     cd2:	d3b6      	bcc.n	c42 <xQueueGenericSend+0x62>
     cd4:	2e02      	cmp	r6, #2
     cd6:	d0b4      	beq.n	c42 <xQueueGenericSend+0x62>
				if( xTicksToWait == ( TickType_t ) 0 )
     cd8:	9b01      	ldr	r3, [sp, #4]
     cda:	2b00      	cmp	r3, #0
     cdc:	d0d7      	beq.n	c8e <xQueueGenericSend+0xae>
				else if( xEntryTimeSet == pdFALSE )
     cde:	2d00      	cmp	r5, #0
     ce0:	d103      	bne.n	cea <xQueueGenericSend+0x10a>
					vTaskInternalSetTimeOutState( &xTimeOut );
     ce2:	a802      	add	r0, sp, #8
     ce4:	4b20      	ldr	r3, [pc, #128]	; (d68 <xQueueGenericSend+0x188>)
     ce6:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
     ce8:	3501      	adds	r5, #1
		taskEXIT_CRITICAL();
     cea:	4b17      	ldr	r3, [pc, #92]	; (d48 <xQueueGenericSend+0x168>)
     cec:	4798      	blx	r3
		vTaskSuspendAll();
     cee:	4b1f      	ldr	r3, [pc, #124]	; (d6c <xQueueGenericSend+0x18c>)
     cf0:	4798      	blx	r3
		prvLockQueue( pxQueue );
     cf2:	4b1c      	ldr	r3, [pc, #112]	; (d64 <xQueueGenericSend+0x184>)
     cf4:	4798      	blx	r3
     cf6:	2344      	movs	r3, #68	; 0x44
     cf8:	5ce3      	ldrb	r3, [r4, r3]
     cfa:	b25b      	sxtb	r3, r3
     cfc:	3301      	adds	r3, #1
     cfe:	d102      	bne.n	d06 <xQueueGenericSend+0x126>
     d00:	2200      	movs	r2, #0
     d02:	2344      	movs	r3, #68	; 0x44
     d04:	54e2      	strb	r2, [r4, r3]
     d06:	2345      	movs	r3, #69	; 0x45
     d08:	5ce3      	ldrb	r3, [r4, r3]
     d0a:	b25b      	sxtb	r3, r3
     d0c:	3301      	adds	r3, #1
     d0e:	d1c2      	bne.n	c96 <xQueueGenericSend+0xb6>
     d10:	2200      	movs	r2, #0
     d12:	2345      	movs	r3, #69	; 0x45
     d14:	54e2      	strb	r2, [r4, r3]
     d16:	e7be      	b.n	c96 <xQueueGenericSend+0xb6>
					portYIELD_WITHIN_API();
     d18:	4b0a      	ldr	r3, [pc, #40]	; (d44 <xQueueGenericSend+0x164>)
     d1a:	4798      	blx	r3
     d1c:	e7d4      	b.n	cc8 <xQueueGenericSend+0xe8>
				prvUnlockQueue( pxQueue );
     d1e:	0020      	movs	r0, r4
     d20:	4b0e      	ldr	r3, [pc, #56]	; (d5c <xQueueGenericSend+0x17c>)
     d22:	4798      	blx	r3
				( void ) xTaskResumeAll();
     d24:	4b0e      	ldr	r3, [pc, #56]	; (d60 <xQueueGenericSend+0x180>)
     d26:	4798      	blx	r3
     d28:	e7ce      	b.n	cc8 <xQueueGenericSend+0xe8>
			prvUnlockQueue( pxQueue );
     d2a:	0020      	movs	r0, r4
     d2c:	4b0b      	ldr	r3, [pc, #44]	; (d5c <xQueueGenericSend+0x17c>)
     d2e:	4798      	blx	r3
			( void ) xTaskResumeAll();
     d30:	4b0b      	ldr	r3, [pc, #44]	; (d60 <xQueueGenericSend+0x180>)
     d32:	4798      	blx	r3
			return errQUEUE_FULL;
     d34:	2000      	movs	r0, #0
     d36:	e797      	b.n	c68 <xQueueGenericSend+0x88>
     d38:	00001831 	.word	0x00001831
     d3c:	00000931 	.word	0x00000931
     d40:	000009bd 	.word	0x000009bd
     d44:	00000809 	.word	0x00000809
     d48:	00000839 	.word	0x00000839
     d4c:	00001721 	.word	0x00001721
     d50:	000017b5 	.word	0x000017b5
     d54:	000008e5 	.word	0x000008e5
     d58:	000016bd 	.word	0x000016bd
     d5c:	00000a4d 	.word	0x00000a4d
     d60:	00001501 	.word	0x00001501
     d64:	00000821 	.word	0x00000821
     d68:	000017a5 	.word	0x000017a5
     d6c:	000013d9 	.word	0x000013d9

00000d70 <xQueueGenericSendFromISR>:
{
     d70:	b5f0      	push	{r4, r5, r6, r7, lr}
     d72:	b083      	sub	sp, #12
     d74:	0004      	movs	r4, r0
     d76:	9100      	str	r1, [sp, #0]
     d78:	0017      	movs	r7, r2
     d7a:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     d7c:	2800      	cmp	r0, #0
     d7e:	d007      	beq.n	d90 <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d80:	9b00      	ldr	r3, [sp, #0]
     d82:	2b00      	cmp	r3, #0
     d84:	d006      	beq.n	d94 <xQueueGenericSendFromISR+0x24>
     d86:	2301      	movs	r3, #1
     d88:	2b00      	cmp	r3, #0
     d8a:	d10a      	bne.n	da2 <xQueueGenericSendFromISR+0x32>
     d8c:	b672      	cpsid	i
     d8e:	e7fe      	b.n	d8e <xQueueGenericSendFromISR+0x1e>
	configASSERT( pxQueue );
     d90:	b672      	cpsid	i
     d92:	e7fe      	b.n	d92 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d94:	6c03      	ldr	r3, [r0, #64]	; 0x40
     d96:	2b00      	cmp	r3, #0
     d98:	d101      	bne.n	d9e <xQueueGenericSendFromISR+0x2e>
     d9a:	3301      	adds	r3, #1
     d9c:	e7f4      	b.n	d88 <xQueueGenericSendFromISR+0x18>
     d9e:	2300      	movs	r3, #0
     da0:	e7f2      	b.n	d88 <xQueueGenericSendFromISR+0x18>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     da2:	2d02      	cmp	r5, #2
     da4:	d003      	beq.n	dae <xQueueGenericSendFromISR+0x3e>
     da6:	2b00      	cmp	r3, #0
     da8:	d106      	bne.n	db8 <xQueueGenericSendFromISR+0x48>
     daa:	b672      	cpsid	i
     dac:	e7fe      	b.n	dac <xQueueGenericSendFromISR+0x3c>
     dae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     db0:	2a01      	cmp	r2, #1
     db2:	d0f8      	beq.n	da6 <xQueueGenericSendFromISR+0x36>
     db4:	2300      	movs	r3, #0
     db6:	e7f6      	b.n	da6 <xQueueGenericSendFromISR+0x36>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     db8:	4b23      	ldr	r3, [pc, #140]	; (e48 <xQueueGenericSendFromISR+0xd8>)
     dba:	4798      	blx	r3
     dbc:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     dbe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     dc0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     dc2:	4293      	cmp	r3, r2
     dc4:	d301      	bcc.n	dca <xQueueGenericSendFromISR+0x5a>
     dc6:	2d02      	cmp	r5, #2
     dc8:	d132      	bne.n	e30 <xQueueGenericSendFromISR+0xc0>
			const int8_t cTxLock = pxQueue->cTxLock;
     dca:	2345      	movs	r3, #69	; 0x45
     dcc:	5ce6      	ldrb	r6, [r4, r3]
     dce:	b276      	sxtb	r6, r6
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     dd0:	002a      	movs	r2, r5
     dd2:	9900      	ldr	r1, [sp, #0]
     dd4:	0020      	movs	r0, r4
     dd6:	4b1d      	ldr	r3, [pc, #116]	; (e4c <xQueueGenericSendFromISR+0xdc>)
     dd8:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
     dda:	1c73      	adds	r3, r6, #1
     ddc:	d122      	bne.n	e24 <xQueueGenericSendFromISR+0xb4>
					if( pxQueue->pxQueueSetContainer != NULL )
     dde:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     de0:	2b00      	cmp	r3, #0
     de2:	d010      	beq.n	e06 <xQueueGenericSendFromISR+0x96>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     de4:	0029      	movs	r1, r5
     de6:	0020      	movs	r0, r4
     de8:	4b19      	ldr	r3, [pc, #100]	; (e50 <xQueueGenericSendFromISR+0xe0>)
     dea:	4798      	blx	r3
     dec:	2800      	cmp	r0, #0
     dee:	d021      	beq.n	e34 <xQueueGenericSendFromISR+0xc4>
							if( pxHigherPriorityTaskWoken != NULL )
     df0:	2f00      	cmp	r7, #0
     df2:	d021      	beq.n	e38 <xQueueGenericSendFromISR+0xc8>
								*pxHigherPriorityTaskWoken = pdTRUE;
     df4:	2301      	movs	r3, #1
     df6:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
     df8:	2401      	movs	r4, #1
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
     dfa:	9801      	ldr	r0, [sp, #4]
     dfc:	4b15      	ldr	r3, [pc, #84]	; (e54 <xQueueGenericSendFromISR+0xe4>)
     dfe:	4798      	blx	r3
}
     e00:	0020      	movs	r0, r4
     e02:	b003      	add	sp, #12
     e04:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e06:	6a63      	ldr	r3, [r4, #36]	; 0x24
     e08:	2b00      	cmp	r3, #0
     e0a:	d017      	beq.n	e3c <xQueueGenericSendFromISR+0xcc>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e0c:	0020      	movs	r0, r4
     e0e:	3024      	adds	r0, #36	; 0x24
     e10:	4b11      	ldr	r3, [pc, #68]	; (e58 <xQueueGenericSendFromISR+0xe8>)
     e12:	4798      	blx	r3
     e14:	2800      	cmp	r0, #0
     e16:	d013      	beq.n	e40 <xQueueGenericSendFromISR+0xd0>
								if( pxHigherPriorityTaskWoken != NULL )
     e18:	2f00      	cmp	r7, #0
     e1a:	d013      	beq.n	e44 <xQueueGenericSendFromISR+0xd4>
									*pxHigherPriorityTaskWoken = pdTRUE;
     e1c:	2301      	movs	r3, #1
     e1e:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
     e20:	2401      	movs	r4, #1
     e22:	e7ea      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     e24:	1c73      	adds	r3, r6, #1
     e26:	b25b      	sxtb	r3, r3
     e28:	2245      	movs	r2, #69	; 0x45
     e2a:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
     e2c:	2401      	movs	r4, #1
     e2e:	e7e4      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
			xReturn = errQUEUE_FULL;
     e30:	2400      	movs	r4, #0
     e32:	e7e2      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
			xReturn = pdPASS;
     e34:	2401      	movs	r4, #1
     e36:	e7e0      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
     e38:	2401      	movs	r4, #1
     e3a:	e7de      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
     e3c:	2401      	movs	r4, #1
     e3e:	e7dc      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
     e40:	2401      	movs	r4, #1
     e42:	e7da      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
     e44:	2401      	movs	r4, #1
     e46:	e7d8      	b.n	dfa <xQueueGenericSendFromISR+0x8a>
     e48:	00000859 	.word	0x00000859
     e4c:	00000931 	.word	0x00000931
     e50:	000009bd 	.word	0x000009bd
     e54:	00000861 	.word	0x00000861
     e58:	00001721 	.word	0x00001721

00000e5c <xQueueReceive>:
{
     e5c:	b5f0      	push	{r4, r5, r6, r7, lr}
     e5e:	b085      	sub	sp, #20
     e60:	0004      	movs	r4, r0
     e62:	000e      	movs	r6, r1
     e64:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
     e66:	2800      	cmp	r0, #0
     e68:	d006      	beq.n	e78 <xQueueReceive+0x1c>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     e6a:	2900      	cmp	r1, #0
     e6c:	d006      	beq.n	e7c <xQueueReceive+0x20>
     e6e:	2501      	movs	r5, #1
     e70:	2d00      	cmp	r5, #0
     e72:	d10a      	bne.n	e8a <xQueueReceive+0x2e>
     e74:	b672      	cpsid	i
     e76:	e7fe      	b.n	e76 <xQueueReceive+0x1a>
	configASSERT( ( pxQueue ) );
     e78:	b672      	cpsid	i
     e7a:	e7fe      	b.n	e7a <xQueueReceive+0x1e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     e7c:	6c03      	ldr	r3, [r0, #64]	; 0x40
     e7e:	2b00      	cmp	r3, #0
     e80:	d101      	bne.n	e86 <xQueueReceive+0x2a>
     e82:	2501      	movs	r5, #1
     e84:	e7f4      	b.n	e70 <xQueueReceive+0x14>
     e86:	2500      	movs	r5, #0
     e88:	e7f2      	b.n	e70 <xQueueReceive+0x14>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     e8a:	4b3e      	ldr	r3, [pc, #248]	; (f84 <xQueueReceive+0x128>)
     e8c:	4798      	blx	r3
     e8e:	2800      	cmp	r0, #0
     e90:	d103      	bne.n	e9a <xQueueReceive+0x3e>
     e92:	9b01      	ldr	r3, [sp, #4]
     e94:	2b00      	cmp	r3, #0
     e96:	d000      	beq.n	e9a <xQueueReceive+0x3e>
     e98:	2500      	movs	r5, #0
     e9a:	2d00      	cmp	r5, #0
     e9c:	d101      	bne.n	ea2 <xQueueReceive+0x46>
     e9e:	b672      	cpsid	i
     ea0:	e7fe      	b.n	ea0 <xQueueReceive+0x44>
     ea2:	2700      	movs	r7, #0
     ea4:	e02b      	b.n	efe <xQueueReceive+0xa2>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ea6:	0031      	movs	r1, r6
     ea8:	0020      	movs	r0, r4
     eaa:	4b37      	ldr	r3, [pc, #220]	; (f88 <xQueueReceive+0x12c>)
     eac:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     eae:	3d01      	subs	r5, #1
     eb0:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     eb2:	6923      	ldr	r3, [r4, #16]
     eb4:	2b00      	cmp	r3, #0
     eb6:	d007      	beq.n	ec8 <xQueueReceive+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     eb8:	0020      	movs	r0, r4
     eba:	3010      	adds	r0, #16
     ebc:	4b33      	ldr	r3, [pc, #204]	; (f8c <xQueueReceive+0x130>)
     ebe:	4798      	blx	r3
     ec0:	2800      	cmp	r0, #0
     ec2:	d001      	beq.n	ec8 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
     ec4:	4b32      	ldr	r3, [pc, #200]	; (f90 <xQueueReceive+0x134>)
     ec6:	4798      	blx	r3
				taskEXIT_CRITICAL();
     ec8:	4b32      	ldr	r3, [pc, #200]	; (f94 <xQueueReceive+0x138>)
     eca:	4798      	blx	r3
				return pdPASS;
     ecc:	2001      	movs	r0, #1
}
     ece:	b005      	add	sp, #20
     ed0:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
     ed2:	4b30      	ldr	r3, [pc, #192]	; (f94 <xQueueReceive+0x138>)
     ed4:	4798      	blx	r3
					return errQUEUE_EMPTY;
     ed6:	2000      	movs	r0, #0
     ed8:	e7f9      	b.n	ece <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
     eda:	a802      	add	r0, sp, #8
     edc:	4b2e      	ldr	r3, [pc, #184]	; (f98 <xQueueReceive+0x13c>)
     ede:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
     ee0:	3701      	adds	r7, #1
     ee2:	e016      	b.n	f12 <xQueueReceive+0xb6>
		prvLockQueue( pxQueue );
     ee4:	2200      	movs	r2, #0
     ee6:	2344      	movs	r3, #68	; 0x44
     ee8:	54e2      	strb	r2, [r4, r3]
     eea:	e01d      	b.n	f28 <xQueueReceive+0xcc>
     eec:	2200      	movs	r2, #0
     eee:	2345      	movs	r3, #69	; 0x45
     ef0:	54e2      	strb	r2, [r4, r3]
     ef2:	e01e      	b.n	f32 <xQueueReceive+0xd6>
				prvUnlockQueue( pxQueue );
     ef4:	0020      	movs	r0, r4
     ef6:	4b29      	ldr	r3, [pc, #164]	; (f9c <xQueueReceive+0x140>)
     ef8:	4798      	blx	r3
				( void ) xTaskResumeAll();
     efa:	4b29      	ldr	r3, [pc, #164]	; (fa0 <xQueueReceive+0x144>)
     efc:	4798      	blx	r3
		taskENTER_CRITICAL();
     efe:	4b29      	ldr	r3, [pc, #164]	; (fa4 <xQueueReceive+0x148>)
     f00:	4798      	blx	r3
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     f02:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     f04:	2d00      	cmp	r5, #0
     f06:	d1ce      	bne.n	ea6 <xQueueReceive+0x4a>
				if( xTicksToWait == ( TickType_t ) 0 )
     f08:	9b01      	ldr	r3, [sp, #4]
     f0a:	2b00      	cmp	r3, #0
     f0c:	d0e1      	beq.n	ed2 <xQueueReceive+0x76>
				else if( xEntryTimeSet == pdFALSE )
     f0e:	2f00      	cmp	r7, #0
     f10:	d0e3      	beq.n	eda <xQueueReceive+0x7e>
		taskEXIT_CRITICAL();
     f12:	4b20      	ldr	r3, [pc, #128]	; (f94 <xQueueReceive+0x138>)
     f14:	4798      	blx	r3
		vTaskSuspendAll();
     f16:	4b24      	ldr	r3, [pc, #144]	; (fa8 <xQueueReceive+0x14c>)
     f18:	4798      	blx	r3
		prvLockQueue( pxQueue );
     f1a:	4b22      	ldr	r3, [pc, #136]	; (fa4 <xQueueReceive+0x148>)
     f1c:	4798      	blx	r3
     f1e:	2344      	movs	r3, #68	; 0x44
     f20:	5ce3      	ldrb	r3, [r4, r3]
     f22:	b25b      	sxtb	r3, r3
     f24:	3301      	adds	r3, #1
     f26:	d0dd      	beq.n	ee4 <xQueueReceive+0x88>
     f28:	2345      	movs	r3, #69	; 0x45
     f2a:	5ce3      	ldrb	r3, [r4, r3]
     f2c:	b25b      	sxtb	r3, r3
     f2e:	3301      	adds	r3, #1
     f30:	d0dc      	beq.n	eec <xQueueReceive+0x90>
     f32:	4b18      	ldr	r3, [pc, #96]	; (f94 <xQueueReceive+0x138>)
     f34:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f36:	a901      	add	r1, sp, #4
     f38:	a802      	add	r0, sp, #8
     f3a:	4b1c      	ldr	r3, [pc, #112]	; (fac <xQueueReceive+0x150>)
     f3c:	4798      	blx	r3
     f3e:	2800      	cmp	r0, #0
     f40:	d113      	bne.n	f6a <xQueueReceive+0x10e>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f42:	0020      	movs	r0, r4
     f44:	4b1a      	ldr	r3, [pc, #104]	; (fb0 <xQueueReceive+0x154>)
     f46:	4798      	blx	r3
     f48:	2800      	cmp	r0, #0
     f4a:	d0d3      	beq.n	ef4 <xQueueReceive+0x98>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f4c:	0020      	movs	r0, r4
     f4e:	3024      	adds	r0, #36	; 0x24
     f50:	9901      	ldr	r1, [sp, #4]
     f52:	4b18      	ldr	r3, [pc, #96]	; (fb4 <xQueueReceive+0x158>)
     f54:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     f56:	0020      	movs	r0, r4
     f58:	4b10      	ldr	r3, [pc, #64]	; (f9c <xQueueReceive+0x140>)
     f5a:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     f5c:	4b10      	ldr	r3, [pc, #64]	; (fa0 <xQueueReceive+0x144>)
     f5e:	4798      	blx	r3
     f60:	2800      	cmp	r0, #0
     f62:	d1cc      	bne.n	efe <xQueueReceive+0xa2>
					portYIELD_WITHIN_API();
     f64:	4b0a      	ldr	r3, [pc, #40]	; (f90 <xQueueReceive+0x134>)
     f66:	4798      	blx	r3
     f68:	e7c9      	b.n	efe <xQueueReceive+0xa2>
			prvUnlockQueue( pxQueue );
     f6a:	0020      	movs	r0, r4
     f6c:	4b0b      	ldr	r3, [pc, #44]	; (f9c <xQueueReceive+0x140>)
     f6e:	4798      	blx	r3
			( void ) xTaskResumeAll();
     f70:	4b0b      	ldr	r3, [pc, #44]	; (fa0 <xQueueReceive+0x144>)
     f72:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f74:	0020      	movs	r0, r4
     f76:	4b0e      	ldr	r3, [pc, #56]	; (fb0 <xQueueReceive+0x154>)
     f78:	4798      	blx	r3
     f7a:	2800      	cmp	r0, #0
     f7c:	d0bf      	beq.n	efe <xQueueReceive+0xa2>
				return errQUEUE_EMPTY;
     f7e:	2000      	movs	r0, #0
     f80:	e7a5      	b.n	ece <xQueueReceive+0x72>
     f82:	46c0      	nop			; (mov r8, r8)
     f84:	00001831 	.word	0x00001831
     f88:	00000a25 	.word	0x00000a25
     f8c:	00001721 	.word	0x00001721
     f90:	00000809 	.word	0x00000809
     f94:	00000839 	.word	0x00000839
     f98:	000017a5 	.word	0x000017a5
     f9c:	00000a4d 	.word	0x00000a4d
     fa0:	00001501 	.word	0x00001501
     fa4:	00000821 	.word	0x00000821
     fa8:	000013d9 	.word	0x000013d9
     fac:	000017b5 	.word	0x000017b5
     fb0:	0000090d 	.word	0x0000090d
     fb4:	000016bd 	.word	0x000016bd

00000fb8 <vQueueAddToRegistry>:
	{
     fb8:	b510      	push	{r4, lr}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
     fba:	2300      	movs	r3, #0
     fbc:	2b07      	cmp	r3, #7
     fbe:	d80a      	bhi.n	fd6 <vQueueAddToRegistry+0x1e>
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
     fc0:	00da      	lsls	r2, r3, #3
     fc2:	4c05      	ldr	r4, [pc, #20]	; (fd8 <vQueueAddToRegistry+0x20>)
     fc4:	5912      	ldr	r2, [r2, r4]
     fc6:	2a00      	cmp	r2, #0
     fc8:	d001      	beq.n	fce <vQueueAddToRegistry+0x16>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
     fca:	3301      	adds	r3, #1
     fcc:	e7f6      	b.n	fbc <vQueueAddToRegistry+0x4>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
     fce:	00db      	lsls	r3, r3, #3
     fd0:	5119      	str	r1, [r3, r4]
				xQueueRegistry[ ux ].xHandle = xQueue;
     fd2:	18e3      	adds	r3, r4, r3
     fd4:	6058      	str	r0, [r3, #4]
	}
     fd6:	bd10      	pop	{r4, pc}
     fd8:	20004448 	.word	0x20004448

00000fdc <vQueueWaitForMessageRestricted>:
	{
     fdc:	b570      	push	{r4, r5, r6, lr}
     fde:	0004      	movs	r4, r0
     fe0:	000d      	movs	r5, r1
     fe2:	0016      	movs	r6, r2
		prvLockQueue( pxQueue );
     fe4:	4b11      	ldr	r3, [pc, #68]	; (102c <vQueueWaitForMessageRestricted+0x50>)
     fe6:	4798      	blx	r3
     fe8:	2344      	movs	r3, #68	; 0x44
     fea:	5ce3      	ldrb	r3, [r4, r3]
     fec:	b25b      	sxtb	r3, r3
     fee:	3301      	adds	r3, #1
     ff0:	d00d      	beq.n	100e <vQueueWaitForMessageRestricted+0x32>
     ff2:	2345      	movs	r3, #69	; 0x45
     ff4:	5ce3      	ldrb	r3, [r4, r3]
     ff6:	b25b      	sxtb	r3, r3
     ff8:	3301      	adds	r3, #1
     ffa:	d00c      	beq.n	1016 <vQueueWaitForMessageRestricted+0x3a>
     ffc:	4b0c      	ldr	r3, [pc, #48]	; (1030 <vQueueWaitForMessageRestricted+0x54>)
     ffe:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1000:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1002:	2b00      	cmp	r3, #0
    1004:	d00b      	beq.n	101e <vQueueWaitForMessageRestricted+0x42>
		prvUnlockQueue( pxQueue );
    1006:	0020      	movs	r0, r4
    1008:	4b0a      	ldr	r3, [pc, #40]	; (1034 <vQueueWaitForMessageRestricted+0x58>)
    100a:	4798      	blx	r3
	}
    100c:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
    100e:	2200      	movs	r2, #0
    1010:	2344      	movs	r3, #68	; 0x44
    1012:	54e2      	strb	r2, [r4, r3]
    1014:	e7ed      	b.n	ff2 <vQueueWaitForMessageRestricted+0x16>
    1016:	2200      	movs	r2, #0
    1018:	2345      	movs	r3, #69	; 0x45
    101a:	54e2      	strb	r2, [r4, r3]
    101c:	e7ee      	b.n	ffc <vQueueWaitForMessageRestricted+0x20>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    101e:	0020      	movs	r0, r4
    1020:	3024      	adds	r0, #36	; 0x24
    1022:	0032      	movs	r2, r6
    1024:	0029      	movs	r1, r5
    1026:	4b04      	ldr	r3, [pc, #16]	; (1038 <vQueueWaitForMessageRestricted+0x5c>)
    1028:	4798      	blx	r3
    102a:	e7ec      	b.n	1006 <vQueueWaitForMessageRestricted+0x2a>
    102c:	00000821 	.word	0x00000821
    1030:	00000839 	.word	0x00000839
    1034:	00000a4d 	.word	0x00000a4d
    1038:	000016e9 	.word	0x000016e9

0000103c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    103c:	4b0a      	ldr	r3, [pc, #40]	; (1068 <prvResetNextTaskUnblockTime+0x2c>)
    103e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1040:	681b      	ldr	r3, [r3, #0]
    1042:	2b00      	cmp	r3, #0
    1044:	d109      	bne.n	105a <prvResetNextTaskUnblockTime+0x1e>
    1046:	3301      	adds	r3, #1
    1048:	2b00      	cmp	r3, #0
    104a:	d108      	bne.n	105e <prvResetNextTaskUnblockTime+0x22>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    104c:	4b06      	ldr	r3, [pc, #24]	; (1068 <prvResetNextTaskUnblockTime+0x2c>)
    104e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1050:	68d2      	ldr	r2, [r2, #12]
    1052:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1054:	6852      	ldr	r2, [r2, #4]
    1056:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    1058:	4770      	bx	lr
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    105a:	2300      	movs	r3, #0
    105c:	e7f4      	b.n	1048 <prvResetNextTaskUnblockTime+0xc>
		xNextTaskUnblockTime = portMAX_DELAY;
    105e:	2201      	movs	r2, #1
    1060:	4252      	negs	r2, r2
    1062:	4b01      	ldr	r3, [pc, #4]	; (1068 <prvResetNextTaskUnblockTime+0x2c>)
    1064:	62da      	str	r2, [r3, #44]	; 0x2c
    1066:	e7f7      	b.n	1058 <prvResetNextTaskUnblockTime+0x1c>
    1068:	20004308 	.word	0x20004308

0000106c <prvDeleteTCB>:
	{
    106c:	b570      	push	{r4, r5, r6, lr}
    106e:	0005      	movs	r5, r0
			vPortFree( pxTCB->pxStack );
    1070:	6b00      	ldr	r0, [r0, #48]	; 0x30
    1072:	4c02      	ldr	r4, [pc, #8]	; (107c <prvDeleteTCB+0x10>)
    1074:	47a0      	blx	r4
			vPortFree( pxTCB );
    1076:	0028      	movs	r0, r5
    1078:	47a0      	blx	r4
	}
    107a:	bd70      	pop	{r4, r5, r6, pc}
    107c:	000002c9 	.word	0x000002c9

00001080 <prvInitialiseNewTask>:
{
    1080:	b5f0      	push	{r4, r5, r6, r7, lr}
    1082:	46c6      	mov	lr, r8
    1084:	b500      	push	{lr}
    1086:	b082      	sub	sp, #8
    1088:	9000      	str	r0, [sp, #0]
    108a:	000f      	movs	r7, r1
    108c:	0015      	movs	r5, r2
    108e:	9301      	str	r3, [sp, #4]
    1090:	9c08      	ldr	r4, [sp, #32]
    1092:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    1094:	0092      	lsls	r2, r2, #2
    1096:	21a5      	movs	r1, #165	; 0xa5
    1098:	6b30      	ldr	r0, [r6, #48]	; 0x30
    109a:	4b1f      	ldr	r3, [pc, #124]	; (1118 <prvInitialiseNewTask+0x98>)
    109c:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    109e:	4b1f      	ldr	r3, [pc, #124]	; (111c <prvInitialiseNewTask+0x9c>)
    10a0:	18eb      	adds	r3, r5, r3
    10a2:	009b      	lsls	r3, r3, #2
    10a4:	6b32      	ldr	r2, [r6, #48]	; 0x30
    10a6:	4694      	mov	ip, r2
    10a8:	4463      	add	r3, ip
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    10aa:	2207      	movs	r2, #7
    10ac:	4393      	bics	r3, r2
    10ae:	4698      	mov	r8, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    10b0:	2300      	movs	r3, #0
    10b2:	2b04      	cmp	r3, #4
    10b4:	d809      	bhi.n	10ca <prvInitialiseNewTask+0x4a>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    10b6:	18f9      	adds	r1, r7, r3
    10b8:	7808      	ldrb	r0, [r1, #0]
    10ba:	18f2      	adds	r2, r6, r3
    10bc:	3234      	adds	r2, #52	; 0x34
    10be:	7010      	strb	r0, [r2, #0]
		if( pcName[ x ] == 0x00 )
    10c0:	780a      	ldrb	r2, [r1, #0]
    10c2:	2a00      	cmp	r2, #0
    10c4:	d001      	beq.n	10ca <prvInitialiseNewTask+0x4a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    10c6:	3301      	adds	r3, #1
    10c8:	e7f3      	b.n	10b2 <prvInitialiseNewTask+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    10ca:	2200      	movs	r2, #0
    10cc:	2338      	movs	r3, #56	; 0x38
    10ce:	54f2      	strb	r2, [r6, r3]
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    10d0:	2c04      	cmp	r4, #4
    10d2:	d900      	bls.n	10d6 <prvInitialiseNewTask+0x56>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    10d4:	2404      	movs	r4, #4
	pxNewTCB->uxPriority = uxPriority;
    10d6:	62f4      	str	r4, [r6, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    10d8:	6474      	str	r4, [r6, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    10da:	2500      	movs	r5, #0
    10dc:	64b5      	str	r5, [r6, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    10de:	1d30      	adds	r0, r6, #4
    10e0:	4f0f      	ldr	r7, [pc, #60]	; (1120 <prvInitialiseNewTask+0xa0>)
    10e2:	47b8      	blx	r7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    10e4:	0030      	movs	r0, r6
    10e6:	3018      	adds	r0, #24
    10e8:	47b8      	blx	r7
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    10ea:	6136      	str	r6, [r6, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10ec:	2305      	movs	r3, #5
    10ee:	1b1c      	subs	r4, r3, r4
    10f0:	61b4      	str	r4, [r6, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    10f2:	6276      	str	r6, [r6, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    10f4:	64f5      	str	r5, [r6, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    10f6:	334b      	adds	r3, #75	; 0x4b
    10f8:	54f5      	strb	r5, [r6, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    10fa:	9a01      	ldr	r2, [sp, #4]
    10fc:	9900      	ldr	r1, [sp, #0]
    10fe:	4640      	mov	r0, r8
    1100:	4b08      	ldr	r3, [pc, #32]	; (1124 <prvInitialiseNewTask+0xa4>)
    1102:	4798      	blx	r3
    1104:	6030      	str	r0, [r6, #0]
	if( ( void * ) pxCreatedTask != NULL )
    1106:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1108:	2b00      	cmp	r3, #0
    110a:	d000      	beq.n	110e <prvInitialiseNewTask+0x8e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    110c:	601e      	str	r6, [r3, #0]
}
    110e:	b002      	add	sp, #8
    1110:	bc04      	pop	{r2}
    1112:	4690      	mov	r8, r2
    1114:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1116:	46c0      	nop			; (mov r8, r8)
    1118:	00001e25 	.word	0x00001e25
    111c:	3fffffff 	.word	0x3fffffff
    1120:	00000327 	.word	0x00000327
    1124:	0000079d 	.word	0x0000079d

00001128 <prvInitialiseTaskLists>:
{
    1128:	b5f0      	push	{r4, r5, r6, r7, lr}
    112a:	46c6      	mov	lr, r8
    112c:	b500      	push	{lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    112e:	2400      	movs	r4, #0
    1130:	e008      	b.n	1144 <prvInitialiseTaskLists+0x1c>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1132:	00a3      	lsls	r3, r4, #2
    1134:	191b      	adds	r3, r3, r4
    1136:	009a      	lsls	r2, r3, #2
    1138:	4810      	ldr	r0, [pc, #64]	; (117c <prvInitialiseTaskLists+0x54>)
    113a:	3030      	adds	r0, #48	; 0x30
    113c:	1880      	adds	r0, r0, r2
    113e:	4b10      	ldr	r3, [pc, #64]	; (1180 <prvInitialiseTaskLists+0x58>)
    1140:	4798      	blx	r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1142:	3401      	adds	r4, #1
    1144:	2c04      	cmp	r4, #4
    1146:	d9f4      	bls.n	1132 <prvInitialiseTaskLists+0xa>
	vListInitialise( &xDelayedTaskList1 );
    1148:	4d0e      	ldr	r5, [pc, #56]	; (1184 <prvInitialiseTaskLists+0x5c>)
    114a:	2314      	movs	r3, #20
    114c:	4698      	mov	r8, r3
    114e:	44a8      	add	r8, r5
    1150:	4640      	mov	r0, r8
    1152:	4c0b      	ldr	r4, [pc, #44]	; (1180 <prvInitialiseTaskLists+0x58>)
    1154:	47a0      	blx	r4
	vListInitialise( &xDelayedTaskList2 );
    1156:	002f      	movs	r7, r5
    1158:	3728      	adds	r7, #40	; 0x28
    115a:	0038      	movs	r0, r7
    115c:	47a0      	blx	r4
	vListInitialise( &xPendingReadyList );
    115e:	4e07      	ldr	r6, [pc, #28]	; (117c <prvInitialiseTaskLists+0x54>)
    1160:	0030      	movs	r0, r6
    1162:	3014      	adds	r0, #20
    1164:	47a0      	blx	r4
		vListInitialise( &xTasksWaitingTermination );
    1166:	0028      	movs	r0, r5
    1168:	303c      	adds	r0, #60	; 0x3c
    116a:	47a0      	blx	r4
		vListInitialise( &xSuspendedTaskList );
    116c:	0030      	movs	r0, r6
    116e:	47a0      	blx	r4
	pxDelayedTaskList = &xDelayedTaskList1;
    1170:	4643      	mov	r3, r8
    1172:	62b3      	str	r3, [r6, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1174:	652f      	str	r7, [r5, #80]	; 0x50
}
    1176:	bc04      	pop	{r2}
    1178:	4690      	mov	r8, r2
    117a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    117c:	20004308 	.word	0x20004308
    1180:	00000311 	.word	0x00000311
    1184:	20004388 	.word	0x20004388

00001188 <prvAddNewTaskToReadyList>:
{
    1188:	b510      	push	{r4, lr}
    118a:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
    118c:	4b1f      	ldr	r3, [pc, #124]	; (120c <prvAddNewTaskToReadyList+0x84>)
    118e:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    1190:	4b1f      	ldr	r3, [pc, #124]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    1192:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    1194:	3201      	adds	r2, #1
    1196:	655a      	str	r2, [r3, #84]	; 0x54
		if( pxCurrentTCB == NULL )
    1198:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    119a:	2b00      	cmp	r3, #0
    119c:	d02b      	beq.n	11f6 <prvAddNewTaskToReadyList+0x6e>
			if( xSchedulerRunning == pdFALSE )
    119e:	4b1c      	ldr	r3, [pc, #112]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    11a0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    11a2:	2b00      	cmp	r3, #0
    11a4:	d107      	bne.n	11b6 <prvAddNewTaskToReadyList+0x2e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    11a6:	4b1a      	ldr	r3, [pc, #104]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    11a8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    11aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    11ac:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    11ae:	4293      	cmp	r3, r2
    11b0:	d801      	bhi.n	11b6 <prvAddNewTaskToReadyList+0x2e>
					pxCurrentTCB = pxNewTCB;
    11b2:	4b17      	ldr	r3, [pc, #92]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    11b4:	659c      	str	r4, [r3, #88]	; 0x58
		uxTaskNumber++;
    11b6:	4916      	ldr	r1, [pc, #88]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    11b8:	6e0b      	ldr	r3, [r1, #96]	; 0x60
    11ba:	3301      	adds	r3, #1
    11bc:	660b      	str	r3, [r1, #96]	; 0x60
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    11be:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList( pxNewTCB );
    11c0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    11c2:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    11c4:	429a      	cmp	r2, r3
    11c6:	d900      	bls.n	11ca <prvAddNewTaskToReadyList+0x42>
    11c8:	664a      	str	r2, [r1, #100]	; 0x64
    11ca:	1d21      	adds	r1, r4, #4
    11cc:	0093      	lsls	r3, r2, #2
    11ce:	189b      	adds	r3, r3, r2
    11d0:	009a      	lsls	r2, r3, #2
    11d2:	4810      	ldr	r0, [pc, #64]	; (1214 <prvAddNewTaskToReadyList+0x8c>)
    11d4:	3030      	adds	r0, #48	; 0x30
    11d6:	1880      	adds	r0, r0, r2
    11d8:	4b0f      	ldr	r3, [pc, #60]	; (1218 <prvAddNewTaskToReadyList+0x90>)
    11da:	4798      	blx	r3
	taskEXIT_CRITICAL();
    11dc:	4b0f      	ldr	r3, [pc, #60]	; (121c <prvAddNewTaskToReadyList+0x94>)
    11de:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    11e0:	4b0b      	ldr	r3, [pc, #44]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    11e2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    11e4:	2b00      	cmp	r3, #0
    11e6:	d005      	beq.n	11f4 <prvAddNewTaskToReadyList+0x6c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    11e8:	4b09      	ldr	r3, [pc, #36]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    11ea:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    11ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    11ee:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    11f0:	429a      	cmp	r2, r3
    11f2:	d308      	bcc.n	1206 <prvAddNewTaskToReadyList+0x7e>
}
    11f4:	bd10      	pop	{r4, pc}
			pxCurrentTCB = pxNewTCB;
    11f6:	4b06      	ldr	r3, [pc, #24]	; (1210 <prvAddNewTaskToReadyList+0x88>)
    11f8:	659c      	str	r4, [r3, #88]	; 0x58
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    11fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    11fc:	2b01      	cmp	r3, #1
    11fe:	d1da      	bne.n	11b6 <prvAddNewTaskToReadyList+0x2e>
				prvInitialiseTaskLists();
    1200:	4b07      	ldr	r3, [pc, #28]	; (1220 <prvAddNewTaskToReadyList+0x98>)
    1202:	4798      	blx	r3
    1204:	e7d7      	b.n	11b6 <prvAddNewTaskToReadyList+0x2e>
			taskYIELD_IF_USING_PREEMPTION();
    1206:	4b07      	ldr	r3, [pc, #28]	; (1224 <prvAddNewTaskToReadyList+0x9c>)
    1208:	4798      	blx	r3
}
    120a:	e7f3      	b.n	11f4 <prvAddNewTaskToReadyList+0x6c>
    120c:	00000821 	.word	0x00000821
    1210:	20004388 	.word	0x20004388
    1214:	20004308 	.word	0x20004308
    1218:	0000032d 	.word	0x0000032d
    121c:	00000839 	.word	0x00000839
    1220:	00001129 	.word	0x00001129
    1224:	00000809 	.word	0x00000809

00001228 <prvCheckTasksWaitingTermination>:
{
    1228:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    122a:	e012      	b.n	1252 <prvCheckTasksWaitingTermination+0x2a>
			taskENTER_CRITICAL();
    122c:	4b0b      	ldr	r3, [pc, #44]	; (125c <prvCheckTasksWaitingTermination+0x34>)
    122e:	4798      	blx	r3
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1230:	4c0b      	ldr	r4, [pc, #44]	; (1260 <prvCheckTasksWaitingTermination+0x38>)
    1232:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1234:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1236:	1d28      	adds	r0, r5, #4
    1238:	4b0a      	ldr	r3, [pc, #40]	; (1264 <prvCheckTasksWaitingTermination+0x3c>)
    123a:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    123c:	6d63      	ldr	r3, [r4, #84]	; 0x54
    123e:	3b01      	subs	r3, #1
    1240:	6563      	str	r3, [r4, #84]	; 0x54
				--uxDeletedTasksWaitingCleanUp;
    1242:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    1244:	3b01      	subs	r3, #1
    1246:	66a3      	str	r3, [r4, #104]	; 0x68
			taskEXIT_CRITICAL();
    1248:	4b07      	ldr	r3, [pc, #28]	; (1268 <prvCheckTasksWaitingTermination+0x40>)
    124a:	4798      	blx	r3
			prvDeleteTCB( pxTCB );
    124c:	0028      	movs	r0, r5
    124e:	4b07      	ldr	r3, [pc, #28]	; (126c <prvCheckTasksWaitingTermination+0x44>)
    1250:	4798      	blx	r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1252:	4b03      	ldr	r3, [pc, #12]	; (1260 <prvCheckTasksWaitingTermination+0x38>)
    1254:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    1256:	2b00      	cmp	r3, #0
    1258:	d1e8      	bne.n	122c <prvCheckTasksWaitingTermination+0x4>
}
    125a:	bd70      	pop	{r4, r5, r6, pc}
    125c:	00000821 	.word	0x00000821
    1260:	20004388 	.word	0x20004388
    1264:	00000375 	.word	0x00000375
    1268:	00000839 	.word	0x00000839
    126c:	0000106d 	.word	0x0000106d

00001270 <prvIdleTask>:
{
    1270:	b510      	push	{r4, lr}
		prvCheckTasksWaitingTermination();
    1272:	4b04      	ldr	r3, [pc, #16]	; (1284 <prvIdleTask+0x14>)
    1274:	4798      	blx	r3
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1276:	4b04      	ldr	r3, [pc, #16]	; (1288 <prvIdleTask+0x18>)
    1278:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    127a:	2b01      	cmp	r3, #1
    127c:	d9f9      	bls.n	1272 <prvIdleTask+0x2>
				taskYIELD();
    127e:	4b03      	ldr	r3, [pc, #12]	; (128c <prvIdleTask+0x1c>)
    1280:	4798      	blx	r3
    1282:	e7f6      	b.n	1272 <prvIdleTask+0x2>
    1284:	00001229 	.word	0x00001229
    1288:	20004308 	.word	0x20004308
    128c:	00000809 	.word	0x00000809

00001290 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1290:	b570      	push	{r4, r5, r6, lr}
    1292:	0004      	movs	r4, r0
    1294:	000d      	movs	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1296:	4b15      	ldr	r3, [pc, #84]	; (12ec <prvAddCurrentTaskToDelayedList+0x5c>)
    1298:	6ede      	ldr	r6, [r3, #108]	; 0x6c
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    129a:	6d98      	ldr	r0, [r3, #88]	; 0x58
    129c:	3004      	adds	r0, #4
    129e:	4b14      	ldr	r3, [pc, #80]	; (12f0 <prvAddCurrentTaskToDelayedList+0x60>)
    12a0:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    12a2:	1c63      	adds	r3, r4, #1
    12a4:	d012      	beq.n	12cc <prvAddCurrentTaskToDelayedList+0x3c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    12a6:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    12a8:	4b10      	ldr	r3, [pc, #64]	; (12ec <prvAddCurrentTaskToDelayedList+0x5c>)
    12aa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    12ac:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
    12ae:	42a6      	cmp	r6, r4
    12b0:	d815      	bhi.n	12de <prvAddCurrentTaskToDelayedList+0x4e>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    12b2:	4d10      	ldr	r5, [pc, #64]	; (12f4 <prvAddCurrentTaskToDelayedList+0x64>)
    12b4:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    12b6:	4b0d      	ldr	r3, [pc, #52]	; (12ec <prvAddCurrentTaskToDelayedList+0x5c>)
    12b8:	6d99      	ldr	r1, [r3, #88]	; 0x58
    12ba:	3104      	adds	r1, #4
    12bc:	4b0e      	ldr	r3, [pc, #56]	; (12f8 <prvAddCurrentTaskToDelayedList+0x68>)
    12be:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    12c0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    12c2:	429c      	cmp	r4, r3
    12c4:	d211      	bcs.n	12ea <prvAddCurrentTaskToDelayedList+0x5a>
				{
					xNextTaskUnblockTime = xTimeToWake;
    12c6:	4b0b      	ldr	r3, [pc, #44]	; (12f4 <prvAddCurrentTaskToDelayedList+0x64>)
    12c8:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    12ca:	e00e      	b.n	12ea <prvAddCurrentTaskToDelayedList+0x5a>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    12cc:	2d00      	cmp	r5, #0
    12ce:	d0ea      	beq.n	12a6 <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    12d0:	4b06      	ldr	r3, [pc, #24]	; (12ec <prvAddCurrentTaskToDelayedList+0x5c>)
    12d2:	6d99      	ldr	r1, [r3, #88]	; 0x58
    12d4:	3104      	adds	r1, #4
    12d6:	4807      	ldr	r0, [pc, #28]	; (12f4 <prvAddCurrentTaskToDelayedList+0x64>)
    12d8:	4b08      	ldr	r3, [pc, #32]	; (12fc <prvAddCurrentTaskToDelayedList+0x6c>)
    12da:	4798      	blx	r3
    12dc:	e005      	b.n	12ea <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    12de:	4b03      	ldr	r3, [pc, #12]	; (12ec <prvAddCurrentTaskToDelayedList+0x5c>)
    12e0:	6d18      	ldr	r0, [r3, #80]	; 0x50
    12e2:	6d99      	ldr	r1, [r3, #88]	; 0x58
    12e4:	3104      	adds	r1, #4
    12e6:	4b04      	ldr	r3, [pc, #16]	; (12f8 <prvAddCurrentTaskToDelayedList+0x68>)
    12e8:	4798      	blx	r3
}
    12ea:	bd70      	pop	{r4, r5, r6, pc}
    12ec:	20004388 	.word	0x20004388
    12f0:	00000375 	.word	0x00000375
    12f4:	20004308 	.word	0x20004308
    12f8:	00000345 	.word	0x00000345
    12fc:	0000032d 	.word	0x0000032d

00001300 <xTaskCreate>:
	{
    1300:	b5f0      	push	{r4, r5, r6, r7, lr}
    1302:	b087      	sub	sp, #28
    1304:	9004      	str	r0, [sp, #16]
    1306:	9105      	str	r1, [sp, #20]
    1308:	0014      	movs	r4, r2
    130a:	001f      	movs	r7, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    130c:	0090      	lsls	r0, r2, #2
    130e:	4b14      	ldr	r3, [pc, #80]	; (1360 <xTaskCreate+0x60>)
    1310:	4798      	blx	r3
    1312:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
    1314:	d01e      	beq.n	1354 <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1316:	2054      	movs	r0, #84	; 0x54
    1318:	4b11      	ldr	r3, [pc, #68]	; (1360 <xTaskCreate+0x60>)
    131a:	4798      	blx	r3
    131c:	1e05      	subs	r5, r0, #0
				if( pxNewTCB != NULL )
    131e:	d015      	beq.n	134c <xTaskCreate+0x4c>
					pxNewTCB->pxStack = pxStack;
    1320:	6306      	str	r6, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
    1322:	2d00      	cmp	r5, #0
    1324:	d018      	beq.n	1358 <xTaskCreate+0x58>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    1326:	2300      	movs	r3, #0
    1328:	9303      	str	r3, [sp, #12]
    132a:	9502      	str	r5, [sp, #8]
    132c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    132e:	9301      	str	r3, [sp, #4]
    1330:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1332:	9300      	str	r3, [sp, #0]
    1334:	003b      	movs	r3, r7
    1336:	0022      	movs	r2, r4
    1338:	9905      	ldr	r1, [sp, #20]
    133a:	9804      	ldr	r0, [sp, #16]
    133c:	4c09      	ldr	r4, [pc, #36]	; (1364 <xTaskCreate+0x64>)
    133e:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
    1340:	0028      	movs	r0, r5
    1342:	4b09      	ldr	r3, [pc, #36]	; (1368 <xTaskCreate+0x68>)
    1344:	4798      	blx	r3
			xReturn = pdPASS;
    1346:	2001      	movs	r0, #1
	}
    1348:	b007      	add	sp, #28
    134a:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
    134c:	0030      	movs	r0, r6
    134e:	4b07      	ldr	r3, [pc, #28]	; (136c <xTaskCreate+0x6c>)
    1350:	4798      	blx	r3
    1352:	e7e6      	b.n	1322 <xTaskCreate+0x22>
				pxNewTCB = NULL;
    1354:	2500      	movs	r5, #0
    1356:	e7e4      	b.n	1322 <xTaskCreate+0x22>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1358:	2001      	movs	r0, #1
    135a:	4240      	negs	r0, r0
		return xReturn;
    135c:	e7f4      	b.n	1348 <xTaskCreate+0x48>
    135e:	46c0      	nop			; (mov r8, r8)
    1360:	00000219 	.word	0x00000219
    1364:	00001081 	.word	0x00001081
    1368:	00001189 	.word	0x00001189
    136c:	000002c9 	.word	0x000002c9

00001370 <vTaskStartScheduler>:
{
    1370:	b510      	push	{r4, lr}
    1372:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
    1374:	4b11      	ldr	r3, [pc, #68]	; (13bc <vTaskStartScheduler+0x4c>)
    1376:	3374      	adds	r3, #116	; 0x74
    1378:	9301      	str	r3, [sp, #4]
    137a:	2300      	movs	r3, #0
    137c:	9300      	str	r3, [sp, #0]
    137e:	2246      	movs	r2, #70	; 0x46
    1380:	490f      	ldr	r1, [pc, #60]	; (13c0 <vTaskStartScheduler+0x50>)
    1382:	4810      	ldr	r0, [pc, #64]	; (13c4 <vTaskStartScheduler+0x54>)
    1384:	4c10      	ldr	r4, [pc, #64]	; (13c8 <vTaskStartScheduler+0x58>)
    1386:	47a0      	blx	r4
		if( xReturn == pdPASS )
    1388:	2801      	cmp	r0, #1
    138a:	d005      	beq.n	1398 <vTaskStartScheduler+0x28>
	if( xReturn == pdPASS )
    138c:	2801      	cmp	r0, #1
    138e:	d006      	beq.n	139e <vTaskStartScheduler+0x2e>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1390:	1c43      	adds	r3, r0, #1
    1392:	d011      	beq.n	13b8 <vTaskStartScheduler+0x48>
}
    1394:	b002      	add	sp, #8
    1396:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    1398:	4b0c      	ldr	r3, [pc, #48]	; (13cc <vTaskStartScheduler+0x5c>)
    139a:	4798      	blx	r3
    139c:	e7f6      	b.n	138c <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    139e:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    13a0:	2201      	movs	r2, #1
    13a2:	4252      	negs	r2, r2
    13a4:	4b0a      	ldr	r3, [pc, #40]	; (13d0 <vTaskStartScheduler+0x60>)
    13a6:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
    13a8:	4b04      	ldr	r3, [pc, #16]	; (13bc <vTaskStartScheduler+0x4c>)
    13aa:	3202      	adds	r2, #2
    13ac:	65da      	str	r2, [r3, #92]	; 0x5c
		xTickCount = ( TickType_t ) 0U;
    13ae:	2200      	movs	r2, #0
    13b0:	66da      	str	r2, [r3, #108]	; 0x6c
		if( xPortStartScheduler() != pdFALSE )
    13b2:	4b08      	ldr	r3, [pc, #32]	; (13d4 <vTaskStartScheduler+0x64>)
    13b4:	4798      	blx	r3
    13b6:	e7ed      	b.n	1394 <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    13b8:	b672      	cpsid	i
    13ba:	e7fe      	b.n	13ba <vTaskStartScheduler+0x4a>
    13bc:	20004388 	.word	0x20004388
    13c0:	0000208c 	.word	0x0000208c
    13c4:	00001271 	.word	0x00001271
    13c8:	00001301 	.word	0x00001301
    13cc:	00001995 	.word	0x00001995
    13d0:	20004308 	.word	0x20004308
    13d4:	000007bd 	.word	0x000007bd

000013d8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    13d8:	4a02      	ldr	r2, [pc, #8]	; (13e4 <vTaskSuspendAll+0xc>)
    13da:	6f13      	ldr	r3, [r2, #112]	; 0x70
    13dc:	3301      	adds	r3, #1
    13de:	6713      	str	r3, [r2, #112]	; 0x70
}
    13e0:	4770      	bx	lr
    13e2:	46c0      	nop			; (mov r8, r8)
    13e4:	20004388 	.word	0x20004388

000013e8 <xTaskGetTickCount>:
		xTicks = xTickCount;
    13e8:	4b01      	ldr	r3, [pc, #4]	; (13f0 <xTaskGetTickCount+0x8>)
    13ea:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
}
    13ec:	4770      	bx	lr
    13ee:	46c0      	nop			; (mov r8, r8)
    13f0:	20004388 	.word	0x20004388

000013f4 <xTaskIncrementTick>:
{
    13f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    13f6:	4b3c      	ldr	r3, [pc, #240]	; (14e8 <xTaskIncrementTick+0xf4>)
    13f8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    13fa:	2b00      	cmp	r3, #0
    13fc:	d167      	bne.n	14ce <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    13fe:	4b3a      	ldr	r3, [pc, #232]	; (14e8 <xTaskIncrementTick+0xf4>)
    1400:	6edd      	ldr	r5, [r3, #108]	; 0x6c
    1402:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
    1404:	66dd      	str	r5, [r3, #108]	; 0x6c
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1406:	2d00      	cmp	r5, #0
    1408:	d111      	bne.n	142e <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
    140a:	4b38      	ldr	r3, [pc, #224]	; (14ec <xTaskIncrementTick+0xf8>)
    140c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    140e:	681b      	ldr	r3, [r3, #0]
    1410:	2b00      	cmp	r3, #0
    1412:	d001      	beq.n	1418 <xTaskIncrementTick+0x24>
    1414:	b672      	cpsid	i
    1416:	e7fe      	b.n	1416 <xTaskIncrementTick+0x22>
    1418:	4a34      	ldr	r2, [pc, #208]	; (14ec <xTaskIncrementTick+0xf8>)
    141a:	6a91      	ldr	r1, [r2, #40]	; 0x28
    141c:	4b32      	ldr	r3, [pc, #200]	; (14e8 <xTaskIncrementTick+0xf4>)
    141e:	6d18      	ldr	r0, [r3, #80]	; 0x50
    1420:	6290      	str	r0, [r2, #40]	; 0x28
    1422:	6519      	str	r1, [r3, #80]	; 0x50
    1424:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1426:	3201      	adds	r2, #1
    1428:	679a      	str	r2, [r3, #120]	; 0x78
    142a:	4b31      	ldr	r3, [pc, #196]	; (14f0 <xTaskIncrementTick+0xfc>)
    142c:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    142e:	4b2f      	ldr	r3, [pc, #188]	; (14ec <xTaskIncrementTick+0xf8>)
    1430:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1432:	429d      	cmp	r5, r3
    1434:	d23f      	bcs.n	14b6 <xTaskIncrementTick+0xc2>
BaseType_t xSwitchRequired = pdFALSE;
    1436:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1438:	4b2b      	ldr	r3, [pc, #172]	; (14e8 <xTaskIncrementTick+0xf4>)
    143a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    143c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    143e:	0093      	lsls	r3, r2, #2
    1440:	189b      	adds	r3, r3, r2
    1442:	009a      	lsls	r2, r3, #2
    1444:	4b29      	ldr	r3, [pc, #164]	; (14ec <xTaskIncrementTick+0xf8>)
    1446:	189b      	adds	r3, r3, r2
    1448:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    144a:	2b01      	cmp	r3, #1
    144c:	d944      	bls.n	14d8 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    144e:	2401      	movs	r4, #1
    1450:	e042      	b.n	14d8 <xTaskIncrementTick+0xe4>
							xSwitchRequired = pdTRUE;
    1452:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1454:	4b25      	ldr	r3, [pc, #148]	; (14ec <xTaskIncrementTick+0xf8>)
    1456:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1458:	681b      	ldr	r3, [r3, #0]
    145a:	2b00      	cmp	r3, #0
    145c:	d02d      	beq.n	14ba <xTaskIncrementTick+0xc6>
    145e:	2300      	movs	r3, #0
    1460:	2b00      	cmp	r3, #0
    1462:	d12c      	bne.n	14be <xTaskIncrementTick+0xca>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1464:	4b21      	ldr	r3, [pc, #132]	; (14ec <xTaskIncrementTick+0xf8>)
    1466:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1468:	68db      	ldr	r3, [r3, #12]
    146a:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    146c:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
    146e:	429d      	cmp	r5, r3
    1470:	d32a      	bcc.n	14c8 <xTaskIncrementTick+0xd4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1472:	1d37      	adds	r7, r6, #4
    1474:	0038      	movs	r0, r7
    1476:	4b1f      	ldr	r3, [pc, #124]	; (14f4 <xTaskIncrementTick+0x100>)
    1478:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    147a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    147c:	2b00      	cmp	r3, #0
    147e:	d003      	beq.n	1488 <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1480:	0030      	movs	r0, r6
    1482:	3018      	adds	r0, #24
    1484:	4b1b      	ldr	r3, [pc, #108]	; (14f4 <xTaskIncrementTick+0x100>)
    1486:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    1488:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    148a:	4b17      	ldr	r3, [pc, #92]	; (14e8 <xTaskIncrementTick+0xf4>)
    148c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    148e:	429a      	cmp	r2, r3
    1490:	d901      	bls.n	1496 <xTaskIncrementTick+0xa2>
    1492:	4b15      	ldr	r3, [pc, #84]	; (14e8 <xTaskIncrementTick+0xf4>)
    1494:	665a      	str	r2, [r3, #100]	; 0x64
    1496:	0093      	lsls	r3, r2, #2
    1498:	189b      	adds	r3, r3, r2
    149a:	009a      	lsls	r2, r3, #2
    149c:	4813      	ldr	r0, [pc, #76]	; (14ec <xTaskIncrementTick+0xf8>)
    149e:	3030      	adds	r0, #48	; 0x30
    14a0:	1880      	adds	r0, r0, r2
    14a2:	0039      	movs	r1, r7
    14a4:	4b14      	ldr	r3, [pc, #80]	; (14f8 <xTaskIncrementTick+0x104>)
    14a6:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    14a8:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    14aa:	4b0f      	ldr	r3, [pc, #60]	; (14e8 <xTaskIncrementTick+0xf4>)
    14ac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    14ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    14b0:	429a      	cmp	r2, r3
    14b2:	d2ce      	bcs.n	1452 <xTaskIncrementTick+0x5e>
    14b4:	e7ce      	b.n	1454 <xTaskIncrementTick+0x60>
    14b6:	2400      	movs	r4, #0
    14b8:	e7cc      	b.n	1454 <xTaskIncrementTick+0x60>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    14ba:	3301      	adds	r3, #1
    14bc:	e7d0      	b.n	1460 <xTaskIncrementTick+0x6c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14be:	2201      	movs	r2, #1
    14c0:	4252      	negs	r2, r2
    14c2:	4b0a      	ldr	r3, [pc, #40]	; (14ec <xTaskIncrementTick+0xf8>)
    14c4:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
    14c6:	e7b7      	b.n	1438 <xTaskIncrementTick+0x44>
						xNextTaskUnblockTime = xItemValue;
    14c8:	4a08      	ldr	r2, [pc, #32]	; (14ec <xTaskIncrementTick+0xf8>)
    14ca:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    14cc:	e7b4      	b.n	1438 <xTaskIncrementTick+0x44>
		++uxPendedTicks;
    14ce:	4a06      	ldr	r2, [pc, #24]	; (14e8 <xTaskIncrementTick+0xf4>)
    14d0:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    14d2:	3301      	adds	r3, #1
    14d4:	67d3      	str	r3, [r2, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    14d6:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    14d8:	4b08      	ldr	r3, [pc, #32]	; (14fc <xTaskIncrementTick+0x108>)
    14da:	681b      	ldr	r3, [r3, #0]
    14dc:	2b00      	cmp	r3, #0
    14de:	d000      	beq.n	14e2 <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    14e0:	2401      	movs	r4, #1
}
    14e2:	0020      	movs	r0, r4
    14e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    14e6:	46c0      	nop			; (mov r8, r8)
    14e8:	20004388 	.word	0x20004388
    14ec:	20004308 	.word	0x20004308
    14f0:	0000103d 	.word	0x0000103d
    14f4:	00000375 	.word	0x00000375
    14f8:	0000032d 	.word	0x0000032d
    14fc:	20004408 	.word	0x20004408

00001500 <xTaskResumeAll>:
{
    1500:	b570      	push	{r4, r5, r6, lr}
	configASSERT( uxSchedulerSuspended );
    1502:	4b32      	ldr	r3, [pc, #200]	; (15cc <xTaskResumeAll+0xcc>)
    1504:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1506:	2b00      	cmp	r3, #0
    1508:	d101      	bne.n	150e <xTaskResumeAll+0xe>
    150a:	b672      	cpsid	i
    150c:	e7fe      	b.n	150c <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
    150e:	4b30      	ldr	r3, [pc, #192]	; (15d0 <xTaskResumeAll+0xd0>)
    1510:	4798      	blx	r3
		--uxSchedulerSuspended;
    1512:	4b2e      	ldr	r3, [pc, #184]	; (15cc <xTaskResumeAll+0xcc>)
    1514:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    1516:	3a01      	subs	r2, #1
    1518:	671a      	str	r2, [r3, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    151a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    151c:	2b00      	cmp	r3, #0
    151e:	d150      	bne.n	15c2 <xTaskResumeAll+0xc2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1520:	4b2a      	ldr	r3, [pc, #168]	; (15cc <xTaskResumeAll+0xcc>)
    1522:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    1524:	2b00      	cmp	r3, #0
    1526:	d104      	bne.n	1532 <xTaskResumeAll+0x32>
BaseType_t xAlreadyYielded = pdFALSE;
    1528:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    152a:	4b2a      	ldr	r3, [pc, #168]	; (15d4 <xTaskResumeAll+0xd4>)
    152c:	4798      	blx	r3
}
    152e:	0020      	movs	r0, r4
    1530:	bd70      	pop	{r4, r5, r6, pc}
    1532:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1534:	4b28      	ldr	r3, [pc, #160]	; (15d8 <xTaskResumeAll+0xd8>)
    1536:	695b      	ldr	r3, [r3, #20]
    1538:	2b00      	cmp	r3, #0
    153a:	d023      	beq.n	1584 <xTaskResumeAll+0x84>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    153c:	4b26      	ldr	r3, [pc, #152]	; (15d8 <xTaskResumeAll+0xd8>)
    153e:	6a1b      	ldr	r3, [r3, #32]
    1540:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1542:	0020      	movs	r0, r4
    1544:	3018      	adds	r0, #24
    1546:	4e25      	ldr	r6, [pc, #148]	; (15dc <xTaskResumeAll+0xdc>)
    1548:	47b0      	blx	r6
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    154a:	1d25      	adds	r5, r4, #4
    154c:	0028      	movs	r0, r5
    154e:	47b0      	blx	r6
					prvAddTaskToReadyList( pxTCB );
    1550:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1552:	4b1e      	ldr	r3, [pc, #120]	; (15cc <xTaskResumeAll+0xcc>)
    1554:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    1556:	429a      	cmp	r2, r3
    1558:	d901      	bls.n	155e <xTaskResumeAll+0x5e>
    155a:	4b1c      	ldr	r3, [pc, #112]	; (15cc <xTaskResumeAll+0xcc>)
    155c:	665a      	str	r2, [r3, #100]	; 0x64
    155e:	0093      	lsls	r3, r2, #2
    1560:	189b      	adds	r3, r3, r2
    1562:	009a      	lsls	r2, r3, #2
    1564:	481c      	ldr	r0, [pc, #112]	; (15d8 <xTaskResumeAll+0xd8>)
    1566:	3030      	adds	r0, #48	; 0x30
    1568:	1880      	adds	r0, r0, r2
    156a:	0029      	movs	r1, r5
    156c:	4b1c      	ldr	r3, [pc, #112]	; (15e0 <xTaskResumeAll+0xe0>)
    156e:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1570:	4b16      	ldr	r3, [pc, #88]	; (15cc <xTaskResumeAll+0xcc>)
    1572:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1574:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1576:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1578:	429a      	cmp	r2, r3
    157a:	d3db      	bcc.n	1534 <xTaskResumeAll+0x34>
						xYieldPending = pdTRUE;
    157c:	2201      	movs	r2, #1
    157e:	4b19      	ldr	r3, [pc, #100]	; (15e4 <xTaskResumeAll+0xe4>)
    1580:	601a      	str	r2, [r3, #0]
    1582:	e7d7      	b.n	1534 <xTaskResumeAll+0x34>
				if( pxTCB != NULL )
    1584:	2c00      	cmp	r4, #0
    1586:	d001      	beq.n	158c <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
    1588:	4b17      	ldr	r3, [pc, #92]	; (15e8 <xTaskResumeAll+0xe8>)
    158a:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    158c:	4b0f      	ldr	r3, [pc, #60]	; (15cc <xTaskResumeAll+0xcc>)
    158e:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1590:	2c00      	cmp	r4, #0
    1592:	d10a      	bne.n	15aa <xTaskResumeAll+0xaa>
				if( xYieldPending != pdFALSE )
    1594:	4b13      	ldr	r3, [pc, #76]	; (15e4 <xTaskResumeAll+0xe4>)
    1596:	681b      	ldr	r3, [r3, #0]
    1598:	2b00      	cmp	r3, #0
    159a:	d014      	beq.n	15c6 <xTaskResumeAll+0xc6>
					taskYIELD_IF_USING_PREEMPTION();
    159c:	4b13      	ldr	r3, [pc, #76]	; (15ec <xTaskResumeAll+0xec>)
    159e:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    15a0:	2401      	movs	r4, #1
    15a2:	e7c2      	b.n	152a <xTaskResumeAll+0x2a>
							--uxPendedCounts;
    15a4:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    15a6:	2c00      	cmp	r4, #0
    15a8:	d007      	beq.n	15ba <xTaskResumeAll+0xba>
							if( xTaskIncrementTick() != pdFALSE )
    15aa:	4b11      	ldr	r3, [pc, #68]	; (15f0 <xTaskResumeAll+0xf0>)
    15ac:	4798      	blx	r3
    15ae:	2800      	cmp	r0, #0
    15b0:	d0f8      	beq.n	15a4 <xTaskResumeAll+0xa4>
								xYieldPending = pdTRUE;
    15b2:	2201      	movs	r2, #1
    15b4:	4b0b      	ldr	r3, [pc, #44]	; (15e4 <xTaskResumeAll+0xe4>)
    15b6:	601a      	str	r2, [r3, #0]
    15b8:	e7f4      	b.n	15a4 <xTaskResumeAll+0xa4>
						uxPendedTicks = 0;
    15ba:	2200      	movs	r2, #0
    15bc:	4b03      	ldr	r3, [pc, #12]	; (15cc <xTaskResumeAll+0xcc>)
    15be:	67da      	str	r2, [r3, #124]	; 0x7c
    15c0:	e7e8      	b.n	1594 <xTaskResumeAll+0x94>
BaseType_t xAlreadyYielded = pdFALSE;
    15c2:	2400      	movs	r4, #0
    15c4:	e7b1      	b.n	152a <xTaskResumeAll+0x2a>
    15c6:	2400      	movs	r4, #0
    15c8:	e7af      	b.n	152a <xTaskResumeAll+0x2a>
    15ca:	46c0      	nop			; (mov r8, r8)
    15cc:	20004388 	.word	0x20004388
    15d0:	00000821 	.word	0x00000821
    15d4:	00000839 	.word	0x00000839
    15d8:	20004308 	.word	0x20004308
    15dc:	00000375 	.word	0x00000375
    15e0:	0000032d 	.word	0x0000032d
    15e4:	20004408 	.word	0x20004408
    15e8:	0000103d 	.word	0x0000103d
    15ec:	00000809 	.word	0x00000809
    15f0:	000013f5 	.word	0x000013f5

000015f4 <vTaskDelay>:
	{
    15f4:	b510      	push	{r4, lr}
    15f6:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
    15f8:	d00e      	beq.n	1618 <vTaskDelay+0x24>
			configASSERT( uxSchedulerSuspended == 0 );
    15fa:	4b0a      	ldr	r3, [pc, #40]	; (1624 <vTaskDelay+0x30>)
    15fc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    15fe:	2b00      	cmp	r3, #0
    1600:	d001      	beq.n	1606 <vTaskDelay+0x12>
    1602:	b672      	cpsid	i
    1604:	e7fe      	b.n	1604 <vTaskDelay+0x10>
			vTaskSuspendAll();
    1606:	4b08      	ldr	r3, [pc, #32]	; (1628 <vTaskDelay+0x34>)
    1608:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    160a:	2100      	movs	r1, #0
    160c:	0020      	movs	r0, r4
    160e:	4b07      	ldr	r3, [pc, #28]	; (162c <vTaskDelay+0x38>)
    1610:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
    1612:	4b07      	ldr	r3, [pc, #28]	; (1630 <vTaskDelay+0x3c>)
    1614:	4798      	blx	r3
    1616:	e000      	b.n	161a <vTaskDelay+0x26>
	BaseType_t xAlreadyYielded = pdFALSE;
    1618:	2000      	movs	r0, #0
		if( xAlreadyYielded == pdFALSE )
    161a:	2800      	cmp	r0, #0
    161c:	d101      	bne.n	1622 <vTaskDelay+0x2e>
			portYIELD_WITHIN_API();
    161e:	4b05      	ldr	r3, [pc, #20]	; (1634 <vTaskDelay+0x40>)
    1620:	4798      	blx	r3
	}
    1622:	bd10      	pop	{r4, pc}
    1624:	20004388 	.word	0x20004388
    1628:	000013d9 	.word	0x000013d9
    162c:	00001291 	.word	0x00001291
    1630:	00001501 	.word	0x00001501
    1634:	00000809 	.word	0x00000809

00001638 <vTaskSwitchContext>:
{
    1638:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    163a:	4b1d      	ldr	r3, [pc, #116]	; (16b0 <vTaskSwitchContext+0x78>)
    163c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    163e:	2b00      	cmp	r3, #0
    1640:	d110      	bne.n	1664 <vTaskSwitchContext+0x2c>
		xYieldPending = pdFALSE;
    1642:	2200      	movs	r2, #0
    1644:	4b1b      	ldr	r3, [pc, #108]	; (16b4 <vTaskSwitchContext+0x7c>)
    1646:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1648:	4b19      	ldr	r3, [pc, #100]	; (16b0 <vTaskSwitchContext+0x78>)
    164a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    164c:	009a      	lsls	r2, r3, #2
    164e:	18d2      	adds	r2, r2, r3
    1650:	0091      	lsls	r1, r2, #2
    1652:	4a19      	ldr	r2, [pc, #100]	; (16b8 <vTaskSwitchContext+0x80>)
    1654:	1852      	adds	r2, r2, r1
    1656:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1658:	2a00      	cmp	r2, #0
    165a:	d109      	bne.n	1670 <vTaskSwitchContext+0x38>
    165c:	2b00      	cmp	r3, #0
    165e:	d005      	beq.n	166c <vTaskSwitchContext+0x34>
    1660:	3b01      	subs	r3, #1
    1662:	e7f3      	b.n	164c <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
    1664:	2201      	movs	r2, #1
    1666:	4b13      	ldr	r3, [pc, #76]	; (16b4 <vTaskSwitchContext+0x7c>)
    1668:	601a      	str	r2, [r3, #0]
}
    166a:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    166c:	b672      	cpsid	i
    166e:	e7fe      	b.n	166e <vTaskSwitchContext+0x36>
    1670:	4a11      	ldr	r2, [pc, #68]	; (16b8 <vTaskSwitchContext+0x80>)
    1672:	0099      	lsls	r1, r3, #2
    1674:	18cc      	adds	r4, r1, r3
    1676:	00a0      	lsls	r0, r4, #2
    1678:	1810      	adds	r0, r2, r0
    167a:	6b44      	ldr	r4, [r0, #52]	; 0x34
    167c:	6864      	ldr	r4, [r4, #4]
    167e:	6344      	str	r4, [r0, #52]	; 0x34
    1680:	3230      	adds	r2, #48	; 0x30
    1682:	18c9      	adds	r1, r1, r3
    1684:	0088      	lsls	r0, r1, #2
    1686:	3008      	adds	r0, #8
    1688:	1812      	adds	r2, r2, r0
    168a:	4294      	cmp	r4, r2
    168c:	d00a      	beq.n	16a4 <vTaskSwitchContext+0x6c>
    168e:	009a      	lsls	r2, r3, #2
    1690:	18d2      	adds	r2, r2, r3
    1692:	0091      	lsls	r1, r2, #2
    1694:	4a08      	ldr	r2, [pc, #32]	; (16b8 <vTaskSwitchContext+0x80>)
    1696:	1852      	adds	r2, r2, r1
    1698:	6b52      	ldr	r2, [r2, #52]	; 0x34
    169a:	68d1      	ldr	r1, [r2, #12]
    169c:	4a04      	ldr	r2, [pc, #16]	; (16b0 <vTaskSwitchContext+0x78>)
    169e:	6591      	str	r1, [r2, #88]	; 0x58
    16a0:	6653      	str	r3, [r2, #100]	; 0x64
}
    16a2:	e7e2      	b.n	166a <vTaskSwitchContext+0x32>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    16a4:	6860      	ldr	r0, [r4, #4]
    16a6:	0089      	lsls	r1, r1, #2
    16a8:	4a03      	ldr	r2, [pc, #12]	; (16b8 <vTaskSwitchContext+0x80>)
    16aa:	1852      	adds	r2, r2, r1
    16ac:	6350      	str	r0, [r2, #52]	; 0x34
    16ae:	e7ee      	b.n	168e <vTaskSwitchContext+0x56>
    16b0:	20004388 	.word	0x20004388
    16b4:	20004408 	.word	0x20004408
    16b8:	20004308 	.word	0x20004308

000016bc <vTaskPlaceOnEventList>:
{
    16bc:	b510      	push	{r4, lr}
    16be:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    16c0:	2800      	cmp	r0, #0
    16c2:	d101      	bne.n	16c8 <vTaskPlaceOnEventList+0xc>
    16c4:	b672      	cpsid	i
    16c6:	e7fe      	b.n	16c6 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    16c8:	4b04      	ldr	r3, [pc, #16]	; (16dc <vTaskPlaceOnEventList+0x20>)
    16ca:	6d99      	ldr	r1, [r3, #88]	; 0x58
    16cc:	3118      	adds	r1, #24
    16ce:	4b04      	ldr	r3, [pc, #16]	; (16e0 <vTaskPlaceOnEventList+0x24>)
    16d0:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    16d2:	2101      	movs	r1, #1
    16d4:	0020      	movs	r0, r4
    16d6:	4b03      	ldr	r3, [pc, #12]	; (16e4 <vTaskPlaceOnEventList+0x28>)
    16d8:	4798      	blx	r3
}
    16da:	bd10      	pop	{r4, pc}
    16dc:	20004388 	.word	0x20004388
    16e0:	00000345 	.word	0x00000345
    16e4:	00001291 	.word	0x00001291

000016e8 <vTaskPlaceOnEventListRestricted>:
	{
    16e8:	b570      	push	{r4, r5, r6, lr}
    16ea:	000c      	movs	r4, r1
    16ec:	0015      	movs	r5, r2
		configASSERT( pxEventList );
    16ee:	2800      	cmp	r0, #0
    16f0:	d00d      	beq.n	170e <vTaskPlaceOnEventListRestricted+0x26>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    16f2:	4b08      	ldr	r3, [pc, #32]	; (1714 <vTaskPlaceOnEventListRestricted+0x2c>)
    16f4:	6d99      	ldr	r1, [r3, #88]	; 0x58
    16f6:	3118      	adds	r1, #24
    16f8:	4b07      	ldr	r3, [pc, #28]	; (1718 <vTaskPlaceOnEventListRestricted+0x30>)
    16fa:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
    16fc:	2d00      	cmp	r5, #0
    16fe:	d001      	beq.n	1704 <vTaskPlaceOnEventListRestricted+0x1c>
			xTicksToWait = portMAX_DELAY;
    1700:	2401      	movs	r4, #1
    1702:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    1704:	0029      	movs	r1, r5
    1706:	0020      	movs	r0, r4
    1708:	4b04      	ldr	r3, [pc, #16]	; (171c <vTaskPlaceOnEventListRestricted+0x34>)
    170a:	4798      	blx	r3
	}
    170c:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxEventList );
    170e:	b672      	cpsid	i
    1710:	e7fe      	b.n	1710 <vTaskPlaceOnEventListRestricted+0x28>
    1712:	46c0      	nop			; (mov r8, r8)
    1714:	20004388 	.word	0x20004388
    1718:	0000032d 	.word	0x0000032d
    171c:	00001291 	.word	0x00001291

00001720 <xTaskRemoveFromEventList>:
{
    1720:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1722:	68c3      	ldr	r3, [r0, #12]
    1724:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    1726:	2c00      	cmp	r4, #0
    1728:	d027      	beq.n	177a <xTaskRemoveFromEventList+0x5a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    172a:	0025      	movs	r5, r4
    172c:	3518      	adds	r5, #24
    172e:	0028      	movs	r0, r5
    1730:	4b17      	ldr	r3, [pc, #92]	; (1790 <xTaskRemoveFromEventList+0x70>)
    1732:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1734:	4b17      	ldr	r3, [pc, #92]	; (1794 <xTaskRemoveFromEventList+0x74>)
    1736:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1738:	2b00      	cmp	r3, #0
    173a:	d120      	bne.n	177e <xTaskRemoveFromEventList+0x5e>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    173c:	1d25      	adds	r5, r4, #4
    173e:	0028      	movs	r0, r5
    1740:	4b13      	ldr	r3, [pc, #76]	; (1790 <xTaskRemoveFromEventList+0x70>)
    1742:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    1744:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1746:	4b13      	ldr	r3, [pc, #76]	; (1794 <xTaskRemoveFromEventList+0x74>)
    1748:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    174a:	429a      	cmp	r2, r3
    174c:	d901      	bls.n	1752 <xTaskRemoveFromEventList+0x32>
    174e:	4b11      	ldr	r3, [pc, #68]	; (1794 <xTaskRemoveFromEventList+0x74>)
    1750:	665a      	str	r2, [r3, #100]	; 0x64
    1752:	0093      	lsls	r3, r2, #2
    1754:	189b      	adds	r3, r3, r2
    1756:	009a      	lsls	r2, r3, #2
    1758:	480f      	ldr	r0, [pc, #60]	; (1798 <xTaskRemoveFromEventList+0x78>)
    175a:	3030      	adds	r0, #48	; 0x30
    175c:	1880      	adds	r0, r0, r2
    175e:	0029      	movs	r1, r5
    1760:	4b0e      	ldr	r3, [pc, #56]	; (179c <xTaskRemoveFromEventList+0x7c>)
    1762:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1764:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1766:	4b0b      	ldr	r3, [pc, #44]	; (1794 <xTaskRemoveFromEventList+0x74>)
    1768:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    176a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    176c:	429a      	cmp	r2, r3
    176e:	d90c      	bls.n	178a <xTaskRemoveFromEventList+0x6a>
		xYieldPending = pdTRUE;
    1770:	2201      	movs	r2, #1
    1772:	4b0b      	ldr	r3, [pc, #44]	; (17a0 <xTaskRemoveFromEventList+0x80>)
    1774:	601a      	str	r2, [r3, #0]
		xReturn = pdTRUE;
    1776:	2001      	movs	r0, #1
}
    1778:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxUnblockedTCB );
    177a:	b672      	cpsid	i
    177c:	e7fe      	b.n	177c <xTaskRemoveFromEventList+0x5c>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    177e:	0029      	movs	r1, r5
    1780:	4805      	ldr	r0, [pc, #20]	; (1798 <xTaskRemoveFromEventList+0x78>)
    1782:	3014      	adds	r0, #20
    1784:	4b05      	ldr	r3, [pc, #20]	; (179c <xTaskRemoveFromEventList+0x7c>)
    1786:	4798      	blx	r3
    1788:	e7ec      	b.n	1764 <xTaskRemoveFromEventList+0x44>
		xReturn = pdFALSE;
    178a:	2000      	movs	r0, #0
	return xReturn;
    178c:	e7f4      	b.n	1778 <xTaskRemoveFromEventList+0x58>
    178e:	46c0      	nop			; (mov r8, r8)
    1790:	00000375 	.word	0x00000375
    1794:	20004388 	.word	0x20004388
    1798:	20004308 	.word	0x20004308
    179c:	0000032d 	.word	0x0000032d
    17a0:	20004408 	.word	0x20004408

000017a4 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    17a4:	4b02      	ldr	r3, [pc, #8]	; (17b0 <vTaskInternalSetTimeOutState+0xc>)
    17a6:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    17a8:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    17aa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    17ac:	6043      	str	r3, [r0, #4]
}
    17ae:	4770      	bx	lr
    17b0:	20004388 	.word	0x20004388

000017b4 <xTaskCheckForTimeOut>:
{
    17b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    17b6:	0005      	movs	r5, r0
    17b8:	000c      	movs	r4, r1
	configASSERT( pxTimeOut );
    17ba:	2800      	cmp	r0, #0
    17bc:	d01a      	beq.n	17f4 <xTaskCheckForTimeOut+0x40>
	configASSERT( pxTicksToWait );
    17be:	2900      	cmp	r1, #0
    17c0:	d01a      	beq.n	17f8 <xTaskCheckForTimeOut+0x44>
	taskENTER_CRITICAL();
    17c2:	4b14      	ldr	r3, [pc, #80]	; (1814 <xTaskCheckForTimeOut+0x60>)
    17c4:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    17c6:	4b14      	ldr	r3, [pc, #80]	; (1818 <xTaskCheckForTimeOut+0x64>)
    17c8:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    17ca:	6869      	ldr	r1, [r5, #4]
    17cc:	1a42      	subs	r2, r0, r1
			if( *pxTicksToWait == portMAX_DELAY )
    17ce:	6823      	ldr	r3, [r4, #0]
    17d0:	1c5e      	adds	r6, r3, #1
    17d2:	d01a      	beq.n	180a <xTaskCheckForTimeOut+0x56>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    17d4:	4e10      	ldr	r6, [pc, #64]	; (1818 <xTaskCheckForTimeOut+0x64>)
    17d6:	6fb6      	ldr	r6, [r6, #120]	; 0x78
    17d8:	682f      	ldr	r7, [r5, #0]
    17da:	42b7      	cmp	r7, r6
    17dc:	d001      	beq.n	17e2 <xTaskCheckForTimeOut+0x2e>
    17de:	4288      	cmp	r0, r1
    17e0:	d215      	bcs.n	180e <xTaskCheckForTimeOut+0x5a>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    17e2:	429a      	cmp	r2, r3
    17e4:	d30a      	bcc.n	17fc <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait = 0;
    17e6:	2300      	movs	r3, #0
    17e8:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
    17ea:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    17ec:	4b0b      	ldr	r3, [pc, #44]	; (181c <xTaskCheckForTimeOut+0x68>)
    17ee:	4798      	blx	r3
}
    17f0:	0020      	movs	r0, r4
    17f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	configASSERT( pxTimeOut );
    17f4:	b672      	cpsid	i
    17f6:	e7fe      	b.n	17f6 <xTaskCheckForTimeOut+0x42>
	configASSERT( pxTicksToWait );
    17f8:	b672      	cpsid	i
    17fa:	e7fe      	b.n	17fa <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= xElapsedTime;
    17fc:	1a9b      	subs	r3, r3, r2
    17fe:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    1800:	0028      	movs	r0, r5
    1802:	4b07      	ldr	r3, [pc, #28]	; (1820 <xTaskCheckForTimeOut+0x6c>)
    1804:	4798      	blx	r3
			xReturn = pdFALSE;
    1806:	2400      	movs	r4, #0
    1808:	e7f0      	b.n	17ec <xTaskCheckForTimeOut+0x38>
				xReturn = pdFALSE;
    180a:	2400      	movs	r4, #0
    180c:	e7ee      	b.n	17ec <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
    180e:	2401      	movs	r4, #1
    1810:	e7ec      	b.n	17ec <xTaskCheckForTimeOut+0x38>
    1812:	46c0      	nop			; (mov r8, r8)
    1814:	00000821 	.word	0x00000821
    1818:	20004388 	.word	0x20004388
    181c:	00000839 	.word	0x00000839
    1820:	000017a5 	.word	0x000017a5

00001824 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    1824:	2201      	movs	r2, #1
    1826:	4b01      	ldr	r3, [pc, #4]	; (182c <vTaskMissedYield+0x8>)
    1828:	601a      	str	r2, [r3, #0]
}
    182a:	4770      	bx	lr
    182c:	20004408 	.word	0x20004408

00001830 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    1830:	4b06      	ldr	r3, [pc, #24]	; (184c <xTaskGetSchedulerState+0x1c>)
    1832:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1834:	2b00      	cmp	r3, #0
    1836:	d005      	beq.n	1844 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1838:	4b04      	ldr	r3, [pc, #16]	; (184c <xTaskGetSchedulerState+0x1c>)
    183a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    183c:	2b00      	cmp	r3, #0
    183e:	d103      	bne.n	1848 <xTaskGetSchedulerState+0x18>
				xReturn = taskSCHEDULER_RUNNING;
    1840:	2002      	movs	r0, #2
	}
    1842:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
    1844:	2001      	movs	r0, #1
    1846:	e7fc      	b.n	1842 <xTaskGetSchedulerState+0x12>
				xReturn = taskSCHEDULER_SUSPENDED;
    1848:	2000      	movs	r0, #0
		return xReturn;
    184a:	e7fa      	b.n	1842 <xTaskGetSchedulerState+0x12>
    184c:	20004388 	.word	0x20004388

00001850 <xTaskPriorityDisinherit>:
	{
    1850:	b570      	push	{r4, r5, r6, lr}
    1852:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    1854:	d02c      	beq.n	18b0 <xTaskPriorityDisinherit+0x60>
			configASSERT( pxTCB == pxCurrentTCB );
    1856:	4b19      	ldr	r3, [pc, #100]	; (18bc <xTaskPriorityDisinherit+0x6c>)
    1858:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    185a:	4298      	cmp	r0, r3
    185c:	d001      	beq.n	1862 <xTaskPriorityDisinherit+0x12>
    185e:	b672      	cpsid	i
    1860:	e7fe      	b.n	1860 <xTaskPriorityDisinherit+0x10>
			configASSERT( pxTCB->uxMutexesHeld );
    1862:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1864:	2b00      	cmp	r3, #0
    1866:	d101      	bne.n	186c <xTaskPriorityDisinherit+0x1c>
    1868:	b672      	cpsid	i
    186a:	e7fe      	b.n	186a <xTaskPriorityDisinherit+0x1a>
			( pxTCB->uxMutexesHeld )--;
    186c:	3b01      	subs	r3, #1
    186e:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1870:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    1872:	6c41      	ldr	r1, [r0, #68]	; 0x44
    1874:	428a      	cmp	r2, r1
    1876:	d01d      	beq.n	18b4 <xTaskPriorityDisinherit+0x64>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1878:	2b00      	cmp	r3, #0
    187a:	d11d      	bne.n	18b8 <xTaskPriorityDisinherit+0x68>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    187c:	1d05      	adds	r5, r0, #4
    187e:	0028      	movs	r0, r5
    1880:	4b0f      	ldr	r3, [pc, #60]	; (18c0 <xTaskPriorityDisinherit+0x70>)
    1882:	4798      	blx	r3
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1884:	6c63      	ldr	r3, [r4, #68]	; 0x44
    1886:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1888:	2205      	movs	r2, #5
    188a:	1ad2      	subs	r2, r2, r3
    188c:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
    188e:	4a0b      	ldr	r2, [pc, #44]	; (18bc <xTaskPriorityDisinherit+0x6c>)
    1890:	6e52      	ldr	r2, [r2, #100]	; 0x64
    1892:	4293      	cmp	r3, r2
    1894:	d901      	bls.n	189a <xTaskPriorityDisinherit+0x4a>
    1896:	4a09      	ldr	r2, [pc, #36]	; (18bc <xTaskPriorityDisinherit+0x6c>)
    1898:	6653      	str	r3, [r2, #100]	; 0x64
    189a:	009a      	lsls	r2, r3, #2
    189c:	18d3      	adds	r3, r2, r3
    189e:	009a      	lsls	r2, r3, #2
    18a0:	4808      	ldr	r0, [pc, #32]	; (18c4 <xTaskPriorityDisinherit+0x74>)
    18a2:	3030      	adds	r0, #48	; 0x30
    18a4:	1880      	adds	r0, r0, r2
    18a6:	0029      	movs	r1, r5
    18a8:	4b07      	ldr	r3, [pc, #28]	; (18c8 <xTaskPriorityDisinherit+0x78>)
    18aa:	4798      	blx	r3
					xReturn = pdTRUE;
    18ac:	2001      	movs	r0, #1
	}
    18ae:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xReturn = pdFALSE;
    18b0:	2000      	movs	r0, #0
    18b2:	e7fc      	b.n	18ae <xTaskPriorityDisinherit+0x5e>
    18b4:	2000      	movs	r0, #0
    18b6:	e7fa      	b.n	18ae <xTaskPriorityDisinherit+0x5e>
    18b8:	2000      	movs	r0, #0
		return xReturn;
    18ba:	e7f8      	b.n	18ae <xTaskPriorityDisinherit+0x5e>
    18bc:	20004388 	.word	0x20004388
    18c0:	00000375 	.word	0x00000375
    18c4:	20004308 	.word	0x20004308
    18c8:	0000032d 	.word	0x0000032d

000018cc <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    18cc:	4b06      	ldr	r3, [pc, #24]	; (18e8 <prvGetNextExpireTime+0x1c>)
    18ce:	681a      	ldr	r2, [r3, #0]
    18d0:	6813      	ldr	r3, [r2, #0]
    18d2:	4259      	negs	r1, r3
    18d4:	414b      	adcs	r3, r1
    18d6:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
    18d8:	2b00      	cmp	r3, #0
    18da:	d102      	bne.n	18e2 <prvGetNextExpireTime+0x16>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    18dc:	68d3      	ldr	r3, [r2, #12]
    18de:	6818      	ldr	r0, [r3, #0]
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
	}

	return xNextExpireTime;
}
    18e0:	4770      	bx	lr
		xNextExpireTime = ( TickType_t ) 0U;
    18e2:	2000      	movs	r0, #0
	return xNextExpireTime;
    18e4:	e7fc      	b.n	18e0 <prvGetNextExpireTime+0x14>
    18e6:	46c0      	nop			; (mov r8, r8)
    18e8:	2000440c 	.word	0x2000440c

000018ec <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    18ec:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    18ee:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    18f0:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    18f2:	4291      	cmp	r1, r2
    18f4:	d80c      	bhi.n	1910 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18f6:	1ad2      	subs	r2, r2, r3
    18f8:	6983      	ldr	r3, [r0, #24]
    18fa:	429a      	cmp	r2, r3
    18fc:	d301      	bcc.n	1902 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    18fe:	2001      	movs	r0, #1
    1900:	e010      	b.n	1924 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1902:	1d01      	adds	r1, r0, #4
    1904:	4b09      	ldr	r3, [pc, #36]	; (192c <prvInsertTimerInActiveList+0x40>)
    1906:	6858      	ldr	r0, [r3, #4]
    1908:	4b09      	ldr	r3, [pc, #36]	; (1930 <prvInsertTimerInActiveList+0x44>)
    190a:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    190c:	2000      	movs	r0, #0
    190e:	e009      	b.n	1924 <prvInsertTimerInActiveList+0x38>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1910:	429a      	cmp	r2, r3
    1912:	d201      	bcs.n	1918 <prvInsertTimerInActiveList+0x2c>
    1914:	4299      	cmp	r1, r3
    1916:	d206      	bcs.n	1926 <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1918:	1d01      	adds	r1, r0, #4
    191a:	4b04      	ldr	r3, [pc, #16]	; (192c <prvInsertTimerInActiveList+0x40>)
    191c:	6818      	ldr	r0, [r3, #0]
    191e:	4b04      	ldr	r3, [pc, #16]	; (1930 <prvInsertTimerInActiveList+0x44>)
    1920:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1922:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    1924:	bd10      	pop	{r4, pc}
			xProcessTimerNow = pdTRUE;
    1926:	2001      	movs	r0, #1
	return xProcessTimerNow;
    1928:	e7fc      	b.n	1924 <prvInsertTimerInActiveList+0x38>
    192a:	46c0      	nop			; (mov r8, r8)
    192c:	2000440c 	.word	0x2000440c
    1930:	00000345 	.word	0x00000345

00001934 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    1934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    1936:	4b10      	ldr	r3, [pc, #64]	; (1978 <prvCheckForValidListAndQueue+0x44>)
    1938:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    193a:	4b10      	ldr	r3, [pc, #64]	; (197c <prvCheckForValidListAndQueue+0x48>)
    193c:	689b      	ldr	r3, [r3, #8]
    193e:	2b00      	cmp	r3, #0
    1940:	d002      	beq.n	1948 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1942:	4b0f      	ldr	r3, [pc, #60]	; (1980 <prvCheckForValidListAndQueue+0x4c>)
    1944:	4798      	blx	r3
}
    1946:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    1948:	4c0c      	ldr	r4, [pc, #48]	; (197c <prvCheckForValidListAndQueue+0x48>)
    194a:	0026      	movs	r6, r4
    194c:	360c      	adds	r6, #12
    194e:	0030      	movs	r0, r6
    1950:	4f0c      	ldr	r7, [pc, #48]	; (1984 <prvCheckForValidListAndQueue+0x50>)
    1952:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    1954:	0025      	movs	r5, r4
    1956:	3520      	adds	r5, #32
    1958:	0028      	movs	r0, r5
    195a:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
    195c:	6026      	str	r6, [r4, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    195e:	6065      	str	r5, [r4, #4]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1960:	2200      	movs	r2, #0
    1962:	210c      	movs	r1, #12
    1964:	2005      	movs	r0, #5
    1966:	4b08      	ldr	r3, [pc, #32]	; (1988 <prvCheckForValidListAndQueue+0x54>)
    1968:	4798      	blx	r3
    196a:	60a0      	str	r0, [r4, #8]
				if( xTimerQueue != NULL )
    196c:	2800      	cmp	r0, #0
    196e:	d0e8      	beq.n	1942 <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    1970:	4906      	ldr	r1, [pc, #24]	; (198c <prvCheckForValidListAndQueue+0x58>)
    1972:	4b07      	ldr	r3, [pc, #28]	; (1990 <prvCheckForValidListAndQueue+0x5c>)
    1974:	4798      	blx	r3
    1976:	e7e4      	b.n	1942 <prvCheckForValidListAndQueue+0xe>
    1978:	00000821 	.word	0x00000821
    197c:	2000440c 	.word	0x2000440c
    1980:	00000839 	.word	0x00000839
    1984:	00000311 	.word	0x00000311
    1988:	00000b99 	.word	0x00000b99
    198c:	000020cc 	.word	0x000020cc
    1990:	00000fb9 	.word	0x00000fb9

00001994 <xTimerCreateTimerTask>:
{
    1994:	b510      	push	{r4, lr}
    1996:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    1998:	4b0c      	ldr	r3, [pc, #48]	; (19cc <xTimerCreateTimerTask+0x38>)
    199a:	4798      	blx	r3
	if( xTimerQueue != NULL )
    199c:	4b0c      	ldr	r3, [pc, #48]	; (19d0 <xTimerCreateTimerTask+0x3c>)
    199e:	689b      	ldr	r3, [r3, #8]
    19a0:	2b00      	cmp	r3, #0
    19a2:	d00e      	beq.n	19c2 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    19a4:	4b0a      	ldr	r3, [pc, #40]	; (19d0 <xTimerCreateTimerTask+0x3c>)
    19a6:	3334      	adds	r3, #52	; 0x34
    19a8:	9301      	str	r3, [sp, #4]
    19aa:	2302      	movs	r3, #2
    19ac:	9300      	str	r3, [sp, #0]
    19ae:	2300      	movs	r3, #0
    19b0:	2250      	movs	r2, #80	; 0x50
    19b2:	4908      	ldr	r1, [pc, #32]	; (19d4 <xTimerCreateTimerTask+0x40>)
    19b4:	4808      	ldr	r0, [pc, #32]	; (19d8 <xTimerCreateTimerTask+0x44>)
    19b6:	4c09      	ldr	r4, [pc, #36]	; (19dc <xTimerCreateTimerTask+0x48>)
    19b8:	47a0      	blx	r4
	configASSERT( xReturn );
    19ba:	2800      	cmp	r0, #0
    19bc:	d103      	bne.n	19c6 <xTimerCreateTimerTask+0x32>
    19be:	b672      	cpsid	i
    19c0:	e7fe      	b.n	19c0 <xTimerCreateTimerTask+0x2c>
BaseType_t xReturn = pdFAIL;
    19c2:	2000      	movs	r0, #0
    19c4:	e7f9      	b.n	19ba <xTimerCreateTimerTask+0x26>
}
    19c6:	b002      	add	sp, #8
    19c8:	bd10      	pop	{r4, pc}
    19ca:	46c0      	nop			; (mov r8, r8)
    19cc:	00001935 	.word	0x00001935
    19d0:	2000440c 	.word	0x2000440c
    19d4:	000020d4 	.word	0x000020d4
    19d8:	00001c99 	.word	0x00001c99
    19dc:	00001301 	.word	0x00001301

000019e0 <xTimerGenericCommand>:
{
    19e0:	b530      	push	{r4, r5, lr}
    19e2:	b085      	sub	sp, #20
    19e4:	0004      	movs	r4, r0
    19e6:	001d      	movs	r5, r3
	configASSERT( xTimer );
    19e8:	2800      	cmp	r0, #0
    19ea:	d014      	beq.n	1a16 <xTimerGenericCommand+0x36>
	if( xTimerQueue != NULL )
    19ec:	4b13      	ldr	r3, [pc, #76]	; (1a3c <xTimerGenericCommand+0x5c>)
    19ee:	6898      	ldr	r0, [r3, #8]
    19f0:	2800      	cmp	r0, #0
    19f2:	d021      	beq.n	1a38 <xTimerGenericCommand+0x58>
		xMessage.xMessageID = xCommandID;
    19f4:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    19f6:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    19f8:	9403      	str	r4, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    19fa:	2905      	cmp	r1, #5
    19fc:	dc15      	bgt.n	1a2a <xTimerGenericCommand+0x4a>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    19fe:	4b10      	ldr	r3, [pc, #64]	; (1a40 <xTimerGenericCommand+0x60>)
    1a00:	4798      	blx	r3
    1a02:	2802      	cmp	r0, #2
    1a04:	d009      	beq.n	1a1a <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1a06:	4b0d      	ldr	r3, [pc, #52]	; (1a3c <xTimerGenericCommand+0x5c>)
    1a08:	6898      	ldr	r0, [r3, #8]
    1a0a:	2300      	movs	r3, #0
    1a0c:	2200      	movs	r2, #0
    1a0e:	a901      	add	r1, sp, #4
    1a10:	4c0c      	ldr	r4, [pc, #48]	; (1a44 <xTimerGenericCommand+0x64>)
    1a12:	47a0      	blx	r4
    1a14:	e00e      	b.n	1a34 <xTimerGenericCommand+0x54>
	configASSERT( xTimer );
    1a16:	b672      	cpsid	i
    1a18:	e7fe      	b.n	1a18 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1a1a:	4b08      	ldr	r3, [pc, #32]	; (1a3c <xTimerGenericCommand+0x5c>)
    1a1c:	6898      	ldr	r0, [r3, #8]
    1a1e:	2300      	movs	r3, #0
    1a20:	9a08      	ldr	r2, [sp, #32]
    1a22:	a901      	add	r1, sp, #4
    1a24:	4c07      	ldr	r4, [pc, #28]	; (1a44 <xTimerGenericCommand+0x64>)
    1a26:	47a0      	blx	r4
    1a28:	e004      	b.n	1a34 <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1a2a:	2300      	movs	r3, #0
    1a2c:	002a      	movs	r2, r5
    1a2e:	a901      	add	r1, sp, #4
    1a30:	4c05      	ldr	r4, [pc, #20]	; (1a48 <xTimerGenericCommand+0x68>)
    1a32:	47a0      	blx	r4
}
    1a34:	b005      	add	sp, #20
    1a36:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
    1a38:	2000      	movs	r0, #0
	return xReturn;
    1a3a:	e7fb      	b.n	1a34 <xTimerGenericCommand+0x54>
    1a3c:	2000440c 	.word	0x2000440c
    1a40:	00001831 	.word	0x00001831
    1a44:	00000be1 	.word	0x00000be1
    1a48:	00000d71 	.word	0x00000d71

00001a4c <prvSwitchTimerLists>:
{
    1a4c:	b570      	push	{r4, r5, r6, lr}
    1a4e:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1a50:	4b17      	ldr	r3, [pc, #92]	; (1ab0 <prvSwitchTimerLists+0x64>)
    1a52:	681b      	ldr	r3, [r3, #0]
    1a54:	681a      	ldr	r2, [r3, #0]
    1a56:	2a00      	cmp	r2, #0
    1a58:	d023      	beq.n	1aa2 <prvSwitchTimerLists+0x56>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a5a:	68db      	ldr	r3, [r3, #12]
    1a5c:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a5e:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1a60:	1d25      	adds	r5, r4, #4
    1a62:	0028      	movs	r0, r5
    1a64:	4b13      	ldr	r3, [pc, #76]	; (1ab4 <prvSwitchTimerLists+0x68>)
    1a66:	4798      	blx	r3
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1a68:	0020      	movs	r0, r4
    1a6a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1a6c:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1a6e:	69e3      	ldr	r3, [r4, #28]
    1a70:	2b01      	cmp	r3, #1
    1a72:	d1ed      	bne.n	1a50 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1a74:	69a3      	ldr	r3, [r4, #24]
    1a76:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
    1a78:	429e      	cmp	r6, r3
    1a7a:	d207      	bcs.n	1a8c <prvSwitchTimerLists+0x40>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1a7c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1a7e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1a80:	4b0b      	ldr	r3, [pc, #44]	; (1ab0 <prvSwitchTimerLists+0x64>)
    1a82:	6818      	ldr	r0, [r3, #0]
    1a84:	0029      	movs	r1, r5
    1a86:	4b0c      	ldr	r3, [pc, #48]	; (1ab8 <prvSwitchTimerLists+0x6c>)
    1a88:	4798      	blx	r3
    1a8a:	e7e1      	b.n	1a50 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1a8c:	2300      	movs	r3, #0
    1a8e:	9300      	str	r3, [sp, #0]
    1a90:	0032      	movs	r2, r6
    1a92:	2100      	movs	r1, #0
    1a94:	0020      	movs	r0, r4
    1a96:	4c09      	ldr	r4, [pc, #36]	; (1abc <prvSwitchTimerLists+0x70>)
    1a98:	47a0      	blx	r4
				configASSERT( xResult );
    1a9a:	2800      	cmp	r0, #0
    1a9c:	d1d8      	bne.n	1a50 <prvSwitchTimerLists+0x4>
    1a9e:	b672      	cpsid	i
    1aa0:	e7fe      	b.n	1aa0 <prvSwitchTimerLists+0x54>
	pxCurrentTimerList = pxOverflowTimerList;
    1aa2:	4a03      	ldr	r2, [pc, #12]	; (1ab0 <prvSwitchTimerLists+0x64>)
    1aa4:	6851      	ldr	r1, [r2, #4]
    1aa6:	6011      	str	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
    1aa8:	6053      	str	r3, [r2, #4]
}
    1aaa:	b002      	add	sp, #8
    1aac:	bd70      	pop	{r4, r5, r6, pc}
    1aae:	46c0      	nop			; (mov r8, r8)
    1ab0:	2000440c 	.word	0x2000440c
    1ab4:	00000375 	.word	0x00000375
    1ab8:	00000345 	.word	0x00000345
    1abc:	000019e1 	.word	0x000019e1

00001ac0 <prvSampleTimeNow>:
{
    1ac0:	b570      	push	{r4, r5, r6, lr}
    1ac2:	0005      	movs	r5, r0
	xTimeNow = xTaskGetTickCount();
    1ac4:	4b08      	ldr	r3, [pc, #32]	; (1ae8 <prvSampleTimeNow+0x28>)
    1ac6:	4798      	blx	r3
    1ac8:	0004      	movs	r4, r0
	if( xTimeNow < xLastTime )
    1aca:	4b08      	ldr	r3, [pc, #32]	; (1aec <prvSampleTimeNow+0x2c>)
    1acc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1ace:	4298      	cmp	r0, r3
    1ad0:	d305      	bcc.n	1ade <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
    1ad2:	2300      	movs	r3, #0
    1ad4:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
    1ad6:	4b05      	ldr	r3, [pc, #20]	; (1aec <prvSampleTimeNow+0x2c>)
    1ad8:	639c      	str	r4, [r3, #56]	; 0x38
}
    1ada:	0020      	movs	r0, r4
    1adc:	bd70      	pop	{r4, r5, r6, pc}
		prvSwitchTimerLists();
    1ade:	4b04      	ldr	r3, [pc, #16]	; (1af0 <prvSampleTimeNow+0x30>)
    1ae0:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
    1ae2:	2301      	movs	r3, #1
    1ae4:	602b      	str	r3, [r5, #0]
    1ae6:	e7f6      	b.n	1ad6 <prvSampleTimeNow+0x16>
    1ae8:	000013e9 	.word	0x000013e9
    1aec:	2000440c 	.word	0x2000440c
    1af0:	00001a4d 	.word	0x00001a4d

00001af4 <prvProcessExpiredTimer>:
{
    1af4:	b570      	push	{r4, r5, r6, lr}
    1af6:	b082      	sub	sp, #8
    1af8:	0005      	movs	r5, r0
    1afa:	000e      	movs	r6, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1afc:	4b11      	ldr	r3, [pc, #68]	; (1b44 <prvProcessExpiredTimer+0x50>)
    1afe:	681b      	ldr	r3, [r3, #0]
    1b00:	68db      	ldr	r3, [r3, #12]
    1b02:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1b04:	1d20      	adds	r0, r4, #4
    1b06:	4b10      	ldr	r3, [pc, #64]	; (1b48 <prvProcessExpiredTimer+0x54>)
    1b08:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1b0a:	69e3      	ldr	r3, [r4, #28]
    1b0c:	2b01      	cmp	r3, #1
    1b0e:	d004      	beq.n	1b1a <prvProcessExpiredTimer+0x26>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1b10:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1b12:	0020      	movs	r0, r4
    1b14:	4798      	blx	r3
}
    1b16:	b002      	add	sp, #8
    1b18:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1b1a:	69a3      	ldr	r3, [r4, #24]
    1b1c:	1959      	adds	r1, r3, r5
    1b1e:	002b      	movs	r3, r5
    1b20:	0032      	movs	r2, r6
    1b22:	0020      	movs	r0, r4
    1b24:	4e09      	ldr	r6, [pc, #36]	; (1b4c <prvProcessExpiredTimer+0x58>)
    1b26:	47b0      	blx	r6
    1b28:	2800      	cmp	r0, #0
    1b2a:	d0f1      	beq.n	1b10 <prvProcessExpiredTimer+0x1c>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1b2c:	2300      	movs	r3, #0
    1b2e:	9300      	str	r3, [sp, #0]
    1b30:	002a      	movs	r2, r5
    1b32:	2100      	movs	r1, #0
    1b34:	0020      	movs	r0, r4
    1b36:	4d06      	ldr	r5, [pc, #24]	; (1b50 <prvProcessExpiredTimer+0x5c>)
    1b38:	47a8      	blx	r5
			configASSERT( xResult );
    1b3a:	2800      	cmp	r0, #0
    1b3c:	d1e8      	bne.n	1b10 <prvProcessExpiredTimer+0x1c>
    1b3e:	b672      	cpsid	i
    1b40:	e7fe      	b.n	1b40 <prvProcessExpiredTimer+0x4c>
    1b42:	46c0      	nop			; (mov r8, r8)
    1b44:	2000440c 	.word	0x2000440c
    1b48:	00000375 	.word	0x00000375
    1b4c:	000018ed 	.word	0x000018ed
    1b50:	000019e1 	.word	0x000019e1

00001b54 <prvProcessTimerOrBlockTask>:
{
    1b54:	b570      	push	{r4, r5, r6, lr}
    1b56:	b082      	sub	sp, #8
    1b58:	0005      	movs	r5, r0
    1b5a:	000c      	movs	r4, r1
	vTaskSuspendAll();
    1b5c:	4b16      	ldr	r3, [pc, #88]	; (1bb8 <prvProcessTimerOrBlockTask+0x64>)
    1b5e:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1b60:	a801      	add	r0, sp, #4
    1b62:	4b16      	ldr	r3, [pc, #88]	; (1bbc <prvProcessTimerOrBlockTask+0x68>)
    1b64:	4798      	blx	r3
    1b66:	0006      	movs	r6, r0
		if( xTimerListsWereSwitched == pdFALSE )
    1b68:	9b01      	ldr	r3, [sp, #4]
    1b6a:	2b00      	cmp	r3, #0
    1b6c:	d121      	bne.n	1bb2 <prvProcessTimerOrBlockTask+0x5e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1b6e:	2c00      	cmp	r4, #0
    1b70:	d101      	bne.n	1b76 <prvProcessTimerOrBlockTask+0x22>
    1b72:	42a8      	cmp	r0, r5
    1b74:	d213      	bcs.n	1b9e <prvProcessTimerOrBlockTask+0x4a>
				if( xListWasEmpty != pdFALSE )
    1b76:	2c00      	cmp	r4, #0
    1b78:	d005      	beq.n	1b86 <prvProcessTimerOrBlockTask+0x32>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1b7a:	4b11      	ldr	r3, [pc, #68]	; (1bc0 <prvProcessTimerOrBlockTask+0x6c>)
    1b7c:	685b      	ldr	r3, [r3, #4]
    1b7e:	681c      	ldr	r4, [r3, #0]
    1b80:	4263      	negs	r3, r4
    1b82:	415c      	adcs	r4, r3
    1b84:	b2e4      	uxtb	r4, r4
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1b86:	1ba9      	subs	r1, r5, r6
    1b88:	4b0d      	ldr	r3, [pc, #52]	; (1bc0 <prvProcessTimerOrBlockTask+0x6c>)
    1b8a:	6898      	ldr	r0, [r3, #8]
    1b8c:	0022      	movs	r2, r4
    1b8e:	4b0d      	ldr	r3, [pc, #52]	; (1bc4 <prvProcessTimerOrBlockTask+0x70>)
    1b90:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    1b92:	4b0d      	ldr	r3, [pc, #52]	; (1bc8 <prvProcessTimerOrBlockTask+0x74>)
    1b94:	4798      	blx	r3
    1b96:	2800      	cmp	r0, #0
    1b98:	d008      	beq.n	1bac <prvProcessTimerOrBlockTask+0x58>
}
    1b9a:	b002      	add	sp, #8
    1b9c:	bd70      	pop	{r4, r5, r6, pc}
				( void ) xTaskResumeAll();
    1b9e:	4b0a      	ldr	r3, [pc, #40]	; (1bc8 <prvProcessTimerOrBlockTask+0x74>)
    1ba0:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    1ba2:	0031      	movs	r1, r6
    1ba4:	0028      	movs	r0, r5
    1ba6:	4b09      	ldr	r3, [pc, #36]	; (1bcc <prvProcessTimerOrBlockTask+0x78>)
    1ba8:	4798      	blx	r3
    1baa:	e7f6      	b.n	1b9a <prvProcessTimerOrBlockTask+0x46>
					portYIELD_WITHIN_API();
    1bac:	4b08      	ldr	r3, [pc, #32]	; (1bd0 <prvProcessTimerOrBlockTask+0x7c>)
    1bae:	4798      	blx	r3
    1bb0:	e7f3      	b.n	1b9a <prvProcessTimerOrBlockTask+0x46>
			( void ) xTaskResumeAll();
    1bb2:	4b05      	ldr	r3, [pc, #20]	; (1bc8 <prvProcessTimerOrBlockTask+0x74>)
    1bb4:	4798      	blx	r3
}
    1bb6:	e7f0      	b.n	1b9a <prvProcessTimerOrBlockTask+0x46>
    1bb8:	000013d9 	.word	0x000013d9
    1bbc:	00001ac1 	.word	0x00001ac1
    1bc0:	2000440c 	.word	0x2000440c
    1bc4:	00000fdd 	.word	0x00000fdd
    1bc8:	00001501 	.word	0x00001501
    1bcc:	00001af5 	.word	0x00001af5
    1bd0:	00000809 	.word	0x00000809

00001bd4 <prvProcessReceivedCommands>:
{
    1bd4:	b530      	push	{r4, r5, lr}
    1bd6:	b087      	sub	sp, #28
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1bd8:	4b27      	ldr	r3, [pc, #156]	; (1c78 <prvProcessReceivedCommands+0xa4>)
    1bda:	6898      	ldr	r0, [r3, #8]
    1bdc:	2200      	movs	r2, #0
    1bde:	a903      	add	r1, sp, #12
    1be0:	4b26      	ldr	r3, [pc, #152]	; (1c7c <prvProcessReceivedCommands+0xa8>)
    1be2:	4798      	blx	r3
    1be4:	2800      	cmp	r0, #0
    1be6:	d045      	beq.n	1c74 <prvProcessReceivedCommands+0xa0>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1be8:	9b03      	ldr	r3, [sp, #12]
    1bea:	2b00      	cmp	r3, #0
    1bec:	dbf4      	blt.n	1bd8 <prvProcessReceivedCommands+0x4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1bee:	9c05      	ldr	r4, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    1bf0:	6963      	ldr	r3, [r4, #20]
    1bf2:	2b00      	cmp	r3, #0
    1bf4:	d002      	beq.n	1bfc <prvProcessReceivedCommands+0x28>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1bf6:	1d20      	adds	r0, r4, #4
    1bf8:	4b21      	ldr	r3, [pc, #132]	; (1c80 <prvProcessReceivedCommands+0xac>)
    1bfa:	4798      	blx	r3
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1bfc:	a802      	add	r0, sp, #8
    1bfe:	4b21      	ldr	r3, [pc, #132]	; (1c84 <prvProcessReceivedCommands+0xb0>)
    1c00:	4798      	blx	r3
			switch( xMessage.xMessageID )
    1c02:	9b03      	ldr	r3, [sp, #12]
    1c04:	2b09      	cmp	r3, #9
    1c06:	d8e7      	bhi.n	1bd8 <prvProcessReceivedCommands+0x4>
    1c08:	009b      	lsls	r3, r3, #2
    1c0a:	4a1f      	ldr	r2, [pc, #124]	; (1c88 <prvProcessReceivedCommands+0xb4>)
    1c0c:	58d3      	ldr	r3, [r2, r3]
    1c0e:	469f      	mov	pc, r3
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1c10:	9b04      	ldr	r3, [sp, #16]
    1c12:	69a2      	ldr	r2, [r4, #24]
    1c14:	4694      	mov	ip, r2
    1c16:	4463      	add	r3, ip
    1c18:	0019      	movs	r1, r3
    1c1a:	9b04      	ldr	r3, [sp, #16]
    1c1c:	0002      	movs	r2, r0
    1c1e:	0020      	movs	r0, r4
    1c20:	4d1a      	ldr	r5, [pc, #104]	; (1c8c <prvProcessReceivedCommands+0xb8>)
    1c22:	47a8      	blx	r5
    1c24:	2800      	cmp	r0, #0
    1c26:	d0d7      	beq.n	1bd8 <prvProcessReceivedCommands+0x4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1c28:	0020      	movs	r0, r4
    1c2a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1c2c:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1c2e:	69e3      	ldr	r3, [r4, #28]
    1c30:	2b01      	cmp	r3, #1
    1c32:	d1d1      	bne.n	1bd8 <prvProcessReceivedCommands+0x4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1c34:	9b04      	ldr	r3, [sp, #16]
    1c36:	69a1      	ldr	r1, [r4, #24]
    1c38:	468c      	mov	ip, r1
    1c3a:	4463      	add	r3, ip
    1c3c:	001a      	movs	r2, r3
    1c3e:	2300      	movs	r3, #0
    1c40:	9300      	str	r3, [sp, #0]
    1c42:	2100      	movs	r1, #0
    1c44:	0020      	movs	r0, r4
    1c46:	4c12      	ldr	r4, [pc, #72]	; (1c90 <prvProcessReceivedCommands+0xbc>)
    1c48:	47a0      	blx	r4
							configASSERT( xResult );
    1c4a:	2800      	cmp	r0, #0
    1c4c:	d1c4      	bne.n	1bd8 <prvProcessReceivedCommands+0x4>
    1c4e:	b672      	cpsid	i
    1c50:	e7fe      	b.n	1c50 <prvProcessReceivedCommands+0x7c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1c52:	9904      	ldr	r1, [sp, #16]
    1c54:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1c56:	2900      	cmp	r1, #0
    1c58:	d006      	beq.n	1c68 <prvProcessReceivedCommands+0x94>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1c5a:	1841      	adds	r1, r0, r1
    1c5c:	0003      	movs	r3, r0
    1c5e:	0002      	movs	r2, r0
    1c60:	0020      	movs	r0, r4
    1c62:	4c0a      	ldr	r4, [pc, #40]	; (1c8c <prvProcessReceivedCommands+0xb8>)
    1c64:	47a0      	blx	r4
					break;
    1c66:	e7b7      	b.n	1bd8 <prvProcessReceivedCommands+0x4>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1c68:	b672      	cpsid	i
    1c6a:	e7fe      	b.n	1c6a <prvProcessReceivedCommands+0x96>
						vPortFree( pxTimer );
    1c6c:	0020      	movs	r0, r4
    1c6e:	4b09      	ldr	r3, [pc, #36]	; (1c94 <prvProcessReceivedCommands+0xc0>)
    1c70:	4798      	blx	r3
					break;
    1c72:	e7b1      	b.n	1bd8 <prvProcessReceivedCommands+0x4>
}
    1c74:	b007      	add	sp, #28
    1c76:	bd30      	pop	{r4, r5, pc}
    1c78:	2000440c 	.word	0x2000440c
    1c7c:	00000e5d 	.word	0x00000e5d
    1c80:	00000375 	.word	0x00000375
    1c84:	00001ac1 	.word	0x00001ac1
    1c88:	000020a4 	.word	0x000020a4
    1c8c:	000018ed 	.word	0x000018ed
    1c90:	000019e1 	.word	0x000019e1
    1c94:	000002c9 	.word	0x000002c9

00001c98 <prvTimerTask>:
{
    1c98:	b500      	push	{lr}
    1c9a:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    1c9c:	a801      	add	r0, sp, #4
    1c9e:	4b04      	ldr	r3, [pc, #16]	; (1cb0 <prvTimerTask+0x18>)
    1ca0:	4798      	blx	r3
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    1ca2:	9901      	ldr	r1, [sp, #4]
    1ca4:	4b03      	ldr	r3, [pc, #12]	; (1cb4 <prvTimerTask+0x1c>)
    1ca6:	4798      	blx	r3
		prvProcessReceivedCommands();
    1ca8:	4b03      	ldr	r3, [pc, #12]	; (1cb8 <prvTimerTask+0x20>)
    1caa:	4798      	blx	r3
    1cac:	e7f6      	b.n	1c9c <prvTimerTask+0x4>
    1cae:	46c0      	nop			; (mov r8, r8)
    1cb0:	000018cd 	.word	0x000018cd
    1cb4:	00001b55 	.word	0x00001b55
    1cb8:	00001bd5 	.word	0x00001bd5

00001cbc <initUART>:
/* Replace with your library code */
void initUART(void) {

	/* APBCMASK */
   /* SERCOM 0 enable*/
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0;
    1cbc:	4a1f      	ldr	r2, [pc, #124]	; (1d3c <initUART+0x80>)
    1cbe:	6a13      	ldr	r3, [r2, #32]
    1cc0:	2104      	movs	r1, #4
    1cc2:	430b      	orrs	r3, r1
    1cc4:	6213      	str	r3, [r2, #32]

	/*GCLK configuration for sercom0 module: using generic clock generator 0, ID for sercom0, enable GCLK*/
    GCLK->GENCTRL.reg=GCLK_GENCTRL_SRC_OSC8M|GCLK_GENCTRL_ID(0)|
    1cc6:	4b1e      	ldr	r3, [pc, #120]	; (1d40 <initUART+0x84>)
    1cc8:	2283      	movs	r2, #131	; 0x83
    1cca:	0252      	lsls	r2, r2, #9
    1ccc:	605a      	str	r2, [r3, #4]
	GCLK_GENCTRL_GENEN;

	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE) |
    1cce:	4a1d      	ldr	r2, [pc, #116]	; (1d44 <initUART+0x88>)
    1cd0:	805a      	strh	r2, [r3, #2]
	GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);

  /*CONFIGURAR PA10 y PA11 como salidas tipo C (SERCOM 0) */
  PORT->Group[0].PINCFG[PIN_PA10].reg= PA10_TX;
    1cd2:	4b1d      	ldr	r3, [pc, #116]	; (1d48 <initUART+0x8c>)
    1cd4:	3903      	subs	r1, #3
    1cd6:	224a      	movs	r2, #74	; 0x4a
    1cd8:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PINCFG[PIN_PA11].reg= PA11_RX;
    1cda:	3106      	adds	r1, #6
    1cdc:	3201      	adds	r2, #1
    1cde:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PMUX[5].bit.PMUXE=Type_C;
    1ce0:	312e      	adds	r1, #46	; 0x2e
    1ce2:	5c5a      	ldrb	r2, [r3, r1]
    1ce4:	200f      	movs	r0, #15
    1ce6:	4382      	bics	r2, r0
    1ce8:	2002      	movs	r0, #2
    1cea:	4302      	orrs	r2, r0
    1cec:	545a      	strb	r2, [r3, r1]
  PORT->Group[0].PMUX[5].bit.PMUXO=Type_C;
    1cee:	5c58      	ldrb	r0, [r3, r1]
    1cf0:	220f      	movs	r2, #15
    1cf2:	4002      	ands	r2, r0
    1cf4:	2020      	movs	r0, #32
    1cf6:	4302      	orrs	r2, r0
    1cf8:	545a      	strb	r2, [r3, r1]
	
	//desahibilitar UART para inicializacion
	SERCOM0->USART.CTRLA.bit.ENABLE=0;
    1cfa:	4b14      	ldr	r3, [pc, #80]	; (1d4c <initUART+0x90>)
    1cfc:	6819      	ldr	r1, [r3, #0]
    1cfe:	2202      	movs	r2, #2
    1d00:	4391      	bics	r1, r2
    1d02:	6019      	str	r1, [r3, #0]
   
   DEFINES:
   1)SERCOM_USART_CTRLA_DORD (_U(0x1) << SERCOM_USART_CTRLA_DORD_Pos)
   2)SERCOM_USART_CTRLA_MODE_USART_INT_CLK (0x1 << 2)
   3)SERCOM_USART_CTRLA_RXPO(value) (SERCOM_USART_CTRLA_RXPO_Msk & ((value) << SERCOM_USART_CTRLA_RXPO_Pos) */
	SERCOM0->USART.CTRLA.reg =
    1d04:	4a12      	ldr	r2, [pc, #72]	; (1d50 <initUART+0x94>)
    1d06:	601a      	str	r2, [r3, #0]
	SERCOM_USART_CTRLA_DORD | SERCOM_USART_CTRLA_MODE_USART_INT_CLK |
	SERCOM_USART_CTRLA_RXPO(3) | SERCOM_USART_CTRLA_TXPO(1);
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1d08:	4b10      	ldr	r3, [pc, #64]	; (1d4c <initUART+0x90>)
    1d0a:	69db      	ldr	r3, [r3, #28]
    1d0c:	2b00      	cmp	r3, #0
    1d0e:	d1fb      	bne.n	1d08 <initUART+0x4c>
	uint64_t br = (uint64_t)65536 * (8000000 - 16 * 9600) / 8000000;

	SERCOM0->USART.BAUD.reg = (uint16_t)br;
    1d10:	4a10      	ldr	r2, [pc, #64]	; (1d54 <initUART+0x98>)
    1d12:	4b0e      	ldr	r3, [pc, #56]	; (1d4c <initUART+0x90>)
    1d14:	819a      	strh	r2, [r3, #12]
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1d16:	4b0d      	ldr	r3, [pc, #52]	; (1d4c <initUART+0x90>)
    1d18:	69db      	ldr	r3, [r3, #28]
    1d1a:	2b00      	cmp	r3, #0
    1d1c:	d1fb      	bne.n	1d16 <initUART+0x5a>
	SERCOM0->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_CHSIZE(0/*8 bits*/);
    1d1e:	22c0      	movs	r2, #192	; 0xc0
    1d20:	0292      	lsls	r2, r2, #10
    1d22:	4b0a      	ldr	r3, [pc, #40]	; (1d4c <initUART+0x90>)
    1d24:	605a      	str	r2, [r3, #4]
    while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1d26:	4b09      	ldr	r3, [pc, #36]	; (1d4c <initUART+0x90>)
    1d28:	69db      	ldr	r3, [r3, #28]
    1d2a:	2b00      	cmp	r3, #0
    1d2c:	d1fb      	bne.n	1d26 <initUART+0x6a>
	SERCOM0->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    1d2e:	4a07      	ldr	r2, [pc, #28]	; (1d4c <initUART+0x90>)
    1d30:	6813      	ldr	r3, [r2, #0]
    1d32:	2102      	movs	r1, #2
    1d34:	430b      	orrs	r3, r1
    1d36:	6013      	str	r3, [r2, #0]
}
    1d38:	4770      	bx	lr
    1d3a:	46c0      	nop			; (mov r8, r8)
    1d3c:	40000400 	.word	0x40000400
    1d40:	40000c00 	.word	0x40000c00
    1d44:	00004014 	.word	0x00004014
    1d48:	41004400 	.word	0x41004400
    1d4c:	42000800 	.word	0x42000800
    1d50:	40310004 	.word	0x40310004
    1d54:	fffffb15 	.word	0xfffffb15

00001d58 <__libc_init_array>:
    1d58:	b570      	push	{r4, r5, r6, lr}
    1d5a:	4e0d      	ldr	r6, [pc, #52]	; (1d90 <__libc_init_array+0x38>)
    1d5c:	4d0d      	ldr	r5, [pc, #52]	; (1d94 <__libc_init_array+0x3c>)
    1d5e:	2400      	movs	r4, #0
    1d60:	1bad      	subs	r5, r5, r6
    1d62:	10ad      	asrs	r5, r5, #2
    1d64:	d005      	beq.n	1d72 <__libc_init_array+0x1a>
    1d66:	00a3      	lsls	r3, r4, #2
    1d68:	58f3      	ldr	r3, [r6, r3]
    1d6a:	3401      	adds	r4, #1
    1d6c:	4798      	blx	r3
    1d6e:	42a5      	cmp	r5, r4
    1d70:	d1f9      	bne.n	1d66 <__libc_init_array+0xe>
    1d72:	f000 f9b5 	bl	20e0 <_init>
    1d76:	4e08      	ldr	r6, [pc, #32]	; (1d98 <__libc_init_array+0x40>)
    1d78:	4d08      	ldr	r5, [pc, #32]	; (1d9c <__libc_init_array+0x44>)
    1d7a:	2400      	movs	r4, #0
    1d7c:	1bad      	subs	r5, r5, r6
    1d7e:	10ad      	asrs	r5, r5, #2
    1d80:	d005      	beq.n	1d8e <__libc_init_array+0x36>
    1d82:	00a3      	lsls	r3, r4, #2
    1d84:	58f3      	ldr	r3, [r6, r3]
    1d86:	3401      	adds	r4, #1
    1d88:	4798      	blx	r3
    1d8a:	42a5      	cmp	r5, r4
    1d8c:	d1f9      	bne.n	1d82 <__libc_init_array+0x2a>
    1d8e:	bd70      	pop	{r4, r5, r6, pc}
    1d90:	000020ec 	.word	0x000020ec
    1d94:	000020ec 	.word	0x000020ec
    1d98:	000020ec 	.word	0x000020ec
    1d9c:	000020f4 	.word	0x000020f4

00001da0 <memcpy>:
    1da0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1da2:	0005      	movs	r5, r0
    1da4:	2a0f      	cmp	r2, #15
    1da6:	d92f      	bls.n	1e08 <memcpy+0x68>
    1da8:	000b      	movs	r3, r1
    1daa:	4303      	orrs	r3, r0
    1dac:	079b      	lsls	r3, r3, #30
    1dae:	d134      	bne.n	1e1a <memcpy+0x7a>
    1db0:	0016      	movs	r6, r2
    1db2:	000c      	movs	r4, r1
    1db4:	0003      	movs	r3, r0
    1db6:	3e10      	subs	r6, #16
    1db8:	0935      	lsrs	r5, r6, #4
    1dba:	3501      	adds	r5, #1
    1dbc:	012d      	lsls	r5, r5, #4
    1dbe:	1945      	adds	r5, r0, r5
    1dc0:	6827      	ldr	r7, [r4, #0]
    1dc2:	601f      	str	r7, [r3, #0]
    1dc4:	6867      	ldr	r7, [r4, #4]
    1dc6:	605f      	str	r7, [r3, #4]
    1dc8:	68a7      	ldr	r7, [r4, #8]
    1dca:	609f      	str	r7, [r3, #8]
    1dcc:	68e7      	ldr	r7, [r4, #12]
    1dce:	3410      	adds	r4, #16
    1dd0:	60df      	str	r7, [r3, #12]
    1dd2:	3310      	adds	r3, #16
    1dd4:	429d      	cmp	r5, r3
    1dd6:	d1f3      	bne.n	1dc0 <memcpy+0x20>
    1dd8:	230f      	movs	r3, #15
    1dda:	439e      	bics	r6, r3
    1ddc:	3610      	adds	r6, #16
    1dde:	1985      	adds	r5, r0, r6
    1de0:	1989      	adds	r1, r1, r6
    1de2:	4013      	ands	r3, r2
    1de4:	2b03      	cmp	r3, #3
    1de6:	d91a      	bls.n	1e1e <memcpy+0x7e>
    1de8:	1f1e      	subs	r6, r3, #4
    1dea:	2300      	movs	r3, #0
    1dec:	08b4      	lsrs	r4, r6, #2
    1dee:	3401      	adds	r4, #1
    1df0:	00a4      	lsls	r4, r4, #2
    1df2:	58cf      	ldr	r7, [r1, r3]
    1df4:	50ef      	str	r7, [r5, r3]
    1df6:	3304      	adds	r3, #4
    1df8:	42a3      	cmp	r3, r4
    1dfa:	d1fa      	bne.n	1df2 <memcpy+0x52>
    1dfc:	2403      	movs	r4, #3
    1dfe:	43a6      	bics	r6, r4
    1e00:	1d33      	adds	r3, r6, #4
    1e02:	4022      	ands	r2, r4
    1e04:	18c9      	adds	r1, r1, r3
    1e06:	18ed      	adds	r5, r5, r3
    1e08:	2a00      	cmp	r2, #0
    1e0a:	d005      	beq.n	1e18 <memcpy+0x78>
    1e0c:	2300      	movs	r3, #0
    1e0e:	5ccc      	ldrb	r4, [r1, r3]
    1e10:	54ec      	strb	r4, [r5, r3]
    1e12:	3301      	adds	r3, #1
    1e14:	4293      	cmp	r3, r2
    1e16:	d1fa      	bne.n	1e0e <memcpy+0x6e>
    1e18:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e1a:	0005      	movs	r5, r0
    1e1c:	e7f6      	b.n	1e0c <memcpy+0x6c>
    1e1e:	001a      	movs	r2, r3
    1e20:	e7f2      	b.n	1e08 <memcpy+0x68>
    1e22:	46c0      	nop			; (mov r8, r8)

00001e24 <memset>:
    1e24:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e26:	0783      	lsls	r3, r0, #30
    1e28:	d043      	beq.n	1eb2 <memset+0x8e>
    1e2a:	1e54      	subs	r4, r2, #1
    1e2c:	2a00      	cmp	r2, #0
    1e2e:	d03f      	beq.n	1eb0 <memset+0x8c>
    1e30:	b2ce      	uxtb	r6, r1
    1e32:	0002      	movs	r2, r0
    1e34:	2503      	movs	r5, #3
    1e36:	e002      	b.n	1e3e <memset+0x1a>
    1e38:	001a      	movs	r2, r3
    1e3a:	3c01      	subs	r4, #1
    1e3c:	d338      	bcc.n	1eb0 <memset+0x8c>
    1e3e:	1c53      	adds	r3, r2, #1
    1e40:	7016      	strb	r6, [r2, #0]
    1e42:	422b      	tst	r3, r5
    1e44:	d1f8      	bne.n	1e38 <memset+0x14>
    1e46:	2c03      	cmp	r4, #3
    1e48:	d92a      	bls.n	1ea0 <memset+0x7c>
    1e4a:	22ff      	movs	r2, #255	; 0xff
    1e4c:	400a      	ands	r2, r1
    1e4e:	0215      	lsls	r5, r2, #8
    1e50:	4315      	orrs	r5, r2
    1e52:	042a      	lsls	r2, r5, #16
    1e54:	4315      	orrs	r5, r2
    1e56:	2c0f      	cmp	r4, #15
    1e58:	d914      	bls.n	1e84 <memset+0x60>
    1e5a:	0027      	movs	r7, r4
    1e5c:	001a      	movs	r2, r3
    1e5e:	3f10      	subs	r7, #16
    1e60:	093e      	lsrs	r6, r7, #4
    1e62:	3601      	adds	r6, #1
    1e64:	0136      	lsls	r6, r6, #4
    1e66:	199e      	adds	r6, r3, r6
    1e68:	6015      	str	r5, [r2, #0]
    1e6a:	6055      	str	r5, [r2, #4]
    1e6c:	6095      	str	r5, [r2, #8]
    1e6e:	60d5      	str	r5, [r2, #12]
    1e70:	3210      	adds	r2, #16
    1e72:	4296      	cmp	r6, r2
    1e74:	d1f8      	bne.n	1e68 <memset+0x44>
    1e76:	220f      	movs	r2, #15
    1e78:	4397      	bics	r7, r2
    1e7a:	3710      	adds	r7, #16
    1e7c:	19db      	adds	r3, r3, r7
    1e7e:	4014      	ands	r4, r2
    1e80:	2c03      	cmp	r4, #3
    1e82:	d90d      	bls.n	1ea0 <memset+0x7c>
    1e84:	001a      	movs	r2, r3
    1e86:	1f27      	subs	r7, r4, #4
    1e88:	08be      	lsrs	r6, r7, #2
    1e8a:	3601      	adds	r6, #1
    1e8c:	00b6      	lsls	r6, r6, #2
    1e8e:	199e      	adds	r6, r3, r6
    1e90:	c220      	stmia	r2!, {r5}
    1e92:	42b2      	cmp	r2, r6
    1e94:	d1fc      	bne.n	1e90 <memset+0x6c>
    1e96:	2203      	movs	r2, #3
    1e98:	4397      	bics	r7, r2
    1e9a:	3704      	adds	r7, #4
    1e9c:	19db      	adds	r3, r3, r7
    1e9e:	4014      	ands	r4, r2
    1ea0:	2c00      	cmp	r4, #0
    1ea2:	d005      	beq.n	1eb0 <memset+0x8c>
    1ea4:	b2c9      	uxtb	r1, r1
    1ea6:	191c      	adds	r4, r3, r4
    1ea8:	7019      	strb	r1, [r3, #0]
    1eaa:	3301      	adds	r3, #1
    1eac:	429c      	cmp	r4, r3
    1eae:	d1fb      	bne.n	1ea8 <memset+0x84>
    1eb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1eb2:	0014      	movs	r4, r2
    1eb4:	0003      	movs	r3, r0
    1eb6:	e7c6      	b.n	1e46 <memset+0x22>

00001eb8 <register_fini>:
    1eb8:	4b03      	ldr	r3, [pc, #12]	; (1ec8 <register_fini+0x10>)
    1eba:	b510      	push	{r4, lr}
    1ebc:	2b00      	cmp	r3, #0
    1ebe:	d002      	beq.n	1ec6 <register_fini+0xe>
    1ec0:	4802      	ldr	r0, [pc, #8]	; (1ecc <register_fini+0x14>)
    1ec2:	f000 f805 	bl	1ed0 <atexit>
    1ec6:	bd10      	pop	{r4, pc}
    1ec8:	00000000 	.word	0x00000000
    1ecc:	00001ee1 	.word	0x00001ee1

00001ed0 <atexit>:
    1ed0:	b510      	push	{r4, lr}
    1ed2:	0001      	movs	r1, r0
    1ed4:	2300      	movs	r3, #0
    1ed6:	2200      	movs	r2, #0
    1ed8:	2000      	movs	r0, #0
    1eda:	f000 f81f 	bl	1f1c <__register_exitproc>
    1ede:	bd10      	pop	{r4, pc}

00001ee0 <__libc_fini_array>:
    1ee0:	b570      	push	{r4, r5, r6, lr}
    1ee2:	4b09      	ldr	r3, [pc, #36]	; (1f08 <__libc_fini_array+0x28>)
    1ee4:	4c09      	ldr	r4, [pc, #36]	; (1f0c <__libc_fini_array+0x2c>)
    1ee6:	1ae4      	subs	r4, r4, r3
    1ee8:	10a4      	asrs	r4, r4, #2
    1eea:	d009      	beq.n	1f00 <__libc_fini_array+0x20>
    1eec:	4a08      	ldr	r2, [pc, #32]	; (1f10 <__libc_fini_array+0x30>)
    1eee:	18a5      	adds	r5, r4, r2
    1ef0:	00ad      	lsls	r5, r5, #2
    1ef2:	18ed      	adds	r5, r5, r3
    1ef4:	682b      	ldr	r3, [r5, #0]
    1ef6:	3c01      	subs	r4, #1
    1ef8:	4798      	blx	r3
    1efa:	3d04      	subs	r5, #4
    1efc:	2c00      	cmp	r4, #0
    1efe:	d1f9      	bne.n	1ef4 <__libc_fini_array+0x14>
    1f00:	f000 f8f8 	bl	20f4 <_fini>
    1f04:	bd70      	pop	{r4, r5, r6, pc}
    1f06:	46c0      	nop			; (mov r8, r8)
    1f08:	00002100 	.word	0x00002100
    1f0c:	00002104 	.word	0x00002104
    1f10:	3fffffff 	.word	0x3fffffff

00001f14 <__retarget_lock_acquire_recursive>:
    1f14:	4770      	bx	lr
    1f16:	46c0      	nop			; (mov r8, r8)

00001f18 <__retarget_lock_release_recursive>:
    1f18:	4770      	bx	lr
    1f1a:	46c0      	nop			; (mov r8, r8)

00001f1c <__register_exitproc>:
    1f1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f1e:	464e      	mov	r6, r9
    1f20:	4645      	mov	r5, r8
    1f22:	46de      	mov	lr, fp
    1f24:	4657      	mov	r7, sl
    1f26:	b5e0      	push	{r5, r6, r7, lr}
    1f28:	4d36      	ldr	r5, [pc, #216]	; (2004 <STACK_SIZE+0x4>)
    1f2a:	b083      	sub	sp, #12
    1f2c:	0006      	movs	r6, r0
    1f2e:	6828      	ldr	r0, [r5, #0]
    1f30:	4698      	mov	r8, r3
    1f32:	000f      	movs	r7, r1
    1f34:	4691      	mov	r9, r2
    1f36:	f7ff ffed 	bl	1f14 <__retarget_lock_acquire_recursive>
    1f3a:	4b33      	ldr	r3, [pc, #204]	; (2008 <STACK_SIZE+0x8>)
    1f3c:	681c      	ldr	r4, [r3, #0]
    1f3e:	23a4      	movs	r3, #164	; 0xa4
    1f40:	005b      	lsls	r3, r3, #1
    1f42:	58e0      	ldr	r0, [r4, r3]
    1f44:	2800      	cmp	r0, #0
    1f46:	d052      	beq.n	1fee <__register_exitproc+0xd2>
    1f48:	6843      	ldr	r3, [r0, #4]
    1f4a:	2b1f      	cmp	r3, #31
    1f4c:	dc13      	bgt.n	1f76 <__register_exitproc+0x5a>
    1f4e:	1c5a      	adds	r2, r3, #1
    1f50:	9201      	str	r2, [sp, #4]
    1f52:	2e00      	cmp	r6, #0
    1f54:	d128      	bne.n	1fa8 <__register_exitproc+0x8c>
    1f56:	9a01      	ldr	r2, [sp, #4]
    1f58:	3302      	adds	r3, #2
    1f5a:	009b      	lsls	r3, r3, #2
    1f5c:	6042      	str	r2, [r0, #4]
    1f5e:	501f      	str	r7, [r3, r0]
    1f60:	6828      	ldr	r0, [r5, #0]
    1f62:	f7ff ffd9 	bl	1f18 <__retarget_lock_release_recursive>
    1f66:	2000      	movs	r0, #0
    1f68:	b003      	add	sp, #12
    1f6a:	bc3c      	pop	{r2, r3, r4, r5}
    1f6c:	4690      	mov	r8, r2
    1f6e:	4699      	mov	r9, r3
    1f70:	46a2      	mov	sl, r4
    1f72:	46ab      	mov	fp, r5
    1f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1f76:	4b25      	ldr	r3, [pc, #148]	; (200c <STACK_SIZE+0xc>)
    1f78:	2b00      	cmp	r3, #0
    1f7a:	d03d      	beq.n	1ff8 <__register_exitproc+0xdc>
    1f7c:	20c8      	movs	r0, #200	; 0xc8
    1f7e:	0040      	lsls	r0, r0, #1
    1f80:	e000      	b.n	1f84 <__register_exitproc+0x68>
    1f82:	bf00      	nop
    1f84:	2800      	cmp	r0, #0
    1f86:	d037      	beq.n	1ff8 <__register_exitproc+0xdc>
    1f88:	22a4      	movs	r2, #164	; 0xa4
    1f8a:	2300      	movs	r3, #0
    1f8c:	0052      	lsls	r2, r2, #1
    1f8e:	58a1      	ldr	r1, [r4, r2]
    1f90:	6043      	str	r3, [r0, #4]
    1f92:	6001      	str	r1, [r0, #0]
    1f94:	50a0      	str	r0, [r4, r2]
    1f96:	3240      	adds	r2, #64	; 0x40
    1f98:	5083      	str	r3, [r0, r2]
    1f9a:	3204      	adds	r2, #4
    1f9c:	5083      	str	r3, [r0, r2]
    1f9e:	3301      	adds	r3, #1
    1fa0:	9301      	str	r3, [sp, #4]
    1fa2:	2300      	movs	r3, #0
    1fa4:	2e00      	cmp	r6, #0
    1fa6:	d0d6      	beq.n	1f56 <__register_exitproc+0x3a>
    1fa8:	009a      	lsls	r2, r3, #2
    1faa:	4692      	mov	sl, r2
    1fac:	4482      	add	sl, r0
    1fae:	464a      	mov	r2, r9
    1fb0:	2188      	movs	r1, #136	; 0x88
    1fb2:	4654      	mov	r4, sl
    1fb4:	5062      	str	r2, [r4, r1]
    1fb6:	22c4      	movs	r2, #196	; 0xc4
    1fb8:	0052      	lsls	r2, r2, #1
    1fba:	4691      	mov	r9, r2
    1fbc:	4481      	add	r9, r0
    1fbe:	464a      	mov	r2, r9
    1fc0:	3987      	subs	r1, #135	; 0x87
    1fc2:	4099      	lsls	r1, r3
    1fc4:	6812      	ldr	r2, [r2, #0]
    1fc6:	468b      	mov	fp, r1
    1fc8:	430a      	orrs	r2, r1
    1fca:	4694      	mov	ip, r2
    1fcc:	464a      	mov	r2, r9
    1fce:	4661      	mov	r1, ip
    1fd0:	6011      	str	r1, [r2, #0]
    1fd2:	2284      	movs	r2, #132	; 0x84
    1fd4:	4641      	mov	r1, r8
    1fd6:	0052      	lsls	r2, r2, #1
    1fd8:	50a1      	str	r1, [r4, r2]
    1fda:	2e02      	cmp	r6, #2
    1fdc:	d1bb      	bne.n	1f56 <__register_exitproc+0x3a>
    1fde:	0002      	movs	r2, r0
    1fe0:	465c      	mov	r4, fp
    1fe2:	328d      	adds	r2, #141	; 0x8d
    1fe4:	32ff      	adds	r2, #255	; 0xff
    1fe6:	6811      	ldr	r1, [r2, #0]
    1fe8:	430c      	orrs	r4, r1
    1fea:	6014      	str	r4, [r2, #0]
    1fec:	e7b3      	b.n	1f56 <__register_exitproc+0x3a>
    1fee:	0020      	movs	r0, r4
    1ff0:	304d      	adds	r0, #77	; 0x4d
    1ff2:	30ff      	adds	r0, #255	; 0xff
    1ff4:	50e0      	str	r0, [r4, r3]
    1ff6:	e7a7      	b.n	1f48 <__register_exitproc+0x2c>
    1ff8:	6828      	ldr	r0, [r5, #0]
    1ffa:	f7ff ff8d 	bl	1f18 <__retarget_lock_release_recursive>
    1ffe:	2001      	movs	r0, #1
    2000:	4240      	negs	r0, r0
    2002:	e7b1      	b.n	1f68 <__register_exitproc+0x4c>
    2004:	20000438 	.word	0x20000438
    2008:	000020dc 	.word	0x000020dc
    200c:	00000000 	.word	0x00000000
    2010:	6e65530a 	.word	0x6e65530a
    2014:	64252064 	.word	0x64252064
    2018:	206f7420 	.word	0x206f7420
    201c:	65636572 	.word	0x65636572
    2020:	72657669 	.word	0x72657669
    2024:	73617420 	.word	0x73617420
    2028:	00000a6b 	.word	0x00000a6b
    202c:	6961460a 	.word	0x6961460a
    2030:	2064656c 	.word	0x2064656c
    2034:	73206f74 	.word	0x73206f74
    2038:	20646e65 	.word	0x20646e65
    203c:	74206f74 	.word	0x74206f74
    2040:	51206568 	.word	0x51206568
    2044:	65756575 	.word	0x65756575
    2048:	00000a20 	.word	0x00000a20
    204c:	6365520a 	.word	0x6365520a
    2050:	65766965 	.word	0x65766965
    2054:	64252064 	.word	0x64252064
    2058:	0000000a 	.word	0x0000000a
    205c:	6961460a 	.word	0x6961460a
    2060:	2064656c 	.word	0x2064656c
    2064:	72206f74 	.word	0x72206f74
    2068:	69656365 	.word	0x69656365
    206c:	64206576 	.word	0x64206576
    2070:	20617461 	.word	0x20617461
    2074:	6d6f7266 	.word	0x6d6f7266
    2078:	65687420 	.word	0x65687420
    207c:	65755120 	.word	0x65755120
    2080:	000a6575 	.word	0x000a6575
    2084:	00007874 	.word	0x00007874
    2088:	00007872 	.word	0x00007872
    208c:	454c4449 	.word	0x454c4449
    2090:	00000000 	.word	0x00000000
    2094:	09632509 	.word	0x09632509
    2098:	25097525 	.word	0x25097525
    209c:	75250975 	.word	0x75250975
    20a0:	00000a0d 	.word	0x00000a0d
    20a4:	00001c10 	.word	0x00001c10
    20a8:	00001c10 	.word	0x00001c10
    20ac:	00001c10 	.word	0x00001c10
    20b0:	00001bd8 	.word	0x00001bd8
    20b4:	00001c52 	.word	0x00001c52
    20b8:	00001c6c 	.word	0x00001c6c
    20bc:	00001c10 	.word	0x00001c10
    20c0:	00001c10 	.word	0x00001c10
    20c4:	00001bd8 	.word	0x00001bd8
    20c8:	00001c52 	.word	0x00001c52
    20cc:	51726d54 	.word	0x51726d54
    20d0:	00000000 	.word	0x00000000
    20d4:	20726d54 	.word	0x20726d54
    20d8:	00637653 	.word	0x00637653

000020dc <_global_impure_ptr>:
    20dc:	20000010                                ... 

000020e0 <_init>:
    20e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20e2:	46c0      	nop			; (mov r8, r8)
    20e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    20e6:	bc08      	pop	{r3}
    20e8:	469e      	mov	lr, r3
    20ea:	4770      	bx	lr

000020ec <__init_array_start>:
    20ec:	00001eb9 	.word	0x00001eb9

000020f0 <__frame_dummy_init_array_entry>:
    20f0:	000000dd                                ....

000020f4 <_fini>:
    20f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20f6:	46c0      	nop			; (mov r8, r8)
    20f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    20fa:	bc08      	pop	{r3}
    20fc:	469e      	mov	lr, r3
    20fe:	4770      	bx	lr

00002100 <__fini_array_start>:
    2100:	000000b5 	.word	0x000000b5
