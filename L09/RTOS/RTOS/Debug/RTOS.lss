
RTOS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002018  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  00002018  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004070  2000043c  00002454  0002043c  2**2
                  ALLOC
  3 .stack        00002004  200044ac  000064c4  0002043c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  6 .debug_info   00012b5a  00000000  00000000  000204bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000019a1  00000000  00000000  00033017  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000674e  00000000  00000000  000349b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000638  00000000  00000000  0003b106  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000798  00000000  00000000  0003b73e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000119c4  00000000  00000000  0003bed6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00005267  00000000  00000000  0004d89a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00079f2b  00000000  00000000  00052b01  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001278  00000000  00000000  000cca2c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	b0 64 00 20 19 01 00 00 15 01 00 00 15 01 00 00     .d. ............
	...
      2c:	15 01 00 00 00 00 00 00 00 00 00 00 e1 07 00 00     ................
      3c:	25 08 00 00 15 01 00 00 15 01 00 00 15 01 00 00     %...............
      4c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      5c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      6c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      7c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      8c:	15 01 00 00 15 01 00 00 00 00 00 00 00 00 00 00     ................
      9c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      ac:	15 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000043c 	.word	0x2000043c
      d4:	00000000 	.word	0x00000000
      d8:	00002018 	.word	0x00002018

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000440 	.word	0x20000440
     108:	00002018 	.word	0x00002018
     10c:	00002018 	.word	0x00002018
     110:	00000000 	.word	0x00000000

00000114 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     114:	e7fe      	b.n	114 <Dummy_Handler>
	...

00000118 <Reset_Handler>:
{
     118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     11a:	4a23      	ldr	r2, [pc, #140]	; (1a8 <Reset_Handler+0x90>)
     11c:	4b23      	ldr	r3, [pc, #140]	; (1ac <Reset_Handler+0x94>)
     11e:	429a      	cmp	r2, r3
     120:	d009      	beq.n	136 <Reset_Handler+0x1e>
     122:	4b22      	ldr	r3, [pc, #136]	; (1ac <Reset_Handler+0x94>)
     124:	4a20      	ldr	r2, [pc, #128]	; (1a8 <Reset_Handler+0x90>)
     126:	e003      	b.n	130 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     128:	6811      	ldr	r1, [r2, #0]
     12a:	6019      	str	r1, [r3, #0]
     12c:	3304      	adds	r3, #4
     12e:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     130:	491f      	ldr	r1, [pc, #124]	; (1b0 <Reset_Handler+0x98>)
     132:	428b      	cmp	r3, r1
     134:	d3f8      	bcc.n	128 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     136:	4b1f      	ldr	r3, [pc, #124]	; (1b4 <Reset_Handler+0x9c>)
     138:	e002      	b.n	140 <Reset_Handler+0x28>
                *pDest++ = 0;
     13a:	2200      	movs	r2, #0
     13c:	601a      	str	r2, [r3, #0]
     13e:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     140:	4a1d      	ldr	r2, [pc, #116]	; (1b8 <Reset_Handler+0xa0>)
     142:	4293      	cmp	r3, r2
     144:	d3f9      	bcc.n	13a <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     146:	4a1d      	ldr	r2, [pc, #116]	; (1bc <Reset_Handler+0xa4>)
     148:	21ff      	movs	r1, #255	; 0xff
     14a:	4b1d      	ldr	r3, [pc, #116]	; (1c0 <Reset_Handler+0xa8>)
     14c:	438b      	bics	r3, r1
     14e:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     150:	39fd      	subs	r1, #253	; 0xfd
     152:	2390      	movs	r3, #144	; 0x90
     154:	005b      	lsls	r3, r3, #1
     156:	4a1b      	ldr	r2, [pc, #108]	; (1c4 <Reset_Handler+0xac>)
     158:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     15a:	4a1b      	ldr	r2, [pc, #108]	; (1c8 <Reset_Handler+0xb0>)
     15c:	78d3      	ldrb	r3, [r2, #3]
     15e:	2503      	movs	r5, #3
     160:	43ab      	bics	r3, r5
     162:	2402      	movs	r4, #2
     164:	4323      	orrs	r3, r4
     166:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     168:	78d3      	ldrb	r3, [r2, #3]
     16a:	270c      	movs	r7, #12
     16c:	43bb      	bics	r3, r7
     16e:	2608      	movs	r6, #8
     170:	4333      	orrs	r3, r6
     172:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     174:	4b15      	ldr	r3, [pc, #84]	; (1cc <Reset_Handler+0xb4>)
     176:	7b98      	ldrb	r0, [r3, #14]
     178:	2230      	movs	r2, #48	; 0x30
     17a:	4390      	bics	r0, r2
     17c:	2220      	movs	r2, #32
     17e:	4310      	orrs	r0, r2
     180:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     182:	7b99      	ldrb	r1, [r3, #14]
     184:	43b9      	bics	r1, r7
     186:	4331      	orrs	r1, r6
     188:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     18a:	7b9a      	ldrb	r2, [r3, #14]
     18c:	43aa      	bics	r2, r5
     18e:	4322      	orrs	r2, r4
     190:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     192:	4a0f      	ldr	r2, [pc, #60]	; (1d0 <Reset_Handler+0xb8>)
     194:	6851      	ldr	r1, [r2, #4]
     196:	2380      	movs	r3, #128	; 0x80
     198:	430b      	orrs	r3, r1
     19a:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     19c:	4b0d      	ldr	r3, [pc, #52]	; (1d4 <Reset_Handler+0xbc>)
     19e:	4798      	blx	r3
        main();
     1a0:	4b0d      	ldr	r3, [pc, #52]	; (1d8 <Reset_Handler+0xc0>)
     1a2:	4798      	blx	r3
     1a4:	e7fe      	b.n	1a4 <Reset_Handler+0x8c>
     1a6:	46c0      	nop			; (mov r8, r8)
     1a8:	00002018 	.word	0x00002018
     1ac:	20000000 	.word	0x20000000
     1b0:	2000043c 	.word	0x2000043c
     1b4:	2000043c 	.word	0x2000043c
     1b8:	200044ac 	.word	0x200044ac
     1bc:	e000ed00 	.word	0xe000ed00
     1c0:	00000000 	.word	0x00000000
     1c4:	41007000 	.word	0x41007000
     1c8:	41005000 	.word	0x41005000
     1cc:	41004800 	.word	0x41004800
     1d0:	41004000 	.word	0x41004000
     1d4:	00001cc9 	.word	0x00001cc9
     1d8:	000003c9 	.word	0x000003c9

000001dc <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
     1dc:	4a01      	ldr	r2, [pc, #4]	; (1e4 <SystemInit+0x8>)
     1de:	4b02      	ldr	r3, [pc, #8]	; (1e8 <SystemInit+0xc>)
     1e0:	601a      	str	r2, [r3, #0]
        return;
}
     1e2:	4770      	bx	lr
     1e4:	000f4240 	.word	0x000f4240
     1e8:	20000000 	.word	0x20000000

000001ec <prvHeapInit>:
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     1ec:	2207      	movs	r2, #7
     1ee:	4b07      	ldr	r3, [pc, #28]	; (20c <prvHeapInit+0x20>)
     1f0:	3308      	adds	r3, #8
     1f2:	4393      	bics	r3, r2

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     1f4:	4a06      	ldr	r2, [pc, #24]	; (210 <prvHeapInit+0x24>)
     1f6:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
     1f8:	2000      	movs	r0, #0
     1fa:	6050      	str	r0, [r2, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     1fc:	4905      	ldr	r1, [pc, #20]	; (214 <prvHeapInit+0x28>)
     1fe:	60d1      	str	r1, [r2, #12]
	xEnd.pxNextFreeBlock = NULL;
     200:	6090      	str	r0, [r2, #8]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     202:	6059      	str	r1, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     204:	3208      	adds	r2, #8
     206:	601a      	str	r2, [r3, #0]
}
     208:	4770      	bx	lr
     20a:	46c0      	nop			; (mov r8, r8)
     20c:	20000458 	.word	0x20000458
     210:	200042d8 	.word	0x200042d8
     214:	00003e78 	.word	0x00003e78

00000218 <pvPortMalloc>:
{
     218:	b570      	push	{r4, r5, r6, lr}
     21a:	0004      	movs	r4, r0
	vTaskSuspendAll();
     21c:	4b24      	ldr	r3, [pc, #144]	; (2b0 <pvPortMalloc+0x98>)
     21e:	4798      	blx	r3
		if( xHeapHasBeenInitialised == pdFALSE )
     220:	4b24      	ldr	r3, [pc, #144]	; (2b4 <pvPortMalloc+0x9c>)
     222:	691b      	ldr	r3, [r3, #16]
     224:	2b00      	cmp	r3, #0
     226:	d00e      	beq.n	246 <pvPortMalloc+0x2e>
		if( xWantedSize > 0 )
     228:	2c00      	cmp	r4, #0
     22a:	d005      	beq.n	238 <pvPortMalloc+0x20>
			xWantedSize += heapSTRUCT_SIZE;
     22c:	3408      	adds	r4, #8
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
     22e:	0763      	lsls	r3, r4, #29
     230:	d002      	beq.n	238 <pvPortMalloc+0x20>
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
     232:	2307      	movs	r3, #7
     234:	439c      	bics	r4, r3
     236:	3408      	adds	r4, #8
		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     238:	1e63      	subs	r3, r4, #1
     23a:	4a1f      	ldr	r2, [pc, #124]	; (2b8 <pvPortMalloc+0xa0>)
     23c:	4293      	cmp	r3, r2
     23e:	d832      	bhi.n	2a6 <pvPortMalloc+0x8e>
			pxBlock = xStart.pxNextFreeBlock;
     240:	491c      	ldr	r1, [pc, #112]	; (2b4 <pvPortMalloc+0x9c>)
     242:	680b      	ldr	r3, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     244:	e007      	b.n	256 <pvPortMalloc+0x3e>
			prvHeapInit();
     246:	4b1d      	ldr	r3, [pc, #116]	; (2bc <pvPortMalloc+0xa4>)
     248:	4798      	blx	r3
			xHeapHasBeenInitialised = pdTRUE;
     24a:	2201      	movs	r2, #1
     24c:	4b19      	ldr	r3, [pc, #100]	; (2b4 <pvPortMalloc+0x9c>)
     24e:	611a      	str	r2, [r3, #16]
     250:	e7ea      	b.n	228 <pvPortMalloc+0x10>
				pxPreviousBlock = pxBlock;
     252:	0019      	movs	r1, r3
				pxBlock = pxBlock->pxNextFreeBlock;
     254:	0013      	movs	r3, r2
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     256:	685a      	ldr	r2, [r3, #4]
     258:	4294      	cmp	r4, r2
     25a:	d902      	bls.n	262 <pvPortMalloc+0x4a>
     25c:	681a      	ldr	r2, [r3, #0]
     25e:	2a00      	cmp	r2, #0
     260:	d1f7      	bne.n	252 <pvPortMalloc+0x3a>
			if( pxBlock != &xEnd )
     262:	4a14      	ldr	r2, [pc, #80]	; (2b4 <pvPortMalloc+0x9c>)
     264:	3208      	adds	r2, #8
     266:	4293      	cmp	r3, r2
     268:	d01f      	beq.n	2aa <pvPortMalloc+0x92>
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     26a:	680d      	ldr	r5, [r1, #0]
     26c:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     26e:	681a      	ldr	r2, [r3, #0]
     270:	600a      	str	r2, [r1, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     272:	685a      	ldr	r2, [r3, #4]
     274:	1b12      	subs	r2, r2, r4
     276:	2a10      	cmp	r2, #16
     278:	d90c      	bls.n	294 <pvPortMalloc+0x7c>
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     27a:	191e      	adds	r6, r3, r4
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     27c:	6072      	str	r2, [r6, #4]
					pxBlock->xBlockSize = xWantedSize;
     27e:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     280:	6870      	ldr	r0, [r6, #4]
     282:	490c      	ldr	r1, [pc, #48]	; (2b4 <pvPortMalloc+0x9c>)
     284:	e000      	b.n	288 <pvPortMalloc+0x70>
     286:	0011      	movs	r1, r2
     288:	680a      	ldr	r2, [r1, #0]
     28a:	6854      	ldr	r4, [r2, #4]
     28c:	42a0      	cmp	r0, r4
     28e:	d8fa      	bhi.n	286 <pvPortMalloc+0x6e>
     290:	6032      	str	r2, [r6, #0]
     292:	600e      	str	r6, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     294:	685b      	ldr	r3, [r3, #4]
     296:	4a0a      	ldr	r2, [pc, #40]	; (2c0 <pvPortMalloc+0xa8>)
     298:	6811      	ldr	r1, [r2, #0]
     29a:	1acb      	subs	r3, r1, r3
     29c:	6013      	str	r3, [r2, #0]
	( void ) xTaskResumeAll();
     29e:	4b09      	ldr	r3, [pc, #36]	; (2c4 <pvPortMalloc+0xac>)
     2a0:	4798      	blx	r3
}
     2a2:	0028      	movs	r0, r5
     2a4:	bd70      	pop	{r4, r5, r6, pc}
void *pvReturn = NULL;
     2a6:	2500      	movs	r5, #0
     2a8:	e7f9      	b.n	29e <pvPortMalloc+0x86>
     2aa:	2500      	movs	r5, #0
     2ac:	e7f7      	b.n	29e <pvPortMalloc+0x86>
     2ae:	46c0      	nop			; (mov r8, r8)
     2b0:	00001349 	.word	0x00001349
     2b4:	200042d8 	.word	0x200042d8
     2b8:	00003e76 	.word	0x00003e76
     2bc:	000001ed 	.word	0x000001ed
     2c0:	20000004 	.word	0x20000004
     2c4:	00001471 	.word	0x00001471

000002c8 <vPortFree>:
{
     2c8:	b570      	push	{r4, r5, r6, lr}
     2ca:	1e04      	subs	r4, r0, #0
	if( pv != NULL )
     2cc:	d016      	beq.n	2fc <vPortFree+0x34>
		puc -= heapSTRUCT_SIZE;
     2ce:	0005      	movs	r5, r0
     2d0:	3d08      	subs	r5, #8
		vTaskSuspendAll();
     2d2:	4b0b      	ldr	r3, [pc, #44]	; (300 <vPortFree+0x38>)
     2d4:	4798      	blx	r3
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     2d6:	6869      	ldr	r1, [r5, #4]
     2d8:	4a0a      	ldr	r2, [pc, #40]	; (304 <vPortFree+0x3c>)
     2da:	e000      	b.n	2de <vPortFree+0x16>
     2dc:	001a      	movs	r2, r3
     2de:	6813      	ldr	r3, [r2, #0]
     2e0:	6858      	ldr	r0, [r3, #4]
     2e2:	4281      	cmp	r1, r0
     2e4:	d8fa      	bhi.n	2dc <vPortFree+0x14>
     2e6:	3c08      	subs	r4, #8
     2e8:	6023      	str	r3, [r4, #0]
     2ea:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
     2ec:	6863      	ldr	r3, [r4, #4]
     2ee:	4a06      	ldr	r2, [pc, #24]	; (308 <vPortFree+0x40>)
     2f0:	6811      	ldr	r1, [r2, #0]
     2f2:	468c      	mov	ip, r1
     2f4:	4463      	add	r3, ip
     2f6:	6013      	str	r3, [r2, #0]
		( void ) xTaskResumeAll();
     2f8:	4b04      	ldr	r3, [pc, #16]	; (30c <vPortFree+0x44>)
     2fa:	4798      	blx	r3
}
     2fc:	bd70      	pop	{r4, r5, r6, pc}
     2fe:	46c0      	nop			; (mov r8, r8)
     300:	00001349 	.word	0x00001349
     304:	200042d8 	.word	0x200042d8
     308:	20000004 	.word	0x20000004
     30c:	00001471 	.word	0x00001471

00000310 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     310:	0003      	movs	r3, r0
     312:	3308      	adds	r3, #8
     314:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     316:	2201      	movs	r2, #1
     318:	4252      	negs	r2, r2
     31a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     31c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     31e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     320:	2300      	movs	r3, #0
     322:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     324:	4770      	bx	lr

00000326 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     326:	2300      	movs	r3, #0
     328:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     32a:	4770      	bx	lr

0000032c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     32c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     32e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     330:	689a      	ldr	r2, [r3, #8]
     332:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     334:	689a      	ldr	r2, [r3, #8]
     336:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     338:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     33a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     33c:	6803      	ldr	r3, [r0, #0]
     33e:	3301      	adds	r3, #1
     340:	6003      	str	r3, [r0, #0]
}
     342:	4770      	bx	lr

00000344 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     344:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     346:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     348:	1c63      	adds	r3, r4, #1
     34a:	d002      	beq.n	352 <vListInsert+0xe>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     34c:	0002      	movs	r2, r0
     34e:	3208      	adds	r2, #8
     350:	e002      	b.n	358 <vListInsert+0x14>
		pxIterator = pxList->xListEnd.pxPrevious;
     352:	6902      	ldr	r2, [r0, #16]
     354:	e004      	b.n	360 <vListInsert+0x1c>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     356:	001a      	movs	r2, r3
     358:	6853      	ldr	r3, [r2, #4]
     35a:	681d      	ldr	r5, [r3, #0]
     35c:	42ac      	cmp	r4, r5
     35e:	d2fa      	bcs.n	356 <vListInsert+0x12>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     360:	6853      	ldr	r3, [r2, #4]
     362:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     364:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
     366:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
     368:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     36a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     36c:	6803      	ldr	r3, [r0, #0]
     36e:	3301      	adds	r3, #1
     370:	6003      	str	r3, [r0, #0]
}
     372:	bd30      	pop	{r4, r5, pc}

00000374 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     374:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     376:	6842      	ldr	r2, [r0, #4]
     378:	6881      	ldr	r1, [r0, #8]
     37a:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     37c:	6882      	ldr	r2, [r0, #8]
     37e:	6841      	ldr	r1, [r0, #4]
     380:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     382:	685a      	ldr	r2, [r3, #4]
     384:	4290      	cmp	r0, r2
     386:	d006      	beq.n	396 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     388:	2200      	movs	r2, #0
     38a:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     38c:	681a      	ldr	r2, [r3, #0]
     38e:	3a01      	subs	r2, #1
     390:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     392:	6818      	ldr	r0, [r3, #0]
}
     394:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     396:	6882      	ldr	r2, [r0, #8]
     398:	605a      	str	r2, [r3, #4]
     39a:	e7f5      	b.n	388 <uxListRemove+0x14>

0000039c <my_task>:
#include "myprintf.h"

/* Priorities at which the tasks are created. */
#define myTASK_TASK_PRIORITY         	( tskIDLE_PRIORITY + 1 )

void my_task(void *p) {
     39c:	b510      	push	{r4, lr}
	static uint32_t i = 0;
	while(1) {
		myprintf("\nHello World task 1 %d", i++);
     39e:	4b06      	ldr	r3, [pc, #24]	; (3b8 <my_task+0x1c>)
     3a0:	6819      	ldr	r1, [r3, #0]
     3a2:	1c4a      	adds	r2, r1, #1
     3a4:	601a      	str	r2, [r3, #0]
     3a6:	4805      	ldr	r0, [pc, #20]	; (3bc <my_task+0x20>)
     3a8:	4b05      	ldr	r3, [pc, #20]	; (3c0 <my_task+0x24>)
     3aa:	4798      	blx	r3
		vTaskDelay(1000);
     3ac:	20fa      	movs	r0, #250	; 0xfa
     3ae:	0080      	lsls	r0, r0, #2
     3b0:	4b04      	ldr	r3, [pc, #16]	; (3c4 <my_task+0x28>)
     3b2:	4798      	blx	r3
     3b4:	e7f3      	b.n	39e <my_task+0x2>
     3b6:	46c0      	nop			; (mov r8, r8)
     3b8:	200042ec 	.word	0x200042ec
     3bc:	00001f80 	.word	0x00001f80
     3c0:	000004d1 	.word	0x000004d1
     3c4:	00001565 	.word	0x00001565

000003c8 <main>:
	}
}

int main()
{
     3c8:	b510      	push	{r4, lr}
     3ca:	b082      	sub	sp, #8
	SystemInit();
     3cc:	4b0b      	ldr	r3, [pc, #44]	; (3fc <main+0x34>)
     3ce:	4798      	blx	r3
	/* Switch to 8MHz clock (disable prescaler) */
	SYSCTRL->OSC8M.bit.PRESC = 0;
     3d0:	4a0b      	ldr	r2, [pc, #44]	; (400 <main+0x38>)
     3d2:	6a11      	ldr	r1, [r2, #32]
     3d4:	4b0b      	ldr	r3, [pc, #44]	; (404 <main+0x3c>)
     3d6:	400b      	ands	r3, r1
     3d8:	6213      	str	r3, [r2, #32]
	initUART();
     3da:	4b0b      	ldr	r3, [pc, #44]	; (408 <main+0x40>)
     3dc:	4798      	blx	r3

	
	xTaskCreate( my_task,        	    /* The function that implements the task. */
     3de:	2300      	movs	r3, #0
     3e0:	9301      	str	r3, [sp, #4]
     3e2:	3301      	adds	r3, #1
     3e4:	9300      	str	r3, [sp, #0]
     3e6:	2300      	movs	r3, #0
     3e8:	2280      	movs	r2, #128	; 0x80
     3ea:	0092      	lsls	r2, r2, #2
     3ec:	4907      	ldr	r1, [pc, #28]	; (40c <main+0x44>)
     3ee:	4808      	ldr	r0, [pc, #32]	; (410 <main+0x48>)
     3f0:	4c08      	ldr	r4, [pc, #32]	; (414 <main+0x4c>)
     3f2:	47a0      	blx	r4
	NULL,           	    /* The parameter passed to the task  */
	myTASK_TASK_PRIORITY,   /* The priority assigned to the task. */
	NULL );         	    /* The task handle is not required, so NULL is passed.                  */

	/* Start the tasks and timer running. */
	vTaskStartScheduler();
     3f4:	4b08      	ldr	r3, [pc, #32]	; (418 <main+0x50>)
     3f6:	4798      	blx	r3
     3f8:	e7fe      	b.n	3f8 <main+0x30>
     3fa:	46c0      	nop			; (mov r8, r8)
     3fc:	000001dd 	.word	0x000001dd
     400:	40000800 	.word	0x40000800
     404:	fffffcff 	.word	0xfffffcff
     408:	00001c2d 	.word	0x00001c2d
     40c:	00001f98 	.word	0x00001f98
     410:	0000039d 	.word	0x0000039d
     414:	00001271 	.word	0x00001271
     418:	000012e1 	.word	0x000012e1

0000041c <sendUART1char>:
static char uc;
static char zs;

static void sendUART1char(char s)
{
  while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     41c:	4b03      	ldr	r3, [pc, #12]	; (42c <sendUART1char+0x10>)
     41e:	7e1b      	ldrb	r3, [r3, #24]
     420:	07db      	lsls	r3, r3, #31
     422:	d5fb      	bpl.n	41c <sendUART1char>
  SERCOM0->USART.DATA.reg = s;
     424:	b280      	uxth	r0, r0
     426:	4b01      	ldr	r3, [pc, #4]	; (42c <sendUART1char+0x10>)
     428:	8518      	strh	r0, [r3, #40]	; 0x28
}
     42a:	4770      	bx	lr
     42c:	42000800 	.word	0x42000800

00000430 <myputchar>:

/* "print.h" uses this function for is's printf implementation */
static void myputchar(char c)
{
     430:	b510      	push	{r4, lr}
     432:	0004      	movs	r4, r0
  if(c=='\n')
     434:	280a      	cmp	r0, #10
     436:	d003      	beq.n	440 <myputchar+0x10>
    sendUART1char('\r');
  sendUART1char(c);
     438:	0020      	movs	r0, r4
     43a:	4b03      	ldr	r3, [pc, #12]	; (448 <myputchar+0x18>)
     43c:	4798      	blx	r3
}
     43e:	bd10      	pop	{r4, pc}
    sendUART1char('\r');
     440:	200d      	movs	r0, #13
     442:	4b01      	ldr	r3, [pc, #4]	; (448 <myputchar+0x18>)
     444:	4798      	blx	r3
     446:	e7f7      	b.n	438 <myputchar+0x8>
     448:	0000041d 	.word	0x0000041d

0000044c <out>:
    //return 0;
//}


static void out(char c) {
    *bf++ = c;
     44c:	4a02      	ldr	r2, [pc, #8]	; (458 <out+0xc>)
     44e:	6813      	ldr	r3, [r2, #0]
     450:	1c59      	adds	r1, r3, #1
     452:	6011      	str	r1, [r2, #0]
     454:	7018      	strb	r0, [r3, #0]
    }
     456:	4770      	bx	lr
     458:	200042f0 	.word	0x200042f0

0000045c <outDgt>:

static void outDgt(char dgt) {
     45c:	b510      	push	{r4, lr}
     45e:	0003      	movs	r3, r0
	out(dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10));
     460:	2809      	cmp	r0, #9
     462:	d907      	bls.n	474 <outDgt+0x18>
     464:	4a08      	ldr	r2, [pc, #32]	; (488 <outDgt+0x2c>)
     466:	7912      	ldrb	r2, [r2, #4]
     468:	2a00      	cmp	r2, #0
     46a:	d101      	bne.n	470 <outDgt+0x14>
     46c:	2057      	movs	r0, #87	; 0x57
     46e:	e002      	b.n	476 <outDgt+0x1a>
     470:	2037      	movs	r0, #55	; 0x37
     472:	e000      	b.n	476 <outDgt+0x1a>
     474:	2030      	movs	r0, #48	; 0x30
     476:	18c0      	adds	r0, r0, r3
     478:	b2c0      	uxtb	r0, r0
     47a:	4b04      	ldr	r3, [pc, #16]	; (48c <outDgt+0x30>)
     47c:	4798      	blx	r3
	zs=1;
     47e:	2201      	movs	r2, #1
     480:	4b01      	ldr	r3, [pc, #4]	; (488 <outDgt+0x2c>)
     482:	715a      	strb	r2, [r3, #5]
    }
     484:	bd10      	pop	{r4, pc}
     486:	46c0      	nop			; (mov r8, r8)
     488:	200042f0 	.word	0x200042f0
     48c:	0000044d 	.word	0x0000044d

00000490 <divOut>:
	
static void divOut(unsigned int div) {
     490:	b510      	push	{r4, lr}
    unsigned char dgt=0;
	num &= 0xffff; // just for testing the code  with 32 bit ints
     492:	4a0d      	ldr	r2, [pc, #52]	; (4c8 <divOut+0x38>)
     494:	6893      	ldr	r3, [r2, #8]
     496:	041b      	lsls	r3, r3, #16
     498:	0c1b      	lsrs	r3, r3, #16
     49a:	6093      	str	r3, [r2, #8]
    unsigned char dgt=0;
     49c:	2200      	movs	r2, #0
	while (num>=div) {
     49e:	e004      	b.n	4aa <divOut+0x1a>
		num -= div;
     4a0:	1a1b      	subs	r3, r3, r0
     4a2:	4909      	ldr	r1, [pc, #36]	; (4c8 <divOut+0x38>)
     4a4:	608b      	str	r3, [r1, #8]
		dgt++;
     4a6:	3201      	adds	r2, #1
     4a8:	b2d2      	uxtb	r2, r2
	while (num>=div) {
     4aa:	4b07      	ldr	r3, [pc, #28]	; (4c8 <divOut+0x38>)
     4ac:	689b      	ldr	r3, [r3, #8]
     4ae:	4283      	cmp	r3, r0
     4b0:	d2f6      	bcs.n	4a0 <divOut+0x10>
		}
	if (zs || dgt>0) 
     4b2:	4b05      	ldr	r3, [pc, #20]	; (4c8 <divOut+0x38>)
     4b4:	795b      	ldrb	r3, [r3, #5]
     4b6:	2b00      	cmp	r3, #0
     4b8:	d101      	bne.n	4be <divOut+0x2e>
     4ba:	2a00      	cmp	r2, #0
     4bc:	d002      	beq.n	4c4 <divOut+0x34>
		outDgt(dgt);
     4be:	0010      	movs	r0, r2
     4c0:	4b02      	ldr	r3, [pc, #8]	; (4cc <divOut+0x3c>)
     4c2:	4798      	blx	r3
    }	
     4c4:	bd10      	pop	{r4, pc}
     4c6:	46c0      	nop			; (mov r8, r8)
     4c8:	200042f0 	.word	0x200042f0
     4cc:	0000045d 	.word	0x0000045d

000004d0 <tfp_printf>:

void tfp_printf(char *fmt, ...)
	{
     4d0:	b40f      	push	{r0, r1, r2, r3}
     4d2:	b5f0      	push	{r4, r5, r6, r7, lr}
     4d4:	46c6      	mov	lr, r8
     4d6:	b500      	push	{lr}
     4d8:	b082      	sub	sp, #8
     4da:	ab08      	add	r3, sp, #32
     4dc:	cb10      	ldmia	r3!, {r4}
	va_list va;
	char ch;
	char* p;
	
	va_start(va,fmt);
     4de:	9301      	str	r3, [sp, #4]
	
	while ((ch=*(fmt++))) {
     4e0:	e0b0      	b.n	644 <tfp_printf+0x174>
			myputchar(ch);
			}
		else {
			char lz=0;
			char w=0;
			ch=*(fmt++);
     4e2:	3402      	adds	r4, #2
     4e4:	7829      	ldrb	r1, [r5, #0]
			if (ch=='0') {
     4e6:	2930      	cmp	r1, #48	; 0x30
     4e8:	d019      	beq.n	51e <tfp_printf+0x4e>
			char lz=0;
     4ea:	2500      	movs	r5, #0
				ch=*(fmt++);
				lz=1;
				}
			if (ch>='0' && ch<='9') {
     4ec:	000b      	movs	r3, r1
     4ee:	3b30      	subs	r3, #48	; 0x30
     4f0:	b2db      	uxtb	r3, r3
     4f2:	2b09      	cmp	r3, #9
     4f4:	d929      	bls.n	54a <tfp_printf+0x7a>
			char w=0;
     4f6:	2600      	movs	r6, #0
				while (ch>='0' && ch<='9') {
					w=(((w<<2)+w)<<1)+ch-'0';
					ch=*fmt++;
					}
				}
			bf=buf;
     4f8:	4b5b      	ldr	r3, [pc, #364]	; (668 <tfp_printf+0x198>)
     4fa:	001a      	movs	r2, r3
     4fc:	320c      	adds	r2, #12
     4fe:	601a      	str	r2, [r3, #0]
			p=bf;
			zs=0;
     500:	2200      	movs	r2, #0
     502:	715a      	strb	r2, [r3, #5]
			switch (ch) {
     504:	2963      	cmp	r1, #99	; 0x63
     506:	d069      	beq.n	5dc <tfp_printf+0x10c>
     508:	d821      	bhi.n	54e <tfp_printf+0x7e>
     50a:	2925      	cmp	r1, #37	; 0x25
     50c:	d074      	beq.n	5f8 <tfp_printf+0x128>
     50e:	2958      	cmp	r1, #88	; 0x58
     510:	d024      	beq.n	55c <tfp_printf+0x8c>
     512:	2900      	cmp	r1, #0
     514:	d100      	bne.n	518 <tfp_printf+0x48>
     516:	e0a0      	b.n	65a <tfp_printf+0x18a>
			p=bf;
     518:	4f53      	ldr	r7, [pc, #332]	; (668 <tfp_printf+0x198>)
     51a:	370c      	adds	r7, #12
     51c:	e050      	b.n	5c0 <tfp_printf+0xf0>
				ch=*(fmt++);
     51e:	1cac      	adds	r4, r5, #2
     520:	7869      	ldrb	r1, [r5, #1]
				lz=1;
     522:	2501      	movs	r5, #1
     524:	e7e2      	b.n	4ec <tfp_printf+0x1c>
					w=(((w<<2)+w)<<1)+ch-'0';
     526:	00b2      	lsls	r2, r6, #2
     528:	b2d2      	uxtb	r2, r2
     52a:	18b2      	adds	r2, r6, r2
     52c:	b2d3      	uxtb	r3, r2
     52e:	005b      	lsls	r3, r3, #1
     530:	b2db      	uxtb	r3, r3
     532:	18cb      	adds	r3, r1, r3
     534:	b2db      	uxtb	r3, r3
     536:	3b30      	subs	r3, #48	; 0x30
     538:	b2de      	uxtb	r6, r3
					ch=*fmt++;
     53a:	7821      	ldrb	r1, [r4, #0]
     53c:	3401      	adds	r4, #1
				while (ch>='0' && ch<='9') {
     53e:	000b      	movs	r3, r1
     540:	3b30      	subs	r3, #48	; 0x30
     542:	b2db      	uxtb	r3, r3
     544:	2b09      	cmp	r3, #9
     546:	d9ee      	bls.n	526 <tfp_printf+0x56>
     548:	e7d6      	b.n	4f8 <tfp_printf+0x28>
     54a:	2600      	movs	r6, #0
     54c:	e7f7      	b.n	53e <tfp_printf+0x6e>
			switch (ch) {
     54e:	2973      	cmp	r1, #115	; 0x73
     550:	d04d      	beq.n	5ee <tfp_printf+0x11e>
     552:	d91c      	bls.n	58e <tfp_printf+0xbe>
     554:	2975      	cmp	r1, #117	; 0x75
     556:	d01c      	beq.n	592 <tfp_printf+0xc2>
     558:	2978      	cmp	r1, #120	; 0x78
     55a:	d1dd      	bne.n	518 <tfp_printf+0x48>
					divOut(10);
					outDgt(num);
					break;
				case 'x': 
				case 'X' : 
				    uc= ch=='X';
     55c:	3958      	subs	r1, #88	; 0x58
     55e:	424b      	negs	r3, r1
     560:	414b      	adcs	r3, r1
     562:	4f41      	ldr	r7, [pc, #260]	; (668 <tfp_printf+0x198>)
     564:	713b      	strb	r3, [r7, #4]
					num=va_arg(va, unsigned int);
     566:	9b01      	ldr	r3, [sp, #4]
     568:	1d1a      	adds	r2, r3, #4
     56a:	9201      	str	r2, [sp, #4]
     56c:	681b      	ldr	r3, [r3, #0]
     56e:	60bb      	str	r3, [r7, #8]
					divOut(0x1000);
     570:	2080      	movs	r0, #128	; 0x80
     572:	0140      	lsls	r0, r0, #5
     574:	4b3d      	ldr	r3, [pc, #244]	; (66c <tfp_printf+0x19c>)
     576:	4698      	mov	r8, r3
     578:	4798      	blx	r3
					divOut(0x100);
     57a:	2080      	movs	r0, #128	; 0x80
     57c:	0040      	lsls	r0, r0, #1
     57e:	47c0      	blx	r8
					divOut(0x10);
     580:	2010      	movs	r0, #16
     582:	47c0      	blx	r8
					outDgt(num);
     584:	7a38      	ldrb	r0, [r7, #8]
     586:	4b3a      	ldr	r3, [pc, #232]	; (670 <tfp_printf+0x1a0>)
     588:	4798      	blx	r3
			p=bf;
     58a:	370c      	adds	r7, #12
					break;
     58c:	e018      	b.n	5c0 <tfp_printf+0xf0>
			switch (ch) {
     58e:	2964      	cmp	r1, #100	; 0x64
     590:	d1c2      	bne.n	518 <tfp_printf+0x48>
					num=va_arg(va, unsigned int);
     592:	9b01      	ldr	r3, [sp, #4]
     594:	1d1a      	adds	r2, r3, #4
     596:	9201      	str	r2, [sp, #4]
     598:	681b      	ldr	r3, [r3, #0]
     59a:	4a33      	ldr	r2, [pc, #204]	; (668 <tfp_printf+0x198>)
     59c:	6093      	str	r3, [r2, #8]
					if (ch=='d' && (int)num<0) {
     59e:	2964      	cmp	r1, #100	; 0x64
     5a0:	d014      	beq.n	5cc <tfp_printf+0xfc>
					divOut(10000);
     5a2:	4834      	ldr	r0, [pc, #208]	; (674 <tfp_printf+0x1a4>)
     5a4:	4f31      	ldr	r7, [pc, #196]	; (66c <tfp_printf+0x19c>)
     5a6:	47b8      	blx	r7
					divOut(1000);
     5a8:	20fa      	movs	r0, #250	; 0xfa
     5aa:	0080      	lsls	r0, r0, #2
     5ac:	47b8      	blx	r7
					divOut(100);
     5ae:	2064      	movs	r0, #100	; 0x64
     5b0:	47b8      	blx	r7
					divOut(10);
     5b2:	200a      	movs	r0, #10
     5b4:	47b8      	blx	r7
					outDgt(num);
     5b6:	4f2c      	ldr	r7, [pc, #176]	; (668 <tfp_printf+0x198>)
     5b8:	7a38      	ldrb	r0, [r7, #8]
     5ba:	4b2d      	ldr	r3, [pc, #180]	; (670 <tfp_printf+0x1a0>)
     5bc:	4798      	blx	r3
			p=bf;
     5be:	370c      	adds	r7, #12
				case '%' :
					out('%');
				default:
					break;
				}
			*bf=0;
     5c0:	4b29      	ldr	r3, [pc, #164]	; (668 <tfp_printf+0x198>)
     5c2:	2200      	movs	r2, #0
     5c4:	6819      	ldr	r1, [r3, #0]
     5c6:	700a      	strb	r2, [r1, #0]
			bf=p;
     5c8:	601f      	str	r7, [r3, #0]
			while (*bf++ && w > 0)
     5ca:	e01d      	b.n	608 <tfp_printf+0x138>
					if (ch=='d' && (int)num<0) {
     5cc:	2b00      	cmp	r3, #0
     5ce:	dae8      	bge.n	5a2 <tfp_printf+0xd2>
						num = -(int)num;
     5d0:	425b      	negs	r3, r3
     5d2:	6093      	str	r3, [r2, #8]
						out('-');
     5d4:	202d      	movs	r0, #45	; 0x2d
     5d6:	4b28      	ldr	r3, [pc, #160]	; (678 <tfp_printf+0x1a8>)
     5d8:	4798      	blx	r3
     5da:	e7e2      	b.n	5a2 <tfp_printf+0xd2>
					out((char)(va_arg(va, int)));
     5dc:	9b01      	ldr	r3, [sp, #4]
     5de:	1d1a      	adds	r2, r3, #4
     5e0:	9201      	str	r2, [sp, #4]
     5e2:	7818      	ldrb	r0, [r3, #0]
     5e4:	4b24      	ldr	r3, [pc, #144]	; (678 <tfp_printf+0x1a8>)
     5e6:	4798      	blx	r3
			p=bf;
     5e8:	4f1f      	ldr	r7, [pc, #124]	; (668 <tfp_printf+0x198>)
     5ea:	370c      	adds	r7, #12
					break;
     5ec:	e7e8      	b.n	5c0 <tfp_printf+0xf0>
					p=va_arg(va, char*);
     5ee:	9b01      	ldr	r3, [sp, #4]
     5f0:	1d1a      	adds	r2, r3, #4
     5f2:	9201      	str	r2, [sp, #4]
     5f4:	681f      	ldr	r7, [r3, #0]
					break;
     5f6:	e7e3      	b.n	5c0 <tfp_printf+0xf0>
					out('%');
     5f8:	2025      	movs	r0, #37	; 0x25
     5fa:	4b1f      	ldr	r3, [pc, #124]	; (678 <tfp_printf+0x1a8>)
     5fc:	4798      	blx	r3
			p=bf;
     5fe:	4f1a      	ldr	r7, [pc, #104]	; (668 <tfp_printf+0x198>)
     600:	370c      	adds	r7, #12
     602:	e7dd      	b.n	5c0 <tfp_printf+0xf0>
				w--;
     604:	3e01      	subs	r6, #1
     606:	b2f6      	uxtb	r6, r6
			while (*bf++ && w > 0)
     608:	4a17      	ldr	r2, [pc, #92]	; (668 <tfp_printf+0x198>)
     60a:	6813      	ldr	r3, [r2, #0]
     60c:	1c59      	adds	r1, r3, #1
     60e:	6011      	str	r1, [r2, #0]
     610:	781b      	ldrb	r3, [r3, #0]
     612:	2b00      	cmp	r3, #0
     614:	d006      	beq.n	624 <tfp_printf+0x154>
     616:	2e00      	cmp	r6, #0
     618:	d1f4      	bne.n	604 <tfp_printf+0x134>
     61a:	e003      	b.n	624 <tfp_printf+0x154>
			while (w-- > 0) 
				myputchar(lz ? '0' : ' ');
     61c:	2020      	movs	r0, #32
     61e:	4b17      	ldr	r3, [pc, #92]	; (67c <tfp_printf+0x1ac>)
     620:	4798      	blx	r3
			while (w-- > 0) 
     622:	4646      	mov	r6, r8
     624:	1e73      	subs	r3, r6, #1
     626:	b2db      	uxtb	r3, r3
     628:	4698      	mov	r8, r3
     62a:	2e00      	cmp	r6, #0
     62c:	d006      	beq.n	63c <tfp_printf+0x16c>
				myputchar(lz ? '0' : ' ');
     62e:	2d00      	cmp	r5, #0
     630:	d0f4      	beq.n	61c <tfp_printf+0x14c>
     632:	2030      	movs	r0, #48	; 0x30
     634:	e7f3      	b.n	61e <tfp_printf+0x14e>
			while ((ch= *p++))
				myputchar(ch);
     636:	4b11      	ldr	r3, [pc, #68]	; (67c <tfp_printf+0x1ac>)
     638:	4798      	blx	r3
			while ((ch= *p++))
     63a:	002f      	movs	r7, r5
     63c:	1c7d      	adds	r5, r7, #1
     63e:	7838      	ldrb	r0, [r7, #0]
     640:	2800      	cmp	r0, #0
     642:	d1f8      	bne.n	636 <tfp_printf+0x166>
	while ((ch=*(fmt++))) {
     644:	1c65      	adds	r5, r4, #1
     646:	7820      	ldrb	r0, [r4, #0]
     648:	2800      	cmp	r0, #0
     64a:	d006      	beq.n	65a <tfp_printf+0x18a>
		if (ch!='%') {
     64c:	2825      	cmp	r0, #37	; 0x25
     64e:	d100      	bne.n	652 <tfp_printf+0x182>
     650:	e747      	b.n	4e2 <tfp_printf+0x12>
			myputchar(ch);
     652:	4b0a      	ldr	r3, [pc, #40]	; (67c <tfp_printf+0x1ac>)
     654:	4798      	blx	r3
	while ((ch=*(fmt++))) {
     656:	002c      	movs	r4, r5
     658:	e7f4      	b.n	644 <tfp_printf+0x174>
			}
		}
	abort:;
	va_end(va);
	}
     65a:	b002      	add	sp, #8
     65c:	bc04      	pop	{r2}
     65e:	4690      	mov	r8, r2
     660:	bcf0      	pop	{r4, r5, r6, r7}
     662:	bc08      	pop	{r3}
     664:	b004      	add	sp, #16
     666:	4718      	bx	r3
     668:	200042f0 	.word	0x200042f0
     66c:	00000491 	.word	0x00000491
     670:	0000045d 	.word	0x0000045d
     674:	00002710 	.word	0x00002710
     678:	0000044d 	.word	0x0000044d
     67c:	00000431 	.word	0x00000431

00000680 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
     680:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
     682:	2300      	movs	r3, #0
     684:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
     686:	4b06      	ldr	r3, [pc, #24]	; (6a0 <prvTaskExitError+0x20>)
     688:	681b      	ldr	r3, [r3, #0]
     68a:	3301      	adds	r3, #1
     68c:	d001      	beq.n	692 <prvTaskExitError+0x12>
     68e:	b672      	cpsid	i
     690:	e7fe      	b.n	690 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     692:	b672      	cpsid	i
	while( ulDummy == 0 )
     694:	9b01      	ldr	r3, [sp, #4]
     696:	2b00      	cmp	r3, #0
     698:	d0fc      	beq.n	694 <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     69a:	b002      	add	sp, #8
     69c:	4770      	bx	lr
     69e:	46c0      	nop			; (mov r8, r8)
     6a0:	20000008 	.word	0x20000008
	...

000006b0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     6b0:	4a0b      	ldr	r2, [pc, #44]	; (6e0 <pxCurrentTCBConst2>)
     6b2:	6813      	ldr	r3, [r2, #0]
     6b4:	6818      	ldr	r0, [r3, #0]
     6b6:	3020      	adds	r0, #32
     6b8:	f380 8809 	msr	PSP, r0
     6bc:	2002      	movs	r0, #2
     6be:	f380 8814 	msr	CONTROL, r0
     6c2:	f3bf 8f6f 	isb	sy
     6c6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     6c8:	46ae      	mov	lr, r5
     6ca:	bc08      	pop	{r3}
     6cc:	bc04      	pop	{r2}
     6ce:	b662      	cpsie	i
     6d0:	4718      	bx	r3
     6d2:	46c0      	nop			; (mov r8, r8)
     6d4:	46c0      	nop			; (mov r8, r8)
     6d6:	46c0      	nop			; (mov r8, r8)
     6d8:	46c0      	nop			; (mov r8, r8)
     6da:	46c0      	nop			; (mov r8, r8)
     6dc:	46c0      	nop			; (mov r8, r8)
     6de:	46c0      	nop			; (mov r8, r8)

000006e0 <pxCurrentTCBConst2>:
     6e0:	200043e0 	.word	0x200043e0

000006e4 <prvSetupTimerInterrupt>:
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
     6e4:	4b05      	ldr	r3, [pc, #20]	; (6fc <prvSetupTimerInterrupt+0x18>)
     6e6:	2200      	movs	r2, #0
     6e8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     6ea:	4905      	ldr	r1, [pc, #20]	; (700 <prvSetupTimerInterrupt+0x1c>)
     6ec:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
     6ee:	4905      	ldr	r1, [pc, #20]	; (704 <prvSetupTimerInterrupt+0x20>)
     6f0:	4a05      	ldr	r2, [pc, #20]	; (708 <prvSetupTimerInterrupt+0x24>)
     6f2:	6011      	str	r1, [r2, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     6f4:	2207      	movs	r2, #7
     6f6:	601a      	str	r2, [r3, #0]
}
     6f8:	4770      	bx	lr
     6fa:	46c0      	nop			; (mov r8, r8)
     6fc:	e000e010 	.word	0xe000e010
     700:	e000e018 	.word	0xe000e018
     704:	000176ff 	.word	0x000176ff
     708:	e000e014 	.word	0xe000e014

0000070c <pxPortInitialiseStack>:
{
     70c:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
     70e:	1f03      	subs	r3, r0, #4
     710:	2480      	movs	r4, #128	; 0x80
     712:	0464      	lsls	r4, r4, #17
     714:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
     716:	3b04      	subs	r3, #4
     718:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
     71a:	3b04      	subs	r3, #4
     71c:	4902      	ldr	r1, [pc, #8]	; (728 <pxPortInitialiseStack+0x1c>)
     71e:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
     720:	3b14      	subs	r3, #20
     722:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
     724:	3840      	subs	r0, #64	; 0x40
}
     726:	bd10      	pop	{r4, pc}
     728:	00000681 	.word	0x00000681

0000072c <xPortStartScheduler>:
{
     72c:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     72e:	4b0c      	ldr	r3, [pc, #48]	; (760 <xPortStartScheduler+0x34>)
     730:	6819      	ldr	r1, [r3, #0]
     732:	22ff      	movs	r2, #255	; 0xff
     734:	0412      	lsls	r2, r2, #16
     736:	430a      	orrs	r2, r1
     738:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     73a:	6819      	ldr	r1, [r3, #0]
     73c:	22ff      	movs	r2, #255	; 0xff
     73e:	0612      	lsls	r2, r2, #24
     740:	430a      	orrs	r2, r1
     742:	601a      	str	r2, [r3, #0]
	prvSetupTimerInterrupt();
     744:	4b07      	ldr	r3, [pc, #28]	; (764 <xPortStartScheduler+0x38>)
     746:	4798      	blx	r3
	uxCriticalNesting = 0;
     748:	2200      	movs	r2, #0
     74a:	4b07      	ldr	r3, [pc, #28]	; (768 <xPortStartScheduler+0x3c>)
     74c:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
     74e:	4b07      	ldr	r3, [pc, #28]	; (76c <xPortStartScheduler+0x40>)
     750:	4798      	blx	r3
	vTaskSwitchContext();
     752:	4b07      	ldr	r3, [pc, #28]	; (770 <xPortStartScheduler+0x44>)
     754:	4798      	blx	r3
	prvTaskExitError();
     756:	4b07      	ldr	r3, [pc, #28]	; (774 <xPortStartScheduler+0x48>)
     758:	4798      	blx	r3
}
     75a:	2000      	movs	r0, #0
     75c:	bd10      	pop	{r4, pc}
     75e:	46c0      	nop			; (mov r8, r8)
     760:	e000ed20 	.word	0xe000ed20
     764:	000006e5 	.word	0x000006e5
     768:	20000008 	.word	0x20000008
     76c:	000006b1 	.word	0x000006b1
     770:	000015a9 	.word	0x000015a9
     774:	00000681 	.word	0x00000681

00000778 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
     778:	2280      	movs	r2, #128	; 0x80
     77a:	0552      	lsls	r2, r2, #21
     77c:	4b03      	ldr	r3, [pc, #12]	; (78c <vPortYield+0x14>)
     77e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
     780:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     784:	f3bf 8f6f 	isb	sy
}
     788:	4770      	bx	lr
     78a:	46c0      	nop			; (mov r8, r8)
     78c:	e000ed04 	.word	0xe000ed04

00000790 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
     790:	b672      	cpsid	i
    uxCriticalNesting++;
     792:	4a04      	ldr	r2, [pc, #16]	; (7a4 <vPortEnterCritical+0x14>)
     794:	6813      	ldr	r3, [r2, #0]
     796:	3301      	adds	r3, #1
     798:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
     79a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     79e:	f3bf 8f6f 	isb	sy
}
     7a2:	4770      	bx	lr
     7a4:	20000008 	.word	0x20000008

000007a8 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
     7a8:	4b06      	ldr	r3, [pc, #24]	; (7c4 <vPortExitCritical+0x1c>)
     7aa:	681b      	ldr	r3, [r3, #0]
     7ac:	2b00      	cmp	r3, #0
     7ae:	d101      	bne.n	7b4 <vPortExitCritical+0xc>
     7b0:	b672      	cpsid	i
     7b2:	e7fe      	b.n	7b2 <vPortExitCritical+0xa>
    uxCriticalNesting--;
     7b4:	3b01      	subs	r3, #1
     7b6:	4a03      	ldr	r2, [pc, #12]	; (7c4 <vPortExitCritical+0x1c>)
     7b8:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
     7ba:	2b00      	cmp	r3, #0
     7bc:	d100      	bne.n	7c0 <vPortExitCritical+0x18>
        portENABLE_INTERRUPTS();
     7be:	b662      	cpsie	i
}
     7c0:	4770      	bx	lr
     7c2:	46c0      	nop			; (mov r8, r8)
     7c4:	20000008 	.word	0x20000008

000007c8 <ulSetInterruptMaskFromISR>:
	__asm volatile(
     7c8:	f3ef 8010 	mrs	r0, PRIMASK
     7cc:	b672      	cpsid	i
     7ce:	4770      	bx	lr

000007d0 <vClearInterruptMaskFromISR>:
	__asm volatile(
     7d0:	f380 8810 	msr	PRIMASK, r0
     7d4:	4770      	bx	lr
	...

000007e0 <PendSV_Handler>:
	__asm volatile
     7e0:	f3ef 8009 	mrs	r0, PSP
     7e4:	4b0e      	ldr	r3, [pc, #56]	; (820 <pxCurrentTCBConst>)
     7e6:	681a      	ldr	r2, [r3, #0]
     7e8:	3820      	subs	r0, #32
     7ea:	6010      	str	r0, [r2, #0]
     7ec:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     7ee:	4644      	mov	r4, r8
     7f0:	464d      	mov	r5, r9
     7f2:	4656      	mov	r6, sl
     7f4:	465f      	mov	r7, fp
     7f6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     7f8:	b508      	push	{r3, lr}
     7fa:	b672      	cpsid	i
     7fc:	f000 fed4 	bl	15a8 <vTaskSwitchContext>
     800:	b662      	cpsie	i
     802:	bc0c      	pop	{r2, r3}
     804:	6811      	ldr	r1, [r2, #0]
     806:	6808      	ldr	r0, [r1, #0]
     808:	3010      	adds	r0, #16
     80a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     80c:	46a0      	mov	r8, r4
     80e:	46a9      	mov	r9, r5
     810:	46b2      	mov	sl, r6
     812:	46bb      	mov	fp, r7
     814:	f380 8809 	msr	PSP, r0
     818:	3820      	subs	r0, #32
     81a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     81c:	4718      	bx	r3
     81e:	46c0      	nop			; (mov r8, r8)

00000820 <pxCurrentTCBConst>:
     820:	200043e0 	.word	0x200043e0

00000824 <SysTick_Handler>:
{
     824:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     826:	4b07      	ldr	r3, [pc, #28]	; (844 <SysTick_Handler+0x20>)
     828:	4798      	blx	r3
     82a:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
     82c:	4b06      	ldr	r3, [pc, #24]	; (848 <SysTick_Handler+0x24>)
     82e:	4798      	blx	r3
     830:	2800      	cmp	r0, #0
     832:	d003      	beq.n	83c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     834:	2280      	movs	r2, #128	; 0x80
     836:	0552      	lsls	r2, r2, #21
     838:	4b04      	ldr	r3, [pc, #16]	; (84c <SysTick_Handler+0x28>)
     83a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     83c:	0020      	movs	r0, r4
     83e:	4b04      	ldr	r3, [pc, #16]	; (850 <SysTick_Handler+0x2c>)
     840:	4798      	blx	r3
}
     842:	bd10      	pop	{r4, pc}
     844:	000007c9 	.word	0x000007c9
     848:	00001365 	.word	0x00001365
     84c:	e000ed04 	.word	0xe000ed04
     850:	000007d1 	.word	0x000007d1

00000854 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
     854:	b510      	push	{r4, lr}
     856:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
     858:	4b06      	ldr	r3, [pc, #24]	; (874 <prvIsQueueFull+0x20>)
     85a:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     85c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     85e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     860:	429a      	cmp	r2, r3
     862:	d004      	beq.n	86e <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
     864:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
     866:	4b04      	ldr	r3, [pc, #16]	; (878 <prvIsQueueFull+0x24>)
     868:	4798      	blx	r3

	return xReturn;
}
     86a:	0020      	movs	r0, r4
     86c:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     86e:	2401      	movs	r4, #1
     870:	e7f9      	b.n	866 <prvIsQueueFull+0x12>
     872:	46c0      	nop			; (mov r8, r8)
     874:	00000791 	.word	0x00000791
     878:	000007a9 	.word	0x000007a9

0000087c <prvIsQueueEmpty>:
{
     87c:	b510      	push	{r4, lr}
     87e:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
     880:	4b05      	ldr	r3, [pc, #20]	; (898 <prvIsQueueEmpty+0x1c>)
     882:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     884:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     886:	2b00      	cmp	r3, #0
     888:	d004      	beq.n	894 <prvIsQueueEmpty+0x18>
			xReturn = pdFALSE;
     88a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
     88c:	4b03      	ldr	r3, [pc, #12]	; (89c <prvIsQueueEmpty+0x20>)
     88e:	4798      	blx	r3
}
     890:	0020      	movs	r0, r4
     892:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     894:	2401      	movs	r4, #1
     896:	e7f9      	b.n	88c <prvIsQueueEmpty+0x10>
     898:	00000791 	.word	0x00000791
     89c:	000007a9 	.word	0x000007a9

000008a0 <prvCopyDataToQueue>:
{
     8a0:	b570      	push	{r4, r5, r6, lr}
     8a2:	0004      	movs	r4, r0
     8a4:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     8a6:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     8a8:	6c02      	ldr	r2, [r0, #64]	; 0x40
     8aa:	2a00      	cmp	r2, #0
     8ac:	d10a      	bne.n	8c4 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     8ae:	6803      	ldr	r3, [r0, #0]
     8b0:	2b00      	cmp	r3, #0
     8b2:	d12e      	bne.n	912 <prvCopyDataToQueue+0x72>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     8b4:	6840      	ldr	r0, [r0, #4]
     8b6:	4b1b      	ldr	r3, [pc, #108]	; (924 <prvCopyDataToQueue+0x84>)
     8b8:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     8ba:	2300      	movs	r3, #0
     8bc:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     8be:	3501      	adds	r5, #1
     8c0:	63a5      	str	r5, [r4, #56]	; 0x38
}
     8c2:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
     8c4:	2e00      	cmp	r6, #0
     8c6:	d10e      	bne.n	8e6 <prvCopyDataToQueue+0x46>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     8c8:	6880      	ldr	r0, [r0, #8]
     8ca:	4b17      	ldr	r3, [pc, #92]	; (928 <prvCopyDataToQueue+0x88>)
     8cc:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     8ce:	68a3      	ldr	r3, [r4, #8]
     8d0:	6c22      	ldr	r2, [r4, #64]	; 0x40
     8d2:	4694      	mov	ip, r2
     8d4:	4463      	add	r3, ip
     8d6:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     8d8:	6862      	ldr	r2, [r4, #4]
     8da:	4293      	cmp	r3, r2
     8dc:	d31b      	bcc.n	916 <prvCopyDataToQueue+0x76>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     8de:	6823      	ldr	r3, [r4, #0]
     8e0:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
     8e2:	2000      	movs	r0, #0
     8e4:	e7eb      	b.n	8be <prvCopyDataToQueue+0x1e>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     8e6:	68c0      	ldr	r0, [r0, #12]
     8e8:	4b0f      	ldr	r3, [pc, #60]	; (928 <prvCopyDataToQueue+0x88>)
     8ea:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     8ec:	6c23      	ldr	r3, [r4, #64]	; 0x40
     8ee:	425b      	negs	r3, r3
     8f0:	68e2      	ldr	r2, [r4, #12]
     8f2:	18d2      	adds	r2, r2, r3
     8f4:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     8f6:	6821      	ldr	r1, [r4, #0]
     8f8:	428a      	cmp	r2, r1
     8fa:	d203      	bcs.n	904 <prvCopyDataToQueue+0x64>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     8fc:	6862      	ldr	r2, [r4, #4]
     8fe:	4694      	mov	ip, r2
     900:	4463      	add	r3, ip
     902:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
     904:	2e02      	cmp	r6, #2
     906:	d108      	bne.n	91a <prvCopyDataToQueue+0x7a>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     908:	2d00      	cmp	r5, #0
     90a:	d008      	beq.n	91e <prvCopyDataToQueue+0x7e>
				--uxMessagesWaiting;
     90c:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
     90e:	2000      	movs	r0, #0
     910:	e7d5      	b.n	8be <prvCopyDataToQueue+0x1e>
     912:	2000      	movs	r0, #0
     914:	e7d3      	b.n	8be <prvCopyDataToQueue+0x1e>
     916:	2000      	movs	r0, #0
     918:	e7d1      	b.n	8be <prvCopyDataToQueue+0x1e>
     91a:	2000      	movs	r0, #0
     91c:	e7cf      	b.n	8be <prvCopyDataToQueue+0x1e>
     91e:	2000      	movs	r0, #0
     920:	e7cd      	b.n	8be <prvCopyDataToQueue+0x1e>
     922:	46c0      	nop			; (mov r8, r8)
     924:	000017c1 	.word	0x000017c1
     928:	00001d11 	.word	0x00001d11

0000092c <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
     92c:	b570      	push	{r4, r5, r6, lr}
     92e:	b082      	sub	sp, #8
     930:	9001      	str	r0, [sp, #4]
     932:	000a      	movs	r2, r1
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     934:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
     936:	2c00      	cmp	r4, #0
     938:	d005      	beq.n	946 <prvNotifyQueueSetContainer+0x1a>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     93a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     93c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     93e:	4299      	cmp	r1, r3
     940:	d303      	bcc.n	94a <prvNotifyQueueSetContainer+0x1e>
     942:	b672      	cpsid	i
     944:	e7fe      	b.n	944 <prvNotifyQueueSetContainer+0x18>
		configASSERT( pxQueueSetContainer );
     946:	b672      	cpsid	i
     948:	e7fe      	b.n	948 <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     94a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     94c:	428b      	cmp	r3, r1
     94e:	d803      	bhi.n	958 <prvNotifyQueueSetContainer+0x2c>
	BaseType_t xReturn = pdFALSE;
     950:	2600      	movs	r6, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     952:	0030      	movs	r0, r6
     954:	b002      	add	sp, #8
     956:	bd70      	pop	{r4, r5, r6, pc}
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     958:	2345      	movs	r3, #69	; 0x45
     95a:	5ce5      	ldrb	r5, [r4, r3]
     95c:	b26d      	sxtb	r5, r5
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     95e:	a901      	add	r1, sp, #4
     960:	0020      	movs	r0, r4
     962:	4b0a      	ldr	r3, [pc, #40]	; (98c <prvNotifyQueueSetContainer+0x60>)
     964:	4798      	blx	r3
     966:	0006      	movs	r6, r0
			if( cTxLock == queueUNLOCKED )
     968:	1c6b      	adds	r3, r5, #1
     96a:	d10a      	bne.n	982 <prvNotifyQueueSetContainer+0x56>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     96c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     96e:	2b00      	cmp	r3, #0
     970:	d0ef      	beq.n	952 <prvNotifyQueueSetContainer+0x26>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     972:	0020      	movs	r0, r4
     974:	3024      	adds	r0, #36	; 0x24
     976:	4b06      	ldr	r3, [pc, #24]	; (990 <prvNotifyQueueSetContainer+0x64>)
     978:	4798      	blx	r3
     97a:	2800      	cmp	r0, #0
     97c:	d0e9      	beq.n	952 <prvNotifyQueueSetContainer+0x26>
						xReturn = pdTRUE;
     97e:	2601      	movs	r6, #1
		return xReturn;
     980:	e7e7      	b.n	952 <prvNotifyQueueSetContainer+0x26>
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
     982:	3501      	adds	r5, #1
     984:	b26d      	sxtb	r5, r5
     986:	2345      	movs	r3, #69	; 0x45
     988:	54e5      	strb	r5, [r4, r3]
     98a:	e7e2      	b.n	952 <prvNotifyQueueSetContainer+0x26>
     98c:	000008a1 	.word	0x000008a1
     990:	00001691 	.word	0x00001691

00000994 <prvCopyDataFromQueue>:
{
     994:	b510      	push	{r4, lr}
     996:	000c      	movs	r4, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     998:	6c02      	ldr	r2, [r0, #64]	; 0x40
     99a:	2a00      	cmp	r2, #0
     99c:	d00b      	beq.n	9b6 <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     99e:	68c3      	ldr	r3, [r0, #12]
     9a0:	189b      	adds	r3, r3, r2
     9a2:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     9a4:	6841      	ldr	r1, [r0, #4]
     9a6:	428b      	cmp	r3, r1
     9a8:	d301      	bcc.n	9ae <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     9aa:	6803      	ldr	r3, [r0, #0]
     9ac:	60c3      	str	r3, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     9ae:	68c1      	ldr	r1, [r0, #12]
     9b0:	0020      	movs	r0, r4
     9b2:	4b01      	ldr	r3, [pc, #4]	; (9b8 <prvCopyDataFromQueue+0x24>)
     9b4:	4798      	blx	r3
}
     9b6:	bd10      	pop	{r4, pc}
     9b8:	00001d11 	.word	0x00001d11

000009bc <prvUnlockQueue>:
{
     9bc:	b570      	push	{r4, r5, r6, lr}
     9be:	0005      	movs	r5, r0
	taskENTER_CRITICAL();
     9c0:	4b21      	ldr	r3, [pc, #132]	; (a48 <prvUnlockQueue+0x8c>)
     9c2:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
     9c4:	2345      	movs	r3, #69	; 0x45
     9c6:	5cec      	ldrb	r4, [r5, r3]
     9c8:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     9ca:	e00a      	b.n	9e2 <prvUnlockQueue+0x26>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     9cc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     9ce:	2b00      	cmp	r3, #0
     9d0:	d018      	beq.n	a04 <prvUnlockQueue+0x48>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     9d2:	0028      	movs	r0, r5
     9d4:	3024      	adds	r0, #36	; 0x24
     9d6:	4b1d      	ldr	r3, [pc, #116]	; (a4c <prvUnlockQueue+0x90>)
     9d8:	4798      	blx	r3
     9da:	2800      	cmp	r0, #0
     9dc:	d10f      	bne.n	9fe <prvUnlockQueue+0x42>
			--cTxLock;
     9de:	3c01      	subs	r4, #1
     9e0:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     9e2:	2c00      	cmp	r4, #0
     9e4:	dd0e      	ble.n	a04 <prvUnlockQueue+0x48>
				if( pxQueue->pxQueueSetContainer != NULL )
     9e6:	6cab      	ldr	r3, [r5, #72]	; 0x48
     9e8:	2b00      	cmp	r3, #0
     9ea:	d0ef      	beq.n	9cc <prvUnlockQueue+0x10>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     9ec:	2100      	movs	r1, #0
     9ee:	0028      	movs	r0, r5
     9f0:	4b17      	ldr	r3, [pc, #92]	; (a50 <prvUnlockQueue+0x94>)
     9f2:	4798      	blx	r3
     9f4:	2800      	cmp	r0, #0
     9f6:	d0f2      	beq.n	9de <prvUnlockQueue+0x22>
						vTaskMissedYield();
     9f8:	4b16      	ldr	r3, [pc, #88]	; (a54 <prvUnlockQueue+0x98>)
     9fa:	4798      	blx	r3
     9fc:	e7ef      	b.n	9de <prvUnlockQueue+0x22>
							vTaskMissedYield();
     9fe:	4b15      	ldr	r3, [pc, #84]	; (a54 <prvUnlockQueue+0x98>)
     a00:	4798      	blx	r3
     a02:	e7ec      	b.n	9de <prvUnlockQueue+0x22>
		pxQueue->cTxLock = queueUNLOCKED;
     a04:	22ff      	movs	r2, #255	; 0xff
     a06:	2345      	movs	r3, #69	; 0x45
     a08:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     a0a:	4b13      	ldr	r3, [pc, #76]	; (a58 <prvUnlockQueue+0x9c>)
     a0c:	4798      	blx	r3
	taskENTER_CRITICAL();
     a0e:	4b0e      	ldr	r3, [pc, #56]	; (a48 <prvUnlockQueue+0x8c>)
     a10:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
     a12:	2344      	movs	r3, #68	; 0x44
     a14:	5cec      	ldrb	r4, [r5, r3]
     a16:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     a18:	e001      	b.n	a1e <prvUnlockQueue+0x62>
				--cRxLock;
     a1a:	3c01      	subs	r4, #1
     a1c:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     a1e:	2c00      	cmp	r4, #0
     a20:	dd0b      	ble.n	a3a <prvUnlockQueue+0x7e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a22:	692b      	ldr	r3, [r5, #16]
     a24:	2b00      	cmp	r3, #0
     a26:	d008      	beq.n	a3a <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     a28:	0028      	movs	r0, r5
     a2a:	3010      	adds	r0, #16
     a2c:	4b07      	ldr	r3, [pc, #28]	; (a4c <prvUnlockQueue+0x90>)
     a2e:	4798      	blx	r3
     a30:	2800      	cmp	r0, #0
     a32:	d0f2      	beq.n	a1a <prvUnlockQueue+0x5e>
					vTaskMissedYield();
     a34:	4b07      	ldr	r3, [pc, #28]	; (a54 <prvUnlockQueue+0x98>)
     a36:	4798      	blx	r3
     a38:	e7ef      	b.n	a1a <prvUnlockQueue+0x5e>
		pxQueue->cRxLock = queueUNLOCKED;
     a3a:	22ff      	movs	r2, #255	; 0xff
     a3c:	2344      	movs	r3, #68	; 0x44
     a3e:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     a40:	4b05      	ldr	r3, [pc, #20]	; (a58 <prvUnlockQueue+0x9c>)
     a42:	4798      	blx	r3
}
     a44:	bd70      	pop	{r4, r5, r6, pc}
     a46:	46c0      	nop			; (mov r8, r8)
     a48:	00000791 	.word	0x00000791
     a4c:	00001691 	.word	0x00001691
     a50:	0000092d 	.word	0x0000092d
     a54:	00001795 	.word	0x00001795
     a58:	000007a9 	.word	0x000007a9

00000a5c <xQueueGenericReset>:
{
     a5c:	b570      	push	{r4, r5, r6, lr}
     a5e:	0004      	movs	r4, r0
     a60:	000d      	movs	r5, r1
	configASSERT( pxQueue );
     a62:	2800      	cmp	r0, #0
     a64:	d023      	beq.n	aae <xQueueGenericReset+0x52>
	taskENTER_CRITICAL();
     a66:	4b18      	ldr	r3, [pc, #96]	; (ac8 <xQueueGenericReset+0x6c>)
     a68:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     a6a:	6822      	ldr	r2, [r4, #0]
     a6c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     a6e:	6c20      	ldr	r0, [r4, #64]	; 0x40
     a70:	0001      	movs	r1, r0
     a72:	4359      	muls	r1, r3
     a74:	1851      	adds	r1, r2, r1
     a76:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     a78:	2100      	movs	r1, #0
     a7a:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
     a7c:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     a7e:	3b01      	subs	r3, #1
     a80:	4343      	muls	r3, r0
     a82:	18d3      	adds	r3, r2, r3
     a84:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
     a86:	23ff      	movs	r3, #255	; 0xff
     a88:	2244      	movs	r2, #68	; 0x44
     a8a:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock = queueUNLOCKED;
     a8c:	3201      	adds	r2, #1
     a8e:	54a3      	strb	r3, [r4, r2]
		if( xNewQueue == pdFALSE )
     a90:	2d00      	cmp	r5, #0
     a92:	d111      	bne.n	ab8 <xQueueGenericReset+0x5c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a94:	6923      	ldr	r3, [r4, #16]
     a96:	2b00      	cmp	r3, #0
     a98:	d005      	beq.n	aa6 <xQueueGenericReset+0x4a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     a9a:	0020      	movs	r0, r4
     a9c:	3010      	adds	r0, #16
     a9e:	4b0b      	ldr	r3, [pc, #44]	; (acc <xQueueGenericReset+0x70>)
     aa0:	4798      	blx	r3
     aa2:	2800      	cmp	r0, #0
     aa4:	d105      	bne.n	ab2 <xQueueGenericReset+0x56>
	taskEXIT_CRITICAL();
     aa6:	4b0a      	ldr	r3, [pc, #40]	; (ad0 <xQueueGenericReset+0x74>)
     aa8:	4798      	blx	r3
}
     aaa:	2001      	movs	r0, #1
     aac:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
     aae:	b672      	cpsid	i
     ab0:	e7fe      	b.n	ab0 <xQueueGenericReset+0x54>
					queueYIELD_IF_USING_PREEMPTION();
     ab2:	4b08      	ldr	r3, [pc, #32]	; (ad4 <xQueueGenericReset+0x78>)
     ab4:	4798      	blx	r3
     ab6:	e7f6      	b.n	aa6 <xQueueGenericReset+0x4a>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     ab8:	0020      	movs	r0, r4
     aba:	3010      	adds	r0, #16
     abc:	4d06      	ldr	r5, [pc, #24]	; (ad8 <xQueueGenericReset+0x7c>)
     abe:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     ac0:	0020      	movs	r0, r4
     ac2:	3024      	adds	r0, #36	; 0x24
     ac4:	47a8      	blx	r5
     ac6:	e7ee      	b.n	aa6 <xQueueGenericReset+0x4a>
     ac8:	00000791 	.word	0x00000791
     acc:	00001691 	.word	0x00001691
     ad0:	000007a9 	.word	0x000007a9
     ad4:	00000779 	.word	0x00000779
     ad8:	00000311 	.word	0x00000311

00000adc <prvInitialiseNewQueue>:
{
     adc:	b570      	push	{r4, r5, r6, lr}
     ade:	001d      	movs	r5, r3
     ae0:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
     ae2:	2900      	cmp	r1, #0
     ae4:	d00b      	beq.n	afe <prvInitialiseNewQueue+0x22>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     ae6:	6022      	str	r2, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
     ae8:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
     aea:	6421      	str	r1, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     aec:	2101      	movs	r1, #1
     aee:	0020      	movs	r0, r4
     af0:	4b04      	ldr	r3, [pc, #16]	; (b04 <prvInitialiseNewQueue+0x28>)
     af2:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
     af4:	2350      	movs	r3, #80	; 0x50
     af6:	54e5      	strb	r5, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
     af8:	2300      	movs	r3, #0
     afa:	64a3      	str	r3, [r4, #72]	; 0x48
}
     afc:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     afe:	6024      	str	r4, [r4, #0]
     b00:	e7f2      	b.n	ae8 <prvInitialiseNewQueue+0xc>
     b02:	46c0      	nop			; (mov r8, r8)
     b04:	00000a5d 	.word	0x00000a5d

00000b08 <xQueueGenericCreate>:
	{
     b08:	b5f0      	push	{r4, r5, r6, r7, lr}
     b0a:	b083      	sub	sp, #12
     b0c:	0006      	movs	r6, r0
     b0e:	000f      	movs	r7, r1
     b10:	0015      	movs	r5, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
     b12:	2800      	cmp	r0, #0
     b14:	d101      	bne.n	b1a <xQueueGenericCreate+0x12>
     b16:	b672      	cpsid	i
     b18:	e7fe      	b.n	b18 <xQueueGenericCreate+0x10>
		if( uxItemSize == ( UBaseType_t ) 0 )
     b1a:	2900      	cmp	r1, #0
     b1c:	d002      	beq.n	b24 <xQueueGenericCreate+0x1c>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b1e:	0008      	movs	r0, r1
     b20:	4370      	muls	r0, r6
     b22:	e000      	b.n	b26 <xQueueGenericCreate+0x1e>
			xQueueSizeInBytes = ( size_t ) 0;
     b24:	2000      	movs	r0, #0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     b26:	3054      	adds	r0, #84	; 0x54
     b28:	4b07      	ldr	r3, [pc, #28]	; (b48 <xQueueGenericCreate+0x40>)
     b2a:	4798      	blx	r3
     b2c:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
     b2e:	d007      	beq.n	b40 <xQueueGenericCreate+0x38>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
     b30:	0002      	movs	r2, r0
     b32:	3254      	adds	r2, #84	; 0x54
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     b34:	9000      	str	r0, [sp, #0]
     b36:	002b      	movs	r3, r5
     b38:	0039      	movs	r1, r7
     b3a:	0030      	movs	r0, r6
     b3c:	4d03      	ldr	r5, [pc, #12]	; (b4c <xQueueGenericCreate+0x44>)
     b3e:	47a8      	blx	r5
	}
     b40:	0020      	movs	r0, r4
     b42:	b003      	add	sp, #12
     b44:	bdf0      	pop	{r4, r5, r6, r7, pc}
     b46:	46c0      	nop			; (mov r8, r8)
     b48:	00000219 	.word	0x00000219
     b4c:	00000add 	.word	0x00000add

00000b50 <xQueueGenericSend>:
{
     b50:	b5f0      	push	{r4, r5, r6, r7, lr}
     b52:	b085      	sub	sp, #20
     b54:	0004      	movs	r4, r0
     b56:	000f      	movs	r7, r1
     b58:	9201      	str	r2, [sp, #4]
     b5a:	001e      	movs	r6, r3
	configASSERT( pxQueue );
     b5c:	2800      	cmp	r0, #0
     b5e:	d006      	beq.n	b6e <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     b60:	2900      	cmp	r1, #0
     b62:	d006      	beq.n	b72 <xQueueGenericSend+0x22>
     b64:	2501      	movs	r5, #1
     b66:	2d00      	cmp	r5, #0
     b68:	d10a      	bne.n	b80 <xQueueGenericSend+0x30>
     b6a:	b672      	cpsid	i
     b6c:	e7fe      	b.n	b6c <xQueueGenericSend+0x1c>
	configASSERT( pxQueue );
     b6e:	b672      	cpsid	i
     b70:	e7fe      	b.n	b70 <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     b72:	6c03      	ldr	r3, [r0, #64]	; 0x40
     b74:	2b00      	cmp	r3, #0
     b76:	d101      	bne.n	b7c <xQueueGenericSend+0x2c>
     b78:	2501      	movs	r5, #1
     b7a:	e7f4      	b.n	b66 <xQueueGenericSend+0x16>
     b7c:	2500      	movs	r5, #0
     b7e:	e7f2      	b.n	b66 <xQueueGenericSend+0x16>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     b80:	2e02      	cmp	r6, #2
     b82:	d003      	beq.n	b8c <xQueueGenericSend+0x3c>
     b84:	2d00      	cmp	r5, #0
     b86:	d106      	bne.n	b96 <xQueueGenericSend+0x46>
     b88:	b672      	cpsid	i
     b8a:	e7fe      	b.n	b8a <xQueueGenericSend+0x3a>
     b8c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     b8e:	2b01      	cmp	r3, #1
     b90:	d0f8      	beq.n	b84 <xQueueGenericSend+0x34>
     b92:	2500      	movs	r5, #0
     b94:	e7f6      	b.n	b84 <xQueueGenericSend+0x34>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     b96:	4b44      	ldr	r3, [pc, #272]	; (ca8 <xQueueGenericSend+0x158>)
     b98:	4798      	blx	r3
     b9a:	2800      	cmp	r0, #0
     b9c:	d103      	bne.n	ba6 <xQueueGenericSend+0x56>
     b9e:	9b01      	ldr	r3, [sp, #4]
     ba0:	2b00      	cmp	r3, #0
     ba2:	d000      	beq.n	ba6 <xQueueGenericSend+0x56>
     ba4:	2500      	movs	r5, #0
     ba6:	2d00      	cmp	r5, #0
     ba8:	d101      	bne.n	bae <xQueueGenericSend+0x5e>
     baa:	b672      	cpsid	i
     bac:	e7fe      	b.n	bac <xQueueGenericSend+0x5c>
     bae:	2500      	movs	r5, #0
     bb0:	e042      	b.n	c38 <xQueueGenericSend+0xe8>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     bb2:	0032      	movs	r2, r6
     bb4:	0039      	movs	r1, r7
     bb6:	0020      	movs	r0, r4
     bb8:	4b3c      	ldr	r3, [pc, #240]	; (cac <xQueueGenericSend+0x15c>)
     bba:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
     bbc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     bbe:	2b00      	cmp	r3, #0
     bc0:	d00c      	beq.n	bdc <xQueueGenericSend+0x8c>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     bc2:	0031      	movs	r1, r6
     bc4:	0020      	movs	r0, r4
     bc6:	4b3a      	ldr	r3, [pc, #232]	; (cb0 <xQueueGenericSend+0x160>)
     bc8:	4798      	blx	r3
     bca:	2800      	cmp	r0, #0
     bcc:	d001      	beq.n	bd2 <xQueueGenericSend+0x82>
							queueYIELD_IF_USING_PREEMPTION();
     bce:	4b39      	ldr	r3, [pc, #228]	; (cb4 <xQueueGenericSend+0x164>)
     bd0:	4798      	blx	r3
				taskEXIT_CRITICAL();
     bd2:	4b39      	ldr	r3, [pc, #228]	; (cb8 <xQueueGenericSend+0x168>)
     bd4:	4798      	blx	r3
				return pdPASS;
     bd6:	2001      	movs	r0, #1
}
     bd8:	b005      	add	sp, #20
     bda:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bdc:	6a63      	ldr	r3, [r4, #36]	; 0x24
     bde:	2b00      	cmp	r3, #0
     be0:	d008      	beq.n	bf4 <xQueueGenericSend+0xa4>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     be2:	0020      	movs	r0, r4
     be4:	3024      	adds	r0, #36	; 0x24
     be6:	4b35      	ldr	r3, [pc, #212]	; (cbc <xQueueGenericSend+0x16c>)
     be8:	4798      	blx	r3
     bea:	2800      	cmp	r0, #0
     bec:	d0f1      	beq.n	bd2 <xQueueGenericSend+0x82>
								queueYIELD_IF_USING_PREEMPTION();
     bee:	4b31      	ldr	r3, [pc, #196]	; (cb4 <xQueueGenericSend+0x164>)
     bf0:	4798      	blx	r3
     bf2:	e7ee      	b.n	bd2 <xQueueGenericSend+0x82>
						else if( xYieldRequired != pdFALSE )
     bf4:	2800      	cmp	r0, #0
     bf6:	d0ec      	beq.n	bd2 <xQueueGenericSend+0x82>
							queueYIELD_IF_USING_PREEMPTION();
     bf8:	4b2e      	ldr	r3, [pc, #184]	; (cb4 <xQueueGenericSend+0x164>)
     bfa:	4798      	blx	r3
     bfc:	e7e9      	b.n	bd2 <xQueueGenericSend+0x82>
					taskEXIT_CRITICAL();
     bfe:	4b2e      	ldr	r3, [pc, #184]	; (cb8 <xQueueGenericSend+0x168>)
     c00:	4798      	blx	r3
					return errQUEUE_FULL;
     c02:	2000      	movs	r0, #0
     c04:	e7e8      	b.n	bd8 <xQueueGenericSend+0x88>
		prvLockQueue( pxQueue );
     c06:	4b2c      	ldr	r3, [pc, #176]	; (cb8 <xQueueGenericSend+0x168>)
     c08:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c0a:	a901      	add	r1, sp, #4
     c0c:	a802      	add	r0, sp, #8
     c0e:	4b2c      	ldr	r3, [pc, #176]	; (cc0 <xQueueGenericSend+0x170>)
     c10:	4798      	blx	r3
     c12:	2800      	cmp	r0, #0
     c14:	d141      	bne.n	c9a <xQueueGenericSend+0x14a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     c16:	0020      	movs	r0, r4
     c18:	4b2a      	ldr	r3, [pc, #168]	; (cc4 <xQueueGenericSend+0x174>)
     c1a:	4798      	blx	r3
     c1c:	2800      	cmp	r0, #0
     c1e:	d036      	beq.n	c8e <xQueueGenericSend+0x13e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     c20:	0020      	movs	r0, r4
     c22:	3010      	adds	r0, #16
     c24:	9901      	ldr	r1, [sp, #4]
     c26:	4b28      	ldr	r3, [pc, #160]	; (cc8 <xQueueGenericSend+0x178>)
     c28:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     c2a:	0020      	movs	r0, r4
     c2c:	4b27      	ldr	r3, [pc, #156]	; (ccc <xQueueGenericSend+0x17c>)
     c2e:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     c30:	4b27      	ldr	r3, [pc, #156]	; (cd0 <xQueueGenericSend+0x180>)
     c32:	4798      	blx	r3
     c34:	2800      	cmp	r0, #0
     c36:	d027      	beq.n	c88 <xQueueGenericSend+0x138>
		taskENTER_CRITICAL();
     c38:	4b26      	ldr	r3, [pc, #152]	; (cd4 <xQueueGenericSend+0x184>)
     c3a:	4798      	blx	r3
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     c3c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     c3e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     c40:	4293      	cmp	r3, r2
     c42:	d3b6      	bcc.n	bb2 <xQueueGenericSend+0x62>
     c44:	2e02      	cmp	r6, #2
     c46:	d0b4      	beq.n	bb2 <xQueueGenericSend+0x62>
				if( xTicksToWait == ( TickType_t ) 0 )
     c48:	9b01      	ldr	r3, [sp, #4]
     c4a:	2b00      	cmp	r3, #0
     c4c:	d0d7      	beq.n	bfe <xQueueGenericSend+0xae>
				else if( xEntryTimeSet == pdFALSE )
     c4e:	2d00      	cmp	r5, #0
     c50:	d103      	bne.n	c5a <xQueueGenericSend+0x10a>
					vTaskInternalSetTimeOutState( &xTimeOut );
     c52:	a802      	add	r0, sp, #8
     c54:	4b20      	ldr	r3, [pc, #128]	; (cd8 <xQueueGenericSend+0x188>)
     c56:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
     c58:	3501      	adds	r5, #1
		taskEXIT_CRITICAL();
     c5a:	4b17      	ldr	r3, [pc, #92]	; (cb8 <xQueueGenericSend+0x168>)
     c5c:	4798      	blx	r3
		vTaskSuspendAll();
     c5e:	4b1f      	ldr	r3, [pc, #124]	; (cdc <xQueueGenericSend+0x18c>)
     c60:	4798      	blx	r3
		prvLockQueue( pxQueue );
     c62:	4b1c      	ldr	r3, [pc, #112]	; (cd4 <xQueueGenericSend+0x184>)
     c64:	4798      	blx	r3
     c66:	2344      	movs	r3, #68	; 0x44
     c68:	5ce3      	ldrb	r3, [r4, r3]
     c6a:	b25b      	sxtb	r3, r3
     c6c:	3301      	adds	r3, #1
     c6e:	d102      	bne.n	c76 <xQueueGenericSend+0x126>
     c70:	2200      	movs	r2, #0
     c72:	2344      	movs	r3, #68	; 0x44
     c74:	54e2      	strb	r2, [r4, r3]
     c76:	2345      	movs	r3, #69	; 0x45
     c78:	5ce3      	ldrb	r3, [r4, r3]
     c7a:	b25b      	sxtb	r3, r3
     c7c:	3301      	adds	r3, #1
     c7e:	d1c2      	bne.n	c06 <xQueueGenericSend+0xb6>
     c80:	2200      	movs	r2, #0
     c82:	2345      	movs	r3, #69	; 0x45
     c84:	54e2      	strb	r2, [r4, r3]
     c86:	e7be      	b.n	c06 <xQueueGenericSend+0xb6>
					portYIELD_WITHIN_API();
     c88:	4b0a      	ldr	r3, [pc, #40]	; (cb4 <xQueueGenericSend+0x164>)
     c8a:	4798      	blx	r3
     c8c:	e7d4      	b.n	c38 <xQueueGenericSend+0xe8>
				prvUnlockQueue( pxQueue );
     c8e:	0020      	movs	r0, r4
     c90:	4b0e      	ldr	r3, [pc, #56]	; (ccc <xQueueGenericSend+0x17c>)
     c92:	4798      	blx	r3
				( void ) xTaskResumeAll();
     c94:	4b0e      	ldr	r3, [pc, #56]	; (cd0 <xQueueGenericSend+0x180>)
     c96:	4798      	blx	r3
     c98:	e7ce      	b.n	c38 <xQueueGenericSend+0xe8>
			prvUnlockQueue( pxQueue );
     c9a:	0020      	movs	r0, r4
     c9c:	4b0b      	ldr	r3, [pc, #44]	; (ccc <xQueueGenericSend+0x17c>)
     c9e:	4798      	blx	r3
			( void ) xTaskResumeAll();
     ca0:	4b0b      	ldr	r3, [pc, #44]	; (cd0 <xQueueGenericSend+0x180>)
     ca2:	4798      	blx	r3
			return errQUEUE_FULL;
     ca4:	2000      	movs	r0, #0
     ca6:	e797      	b.n	bd8 <xQueueGenericSend+0x88>
     ca8:	000017a1 	.word	0x000017a1
     cac:	000008a1 	.word	0x000008a1
     cb0:	0000092d 	.word	0x0000092d
     cb4:	00000779 	.word	0x00000779
     cb8:	000007a9 	.word	0x000007a9
     cbc:	00001691 	.word	0x00001691
     cc0:	00001725 	.word	0x00001725
     cc4:	00000855 	.word	0x00000855
     cc8:	0000162d 	.word	0x0000162d
     ccc:	000009bd 	.word	0x000009bd
     cd0:	00001471 	.word	0x00001471
     cd4:	00000791 	.word	0x00000791
     cd8:	00001715 	.word	0x00001715
     cdc:	00001349 	.word	0x00001349

00000ce0 <xQueueGenericSendFromISR>:
{
     ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
     ce2:	b083      	sub	sp, #12
     ce4:	0004      	movs	r4, r0
     ce6:	9100      	str	r1, [sp, #0]
     ce8:	0017      	movs	r7, r2
     cea:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     cec:	2800      	cmp	r0, #0
     cee:	d007      	beq.n	d00 <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     cf0:	9b00      	ldr	r3, [sp, #0]
     cf2:	2b00      	cmp	r3, #0
     cf4:	d006      	beq.n	d04 <xQueueGenericSendFromISR+0x24>
     cf6:	2301      	movs	r3, #1
     cf8:	2b00      	cmp	r3, #0
     cfa:	d10a      	bne.n	d12 <xQueueGenericSendFromISR+0x32>
     cfc:	b672      	cpsid	i
     cfe:	e7fe      	b.n	cfe <xQueueGenericSendFromISR+0x1e>
	configASSERT( pxQueue );
     d00:	b672      	cpsid	i
     d02:	e7fe      	b.n	d02 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d04:	6c03      	ldr	r3, [r0, #64]	; 0x40
     d06:	2b00      	cmp	r3, #0
     d08:	d101      	bne.n	d0e <xQueueGenericSendFromISR+0x2e>
     d0a:	3301      	adds	r3, #1
     d0c:	e7f4      	b.n	cf8 <xQueueGenericSendFromISR+0x18>
     d0e:	2300      	movs	r3, #0
     d10:	e7f2      	b.n	cf8 <xQueueGenericSendFromISR+0x18>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     d12:	2d02      	cmp	r5, #2
     d14:	d003      	beq.n	d1e <xQueueGenericSendFromISR+0x3e>
     d16:	2b00      	cmp	r3, #0
     d18:	d106      	bne.n	d28 <xQueueGenericSendFromISR+0x48>
     d1a:	b672      	cpsid	i
     d1c:	e7fe      	b.n	d1c <xQueueGenericSendFromISR+0x3c>
     d1e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     d20:	2a01      	cmp	r2, #1
     d22:	d0f8      	beq.n	d16 <xQueueGenericSendFromISR+0x36>
     d24:	2300      	movs	r3, #0
     d26:	e7f6      	b.n	d16 <xQueueGenericSendFromISR+0x36>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     d28:	4b23      	ldr	r3, [pc, #140]	; (db8 <xQueueGenericSendFromISR+0xd8>)
     d2a:	4798      	blx	r3
     d2c:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     d2e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     d30:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     d32:	4293      	cmp	r3, r2
     d34:	d301      	bcc.n	d3a <xQueueGenericSendFromISR+0x5a>
     d36:	2d02      	cmp	r5, #2
     d38:	d132      	bne.n	da0 <xQueueGenericSendFromISR+0xc0>
			const int8_t cTxLock = pxQueue->cTxLock;
     d3a:	2345      	movs	r3, #69	; 0x45
     d3c:	5ce6      	ldrb	r6, [r4, r3]
     d3e:	b276      	sxtb	r6, r6
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d40:	002a      	movs	r2, r5
     d42:	9900      	ldr	r1, [sp, #0]
     d44:	0020      	movs	r0, r4
     d46:	4b1d      	ldr	r3, [pc, #116]	; (dbc <xQueueGenericSendFromISR+0xdc>)
     d48:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
     d4a:	1c73      	adds	r3, r6, #1
     d4c:	d122      	bne.n	d94 <xQueueGenericSendFromISR+0xb4>
					if( pxQueue->pxQueueSetContainer != NULL )
     d4e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     d50:	2b00      	cmp	r3, #0
     d52:	d010      	beq.n	d76 <xQueueGenericSendFromISR+0x96>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     d54:	0029      	movs	r1, r5
     d56:	0020      	movs	r0, r4
     d58:	4b19      	ldr	r3, [pc, #100]	; (dc0 <xQueueGenericSendFromISR+0xe0>)
     d5a:	4798      	blx	r3
     d5c:	2800      	cmp	r0, #0
     d5e:	d021      	beq.n	da4 <xQueueGenericSendFromISR+0xc4>
							if( pxHigherPriorityTaskWoken != NULL )
     d60:	2f00      	cmp	r7, #0
     d62:	d021      	beq.n	da8 <xQueueGenericSendFromISR+0xc8>
								*pxHigherPriorityTaskWoken = pdTRUE;
     d64:	2301      	movs	r3, #1
     d66:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
     d68:	2401      	movs	r4, #1
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
     d6a:	9801      	ldr	r0, [sp, #4]
     d6c:	4b15      	ldr	r3, [pc, #84]	; (dc4 <xQueueGenericSendFromISR+0xe4>)
     d6e:	4798      	blx	r3
}
     d70:	0020      	movs	r0, r4
     d72:	b003      	add	sp, #12
     d74:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d76:	6a63      	ldr	r3, [r4, #36]	; 0x24
     d78:	2b00      	cmp	r3, #0
     d7a:	d017      	beq.n	dac <xQueueGenericSendFromISR+0xcc>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d7c:	0020      	movs	r0, r4
     d7e:	3024      	adds	r0, #36	; 0x24
     d80:	4b11      	ldr	r3, [pc, #68]	; (dc8 <xQueueGenericSendFromISR+0xe8>)
     d82:	4798      	blx	r3
     d84:	2800      	cmp	r0, #0
     d86:	d013      	beq.n	db0 <xQueueGenericSendFromISR+0xd0>
								if( pxHigherPriorityTaskWoken != NULL )
     d88:	2f00      	cmp	r7, #0
     d8a:	d013      	beq.n	db4 <xQueueGenericSendFromISR+0xd4>
									*pxHigherPriorityTaskWoken = pdTRUE;
     d8c:	2301      	movs	r3, #1
     d8e:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
     d90:	2401      	movs	r4, #1
     d92:	e7ea      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     d94:	1c73      	adds	r3, r6, #1
     d96:	b25b      	sxtb	r3, r3
     d98:	2245      	movs	r2, #69	; 0x45
     d9a:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
     d9c:	2401      	movs	r4, #1
     d9e:	e7e4      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
			xReturn = errQUEUE_FULL;
     da0:	2400      	movs	r4, #0
     da2:	e7e2      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
			xReturn = pdPASS;
     da4:	2401      	movs	r4, #1
     da6:	e7e0      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
     da8:	2401      	movs	r4, #1
     daa:	e7de      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
     dac:	2401      	movs	r4, #1
     dae:	e7dc      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
     db0:	2401      	movs	r4, #1
     db2:	e7da      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
     db4:	2401      	movs	r4, #1
     db6:	e7d8      	b.n	d6a <xQueueGenericSendFromISR+0x8a>
     db8:	000007c9 	.word	0x000007c9
     dbc:	000008a1 	.word	0x000008a1
     dc0:	0000092d 	.word	0x0000092d
     dc4:	000007d1 	.word	0x000007d1
     dc8:	00001691 	.word	0x00001691

00000dcc <xQueueReceive>:
{
     dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
     dce:	b085      	sub	sp, #20
     dd0:	0004      	movs	r4, r0
     dd2:	000e      	movs	r6, r1
     dd4:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
     dd6:	2800      	cmp	r0, #0
     dd8:	d006      	beq.n	de8 <xQueueReceive+0x1c>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     dda:	2900      	cmp	r1, #0
     ddc:	d006      	beq.n	dec <xQueueReceive+0x20>
     dde:	2501      	movs	r5, #1
     de0:	2d00      	cmp	r5, #0
     de2:	d10a      	bne.n	dfa <xQueueReceive+0x2e>
     de4:	b672      	cpsid	i
     de6:	e7fe      	b.n	de6 <xQueueReceive+0x1a>
	configASSERT( ( pxQueue ) );
     de8:	b672      	cpsid	i
     dea:	e7fe      	b.n	dea <xQueueReceive+0x1e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     dec:	6c03      	ldr	r3, [r0, #64]	; 0x40
     dee:	2b00      	cmp	r3, #0
     df0:	d101      	bne.n	df6 <xQueueReceive+0x2a>
     df2:	2501      	movs	r5, #1
     df4:	e7f4      	b.n	de0 <xQueueReceive+0x14>
     df6:	2500      	movs	r5, #0
     df8:	e7f2      	b.n	de0 <xQueueReceive+0x14>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     dfa:	4b3e      	ldr	r3, [pc, #248]	; (ef4 <xQueueReceive+0x128>)
     dfc:	4798      	blx	r3
     dfe:	2800      	cmp	r0, #0
     e00:	d103      	bne.n	e0a <xQueueReceive+0x3e>
     e02:	9b01      	ldr	r3, [sp, #4]
     e04:	2b00      	cmp	r3, #0
     e06:	d000      	beq.n	e0a <xQueueReceive+0x3e>
     e08:	2500      	movs	r5, #0
     e0a:	2d00      	cmp	r5, #0
     e0c:	d101      	bne.n	e12 <xQueueReceive+0x46>
     e0e:	b672      	cpsid	i
     e10:	e7fe      	b.n	e10 <xQueueReceive+0x44>
     e12:	2700      	movs	r7, #0
     e14:	e02b      	b.n	e6e <xQueueReceive+0xa2>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
     e16:	0031      	movs	r1, r6
     e18:	0020      	movs	r0, r4
     e1a:	4b37      	ldr	r3, [pc, #220]	; (ef8 <xQueueReceive+0x12c>)
     e1c:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     e1e:	3d01      	subs	r5, #1
     e20:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e22:	6923      	ldr	r3, [r4, #16]
     e24:	2b00      	cmp	r3, #0
     e26:	d007      	beq.n	e38 <xQueueReceive+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e28:	0020      	movs	r0, r4
     e2a:	3010      	adds	r0, #16
     e2c:	4b33      	ldr	r3, [pc, #204]	; (efc <xQueueReceive+0x130>)
     e2e:	4798      	blx	r3
     e30:	2800      	cmp	r0, #0
     e32:	d001      	beq.n	e38 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
     e34:	4b32      	ldr	r3, [pc, #200]	; (f00 <xQueueReceive+0x134>)
     e36:	4798      	blx	r3
				taskEXIT_CRITICAL();
     e38:	4b32      	ldr	r3, [pc, #200]	; (f04 <xQueueReceive+0x138>)
     e3a:	4798      	blx	r3
				return pdPASS;
     e3c:	2001      	movs	r0, #1
}
     e3e:	b005      	add	sp, #20
     e40:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
     e42:	4b30      	ldr	r3, [pc, #192]	; (f04 <xQueueReceive+0x138>)
     e44:	4798      	blx	r3
					return errQUEUE_EMPTY;
     e46:	2000      	movs	r0, #0
     e48:	e7f9      	b.n	e3e <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
     e4a:	a802      	add	r0, sp, #8
     e4c:	4b2e      	ldr	r3, [pc, #184]	; (f08 <xQueueReceive+0x13c>)
     e4e:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
     e50:	3701      	adds	r7, #1
     e52:	e016      	b.n	e82 <xQueueReceive+0xb6>
		prvLockQueue( pxQueue );
     e54:	2200      	movs	r2, #0
     e56:	2344      	movs	r3, #68	; 0x44
     e58:	54e2      	strb	r2, [r4, r3]
     e5a:	e01d      	b.n	e98 <xQueueReceive+0xcc>
     e5c:	2200      	movs	r2, #0
     e5e:	2345      	movs	r3, #69	; 0x45
     e60:	54e2      	strb	r2, [r4, r3]
     e62:	e01e      	b.n	ea2 <xQueueReceive+0xd6>
				prvUnlockQueue( pxQueue );
     e64:	0020      	movs	r0, r4
     e66:	4b29      	ldr	r3, [pc, #164]	; (f0c <xQueueReceive+0x140>)
     e68:	4798      	blx	r3
				( void ) xTaskResumeAll();
     e6a:	4b29      	ldr	r3, [pc, #164]	; (f10 <xQueueReceive+0x144>)
     e6c:	4798      	blx	r3
		taskENTER_CRITICAL();
     e6e:	4b29      	ldr	r3, [pc, #164]	; (f14 <xQueueReceive+0x148>)
     e70:	4798      	blx	r3
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     e72:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     e74:	2d00      	cmp	r5, #0
     e76:	d1ce      	bne.n	e16 <xQueueReceive+0x4a>
				if( xTicksToWait == ( TickType_t ) 0 )
     e78:	9b01      	ldr	r3, [sp, #4]
     e7a:	2b00      	cmp	r3, #0
     e7c:	d0e1      	beq.n	e42 <xQueueReceive+0x76>
				else if( xEntryTimeSet == pdFALSE )
     e7e:	2f00      	cmp	r7, #0
     e80:	d0e3      	beq.n	e4a <xQueueReceive+0x7e>
		taskEXIT_CRITICAL();
     e82:	4b20      	ldr	r3, [pc, #128]	; (f04 <xQueueReceive+0x138>)
     e84:	4798      	blx	r3
		vTaskSuspendAll();
     e86:	4b24      	ldr	r3, [pc, #144]	; (f18 <xQueueReceive+0x14c>)
     e88:	4798      	blx	r3
		prvLockQueue( pxQueue );
     e8a:	4b22      	ldr	r3, [pc, #136]	; (f14 <xQueueReceive+0x148>)
     e8c:	4798      	blx	r3
     e8e:	2344      	movs	r3, #68	; 0x44
     e90:	5ce3      	ldrb	r3, [r4, r3]
     e92:	b25b      	sxtb	r3, r3
     e94:	3301      	adds	r3, #1
     e96:	d0dd      	beq.n	e54 <xQueueReceive+0x88>
     e98:	2345      	movs	r3, #69	; 0x45
     e9a:	5ce3      	ldrb	r3, [r4, r3]
     e9c:	b25b      	sxtb	r3, r3
     e9e:	3301      	adds	r3, #1
     ea0:	d0dc      	beq.n	e5c <xQueueReceive+0x90>
     ea2:	4b18      	ldr	r3, [pc, #96]	; (f04 <xQueueReceive+0x138>)
     ea4:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ea6:	a901      	add	r1, sp, #4
     ea8:	a802      	add	r0, sp, #8
     eaa:	4b1c      	ldr	r3, [pc, #112]	; (f1c <xQueueReceive+0x150>)
     eac:	4798      	blx	r3
     eae:	2800      	cmp	r0, #0
     eb0:	d113      	bne.n	eda <xQueueReceive+0x10e>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     eb2:	0020      	movs	r0, r4
     eb4:	4b1a      	ldr	r3, [pc, #104]	; (f20 <xQueueReceive+0x154>)
     eb6:	4798      	blx	r3
     eb8:	2800      	cmp	r0, #0
     eba:	d0d3      	beq.n	e64 <xQueueReceive+0x98>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ebc:	0020      	movs	r0, r4
     ebe:	3024      	adds	r0, #36	; 0x24
     ec0:	9901      	ldr	r1, [sp, #4]
     ec2:	4b18      	ldr	r3, [pc, #96]	; (f24 <xQueueReceive+0x158>)
     ec4:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     ec6:	0020      	movs	r0, r4
     ec8:	4b10      	ldr	r3, [pc, #64]	; (f0c <xQueueReceive+0x140>)
     eca:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     ecc:	4b10      	ldr	r3, [pc, #64]	; (f10 <xQueueReceive+0x144>)
     ece:	4798      	blx	r3
     ed0:	2800      	cmp	r0, #0
     ed2:	d1cc      	bne.n	e6e <xQueueReceive+0xa2>
					portYIELD_WITHIN_API();
     ed4:	4b0a      	ldr	r3, [pc, #40]	; (f00 <xQueueReceive+0x134>)
     ed6:	4798      	blx	r3
     ed8:	e7c9      	b.n	e6e <xQueueReceive+0xa2>
			prvUnlockQueue( pxQueue );
     eda:	0020      	movs	r0, r4
     edc:	4b0b      	ldr	r3, [pc, #44]	; (f0c <xQueueReceive+0x140>)
     ede:	4798      	blx	r3
			( void ) xTaskResumeAll();
     ee0:	4b0b      	ldr	r3, [pc, #44]	; (f10 <xQueueReceive+0x144>)
     ee2:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ee4:	0020      	movs	r0, r4
     ee6:	4b0e      	ldr	r3, [pc, #56]	; (f20 <xQueueReceive+0x154>)
     ee8:	4798      	blx	r3
     eea:	2800      	cmp	r0, #0
     eec:	d0bf      	beq.n	e6e <xQueueReceive+0xa2>
				return errQUEUE_EMPTY;
     eee:	2000      	movs	r0, #0
     ef0:	e7a5      	b.n	e3e <xQueueReceive+0x72>
     ef2:	46c0      	nop			; (mov r8, r8)
     ef4:	000017a1 	.word	0x000017a1
     ef8:	00000995 	.word	0x00000995
     efc:	00001691 	.word	0x00001691
     f00:	00000779 	.word	0x00000779
     f04:	000007a9 	.word	0x000007a9
     f08:	00001715 	.word	0x00001715
     f0c:	000009bd 	.word	0x000009bd
     f10:	00001471 	.word	0x00001471
     f14:	00000791 	.word	0x00000791
     f18:	00001349 	.word	0x00001349
     f1c:	00001725 	.word	0x00001725
     f20:	0000087d 	.word	0x0000087d
     f24:	0000162d 	.word	0x0000162d

00000f28 <vQueueAddToRegistry>:
	{
     f28:	b510      	push	{r4, lr}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
     f2a:	2300      	movs	r3, #0
     f2c:	2b07      	cmp	r3, #7
     f2e:	d80a      	bhi.n	f46 <vQueueAddToRegistry+0x1e>
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
     f30:	00da      	lsls	r2, r3, #3
     f32:	4c05      	ldr	r4, [pc, #20]	; (f48 <vQueueAddToRegistry+0x20>)
     f34:	5912      	ldr	r2, [r2, r4]
     f36:	2a00      	cmp	r2, #0
     f38:	d001      	beq.n	f3e <vQueueAddToRegistry+0x16>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
     f3a:	3301      	adds	r3, #1
     f3c:	e7f6      	b.n	f2c <vQueueAddToRegistry+0x4>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
     f3e:	00db      	lsls	r3, r3, #3
     f40:	5119      	str	r1, [r3, r4]
				xQueueRegistry[ ux ].xHandle = xQueue;
     f42:	18e3      	adds	r3, r4, r3
     f44:	6058      	str	r0, [r3, #4]
	}
     f46:	bd10      	pop	{r4, pc}
     f48:	20004448 	.word	0x20004448

00000f4c <vQueueWaitForMessageRestricted>:
	{
     f4c:	b570      	push	{r4, r5, r6, lr}
     f4e:	0004      	movs	r4, r0
     f50:	000d      	movs	r5, r1
     f52:	0016      	movs	r6, r2
		prvLockQueue( pxQueue );
     f54:	4b11      	ldr	r3, [pc, #68]	; (f9c <vQueueWaitForMessageRestricted+0x50>)
     f56:	4798      	blx	r3
     f58:	2344      	movs	r3, #68	; 0x44
     f5a:	5ce3      	ldrb	r3, [r4, r3]
     f5c:	b25b      	sxtb	r3, r3
     f5e:	3301      	adds	r3, #1
     f60:	d00d      	beq.n	f7e <vQueueWaitForMessageRestricted+0x32>
     f62:	2345      	movs	r3, #69	; 0x45
     f64:	5ce3      	ldrb	r3, [r4, r3]
     f66:	b25b      	sxtb	r3, r3
     f68:	3301      	adds	r3, #1
     f6a:	d00c      	beq.n	f86 <vQueueWaitForMessageRestricted+0x3a>
     f6c:	4b0c      	ldr	r3, [pc, #48]	; (fa0 <vQueueWaitForMessageRestricted+0x54>)
     f6e:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     f70:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     f72:	2b00      	cmp	r3, #0
     f74:	d00b      	beq.n	f8e <vQueueWaitForMessageRestricted+0x42>
		prvUnlockQueue( pxQueue );
     f76:	0020      	movs	r0, r4
     f78:	4b0a      	ldr	r3, [pc, #40]	; (fa4 <vQueueWaitForMessageRestricted+0x58>)
     f7a:	4798      	blx	r3
	}
     f7c:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
     f7e:	2200      	movs	r2, #0
     f80:	2344      	movs	r3, #68	; 0x44
     f82:	54e2      	strb	r2, [r4, r3]
     f84:	e7ed      	b.n	f62 <vQueueWaitForMessageRestricted+0x16>
     f86:	2200      	movs	r2, #0
     f88:	2345      	movs	r3, #69	; 0x45
     f8a:	54e2      	strb	r2, [r4, r3]
     f8c:	e7ee      	b.n	f6c <vQueueWaitForMessageRestricted+0x20>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     f8e:	0020      	movs	r0, r4
     f90:	3024      	adds	r0, #36	; 0x24
     f92:	0032      	movs	r2, r6
     f94:	0029      	movs	r1, r5
     f96:	4b04      	ldr	r3, [pc, #16]	; (fa8 <vQueueWaitForMessageRestricted+0x5c>)
     f98:	4798      	blx	r3
     f9a:	e7ec      	b.n	f76 <vQueueWaitForMessageRestricted+0x2a>
     f9c:	00000791 	.word	0x00000791
     fa0:	000007a9 	.word	0x000007a9
     fa4:	000009bd 	.word	0x000009bd
     fa8:	00001659 	.word	0x00001659

00000fac <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     fac:	4b0a      	ldr	r3, [pc, #40]	; (fd8 <prvResetNextTaskUnblockTime+0x2c>)
     fae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     fb0:	681b      	ldr	r3, [r3, #0]
     fb2:	2b00      	cmp	r3, #0
     fb4:	d109      	bne.n	fca <prvResetNextTaskUnblockTime+0x1e>
     fb6:	3301      	adds	r3, #1
     fb8:	2b00      	cmp	r3, #0
     fba:	d108      	bne.n	fce <prvResetNextTaskUnblockTime+0x22>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     fbc:	4b06      	ldr	r3, [pc, #24]	; (fd8 <prvResetNextTaskUnblockTime+0x2c>)
     fbe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     fc0:	68d2      	ldr	r2, [r2, #12]
     fc2:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     fc4:	6852      	ldr	r2, [r2, #4]
     fc6:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
     fc8:	4770      	bx	lr
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     fca:	2300      	movs	r3, #0
     fcc:	e7f4      	b.n	fb8 <prvResetNextTaskUnblockTime+0xc>
		xNextTaskUnblockTime = portMAX_DELAY;
     fce:	2201      	movs	r2, #1
     fd0:	4252      	negs	r2, r2
     fd2:	4b01      	ldr	r3, [pc, #4]	; (fd8 <prvResetNextTaskUnblockTime+0x2c>)
     fd4:	62da      	str	r2, [r3, #44]	; 0x2c
     fd6:	e7f7      	b.n	fc8 <prvResetNextTaskUnblockTime+0x1c>
     fd8:	20004308 	.word	0x20004308

00000fdc <prvDeleteTCB>:
	{
     fdc:	b570      	push	{r4, r5, r6, lr}
     fde:	0005      	movs	r5, r0
			vPortFree( pxTCB->pxStack );
     fe0:	6b00      	ldr	r0, [r0, #48]	; 0x30
     fe2:	4c02      	ldr	r4, [pc, #8]	; (fec <prvDeleteTCB+0x10>)
     fe4:	47a0      	blx	r4
			vPortFree( pxTCB );
     fe6:	0028      	movs	r0, r5
     fe8:	47a0      	blx	r4
	}
     fea:	bd70      	pop	{r4, r5, r6, pc}
     fec:	000002c9 	.word	0x000002c9

00000ff0 <prvInitialiseNewTask>:
{
     ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
     ff2:	46c6      	mov	lr, r8
     ff4:	b500      	push	{lr}
     ff6:	b082      	sub	sp, #8
     ff8:	9000      	str	r0, [sp, #0]
     ffa:	000f      	movs	r7, r1
     ffc:	0015      	movs	r5, r2
     ffe:	9301      	str	r3, [sp, #4]
    1000:	9c08      	ldr	r4, [sp, #32]
    1002:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    1004:	0092      	lsls	r2, r2, #2
    1006:	21a5      	movs	r1, #165	; 0xa5
    1008:	6b30      	ldr	r0, [r6, #48]	; 0x30
    100a:	4b1f      	ldr	r3, [pc, #124]	; (1088 <prvInitialiseNewTask+0x98>)
    100c:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    100e:	4b1f      	ldr	r3, [pc, #124]	; (108c <prvInitialiseNewTask+0x9c>)
    1010:	18eb      	adds	r3, r5, r3
    1012:	009b      	lsls	r3, r3, #2
    1014:	6b32      	ldr	r2, [r6, #48]	; 0x30
    1016:	4694      	mov	ip, r2
    1018:	4463      	add	r3, ip
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    101a:	2207      	movs	r2, #7
    101c:	4393      	bics	r3, r2
    101e:	4698      	mov	r8, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1020:	2300      	movs	r3, #0
    1022:	2b04      	cmp	r3, #4
    1024:	d809      	bhi.n	103a <prvInitialiseNewTask+0x4a>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1026:	18f9      	adds	r1, r7, r3
    1028:	7808      	ldrb	r0, [r1, #0]
    102a:	18f2      	adds	r2, r6, r3
    102c:	3234      	adds	r2, #52	; 0x34
    102e:	7010      	strb	r0, [r2, #0]
		if( pcName[ x ] == 0x00 )
    1030:	780a      	ldrb	r2, [r1, #0]
    1032:	2a00      	cmp	r2, #0
    1034:	d001      	beq.n	103a <prvInitialiseNewTask+0x4a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1036:	3301      	adds	r3, #1
    1038:	e7f3      	b.n	1022 <prvInitialiseNewTask+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    103a:	2200      	movs	r2, #0
    103c:	2338      	movs	r3, #56	; 0x38
    103e:	54f2      	strb	r2, [r6, r3]
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1040:	2c04      	cmp	r4, #4
    1042:	d900      	bls.n	1046 <prvInitialiseNewTask+0x56>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1044:	2404      	movs	r4, #4
	pxNewTCB->uxPriority = uxPriority;
    1046:	62f4      	str	r4, [r6, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    1048:	6474      	str	r4, [r6, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    104a:	2500      	movs	r5, #0
    104c:	64b5      	str	r5, [r6, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    104e:	1d30      	adds	r0, r6, #4
    1050:	4f0f      	ldr	r7, [pc, #60]	; (1090 <prvInitialiseNewTask+0xa0>)
    1052:	47b8      	blx	r7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1054:	0030      	movs	r0, r6
    1056:	3018      	adds	r0, #24
    1058:	47b8      	blx	r7
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    105a:	6136      	str	r6, [r6, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    105c:	2305      	movs	r3, #5
    105e:	1b1c      	subs	r4, r3, r4
    1060:	61b4      	str	r4, [r6, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1062:	6276      	str	r6, [r6, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    1064:	64f5      	str	r5, [r6, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1066:	334b      	adds	r3, #75	; 0x4b
    1068:	54f5      	strb	r5, [r6, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    106a:	9a01      	ldr	r2, [sp, #4]
    106c:	9900      	ldr	r1, [sp, #0]
    106e:	4640      	mov	r0, r8
    1070:	4b08      	ldr	r3, [pc, #32]	; (1094 <prvInitialiseNewTask+0xa4>)
    1072:	4798      	blx	r3
    1074:	6030      	str	r0, [r6, #0]
	if( ( void * ) pxCreatedTask != NULL )
    1076:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1078:	2b00      	cmp	r3, #0
    107a:	d000      	beq.n	107e <prvInitialiseNewTask+0x8e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    107c:	601e      	str	r6, [r3, #0]
}
    107e:	b002      	add	sp, #8
    1080:	bc04      	pop	{r2}
    1082:	4690      	mov	r8, r2
    1084:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1086:	46c0      	nop			; (mov r8, r8)
    1088:	00001d95 	.word	0x00001d95
    108c:	3fffffff 	.word	0x3fffffff
    1090:	00000327 	.word	0x00000327
    1094:	0000070d 	.word	0x0000070d

00001098 <prvInitialiseTaskLists>:
{
    1098:	b5f0      	push	{r4, r5, r6, r7, lr}
    109a:	46c6      	mov	lr, r8
    109c:	b500      	push	{lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    109e:	2400      	movs	r4, #0
    10a0:	e008      	b.n	10b4 <prvInitialiseTaskLists+0x1c>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    10a2:	00a3      	lsls	r3, r4, #2
    10a4:	191b      	adds	r3, r3, r4
    10a6:	009a      	lsls	r2, r3, #2
    10a8:	4810      	ldr	r0, [pc, #64]	; (10ec <prvInitialiseTaskLists+0x54>)
    10aa:	3030      	adds	r0, #48	; 0x30
    10ac:	1880      	adds	r0, r0, r2
    10ae:	4b10      	ldr	r3, [pc, #64]	; (10f0 <prvInitialiseTaskLists+0x58>)
    10b0:	4798      	blx	r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    10b2:	3401      	adds	r4, #1
    10b4:	2c04      	cmp	r4, #4
    10b6:	d9f4      	bls.n	10a2 <prvInitialiseTaskLists+0xa>
	vListInitialise( &xDelayedTaskList1 );
    10b8:	4d0e      	ldr	r5, [pc, #56]	; (10f4 <prvInitialiseTaskLists+0x5c>)
    10ba:	2314      	movs	r3, #20
    10bc:	4698      	mov	r8, r3
    10be:	44a8      	add	r8, r5
    10c0:	4640      	mov	r0, r8
    10c2:	4c0b      	ldr	r4, [pc, #44]	; (10f0 <prvInitialiseTaskLists+0x58>)
    10c4:	47a0      	blx	r4
	vListInitialise( &xDelayedTaskList2 );
    10c6:	002f      	movs	r7, r5
    10c8:	3728      	adds	r7, #40	; 0x28
    10ca:	0038      	movs	r0, r7
    10cc:	47a0      	blx	r4
	vListInitialise( &xPendingReadyList );
    10ce:	4e07      	ldr	r6, [pc, #28]	; (10ec <prvInitialiseTaskLists+0x54>)
    10d0:	0030      	movs	r0, r6
    10d2:	3014      	adds	r0, #20
    10d4:	47a0      	blx	r4
		vListInitialise( &xTasksWaitingTermination );
    10d6:	0028      	movs	r0, r5
    10d8:	303c      	adds	r0, #60	; 0x3c
    10da:	47a0      	blx	r4
		vListInitialise( &xSuspendedTaskList );
    10dc:	0030      	movs	r0, r6
    10de:	47a0      	blx	r4
	pxDelayedTaskList = &xDelayedTaskList1;
    10e0:	4643      	mov	r3, r8
    10e2:	62b3      	str	r3, [r6, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    10e4:	652f      	str	r7, [r5, #80]	; 0x50
}
    10e6:	bc04      	pop	{r2}
    10e8:	4690      	mov	r8, r2
    10ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    10ec:	20004308 	.word	0x20004308
    10f0:	00000311 	.word	0x00000311
    10f4:	20004388 	.word	0x20004388

000010f8 <prvAddNewTaskToReadyList>:
{
    10f8:	b510      	push	{r4, lr}
    10fa:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
    10fc:	4b1f      	ldr	r3, [pc, #124]	; (117c <prvAddNewTaskToReadyList+0x84>)
    10fe:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    1100:	4b1f      	ldr	r3, [pc, #124]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    1102:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    1104:	3201      	adds	r2, #1
    1106:	655a      	str	r2, [r3, #84]	; 0x54
		if( pxCurrentTCB == NULL )
    1108:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    110a:	2b00      	cmp	r3, #0
    110c:	d02b      	beq.n	1166 <prvAddNewTaskToReadyList+0x6e>
			if( xSchedulerRunning == pdFALSE )
    110e:	4b1c      	ldr	r3, [pc, #112]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    1110:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1112:	2b00      	cmp	r3, #0
    1114:	d107      	bne.n	1126 <prvAddNewTaskToReadyList+0x2e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1116:	4b1a      	ldr	r3, [pc, #104]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    1118:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    111a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    111c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    111e:	4293      	cmp	r3, r2
    1120:	d801      	bhi.n	1126 <prvAddNewTaskToReadyList+0x2e>
					pxCurrentTCB = pxNewTCB;
    1122:	4b17      	ldr	r3, [pc, #92]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    1124:	659c      	str	r4, [r3, #88]	; 0x58
		uxTaskNumber++;
    1126:	4916      	ldr	r1, [pc, #88]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    1128:	6e0b      	ldr	r3, [r1, #96]	; 0x60
    112a:	3301      	adds	r3, #1
    112c:	660b      	str	r3, [r1, #96]	; 0x60
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    112e:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList( pxNewTCB );
    1130:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1132:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    1134:	429a      	cmp	r2, r3
    1136:	d900      	bls.n	113a <prvAddNewTaskToReadyList+0x42>
    1138:	664a      	str	r2, [r1, #100]	; 0x64
    113a:	1d21      	adds	r1, r4, #4
    113c:	0093      	lsls	r3, r2, #2
    113e:	189b      	adds	r3, r3, r2
    1140:	009a      	lsls	r2, r3, #2
    1142:	4810      	ldr	r0, [pc, #64]	; (1184 <prvAddNewTaskToReadyList+0x8c>)
    1144:	3030      	adds	r0, #48	; 0x30
    1146:	1880      	adds	r0, r0, r2
    1148:	4b0f      	ldr	r3, [pc, #60]	; (1188 <prvAddNewTaskToReadyList+0x90>)
    114a:	4798      	blx	r3
	taskEXIT_CRITICAL();
    114c:	4b0f      	ldr	r3, [pc, #60]	; (118c <prvAddNewTaskToReadyList+0x94>)
    114e:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    1150:	4b0b      	ldr	r3, [pc, #44]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    1152:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1154:	2b00      	cmp	r3, #0
    1156:	d005      	beq.n	1164 <prvAddNewTaskToReadyList+0x6c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1158:	4b09      	ldr	r3, [pc, #36]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    115a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    115c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    115e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1160:	429a      	cmp	r2, r3
    1162:	d308      	bcc.n	1176 <prvAddNewTaskToReadyList+0x7e>
}
    1164:	bd10      	pop	{r4, pc}
			pxCurrentTCB = pxNewTCB;
    1166:	4b06      	ldr	r3, [pc, #24]	; (1180 <prvAddNewTaskToReadyList+0x88>)
    1168:	659c      	str	r4, [r3, #88]	; 0x58
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    116a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    116c:	2b01      	cmp	r3, #1
    116e:	d1da      	bne.n	1126 <prvAddNewTaskToReadyList+0x2e>
				prvInitialiseTaskLists();
    1170:	4b07      	ldr	r3, [pc, #28]	; (1190 <prvAddNewTaskToReadyList+0x98>)
    1172:	4798      	blx	r3
    1174:	e7d7      	b.n	1126 <prvAddNewTaskToReadyList+0x2e>
			taskYIELD_IF_USING_PREEMPTION();
    1176:	4b07      	ldr	r3, [pc, #28]	; (1194 <prvAddNewTaskToReadyList+0x9c>)
    1178:	4798      	blx	r3
}
    117a:	e7f3      	b.n	1164 <prvAddNewTaskToReadyList+0x6c>
    117c:	00000791 	.word	0x00000791
    1180:	20004388 	.word	0x20004388
    1184:	20004308 	.word	0x20004308
    1188:	0000032d 	.word	0x0000032d
    118c:	000007a9 	.word	0x000007a9
    1190:	00001099 	.word	0x00001099
    1194:	00000779 	.word	0x00000779

00001198 <prvCheckTasksWaitingTermination>:
{
    1198:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    119a:	e012      	b.n	11c2 <prvCheckTasksWaitingTermination+0x2a>
			taskENTER_CRITICAL();
    119c:	4b0b      	ldr	r3, [pc, #44]	; (11cc <prvCheckTasksWaitingTermination+0x34>)
    119e:	4798      	blx	r3
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    11a0:	4c0b      	ldr	r4, [pc, #44]	; (11d0 <prvCheckTasksWaitingTermination+0x38>)
    11a2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    11a4:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    11a6:	1d28      	adds	r0, r5, #4
    11a8:	4b0a      	ldr	r3, [pc, #40]	; (11d4 <prvCheckTasksWaitingTermination+0x3c>)
    11aa:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    11ac:	6d63      	ldr	r3, [r4, #84]	; 0x54
    11ae:	3b01      	subs	r3, #1
    11b0:	6563      	str	r3, [r4, #84]	; 0x54
				--uxDeletedTasksWaitingCleanUp;
    11b2:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    11b4:	3b01      	subs	r3, #1
    11b6:	66a3      	str	r3, [r4, #104]	; 0x68
			taskEXIT_CRITICAL();
    11b8:	4b07      	ldr	r3, [pc, #28]	; (11d8 <prvCheckTasksWaitingTermination+0x40>)
    11ba:	4798      	blx	r3
			prvDeleteTCB( pxTCB );
    11bc:	0028      	movs	r0, r5
    11be:	4b07      	ldr	r3, [pc, #28]	; (11dc <prvCheckTasksWaitingTermination+0x44>)
    11c0:	4798      	blx	r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    11c2:	4b03      	ldr	r3, [pc, #12]	; (11d0 <prvCheckTasksWaitingTermination+0x38>)
    11c4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    11c6:	2b00      	cmp	r3, #0
    11c8:	d1e8      	bne.n	119c <prvCheckTasksWaitingTermination+0x4>
}
    11ca:	bd70      	pop	{r4, r5, r6, pc}
    11cc:	00000791 	.word	0x00000791
    11d0:	20004388 	.word	0x20004388
    11d4:	00000375 	.word	0x00000375
    11d8:	000007a9 	.word	0x000007a9
    11dc:	00000fdd 	.word	0x00000fdd

000011e0 <prvIdleTask>:
{
    11e0:	b510      	push	{r4, lr}
		prvCheckTasksWaitingTermination();
    11e2:	4b04      	ldr	r3, [pc, #16]	; (11f4 <prvIdleTask+0x14>)
    11e4:	4798      	blx	r3
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    11e6:	4b04      	ldr	r3, [pc, #16]	; (11f8 <prvIdleTask+0x18>)
    11e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    11ea:	2b01      	cmp	r3, #1
    11ec:	d9f9      	bls.n	11e2 <prvIdleTask+0x2>
				taskYIELD();
    11ee:	4b03      	ldr	r3, [pc, #12]	; (11fc <prvIdleTask+0x1c>)
    11f0:	4798      	blx	r3
    11f2:	e7f6      	b.n	11e2 <prvIdleTask+0x2>
    11f4:	00001199 	.word	0x00001199
    11f8:	20004308 	.word	0x20004308
    11fc:	00000779 	.word	0x00000779

00001200 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1200:	b570      	push	{r4, r5, r6, lr}
    1202:	0004      	movs	r4, r0
    1204:	000d      	movs	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1206:	4b15      	ldr	r3, [pc, #84]	; (125c <prvAddCurrentTaskToDelayedList+0x5c>)
    1208:	6ede      	ldr	r6, [r3, #108]	; 0x6c
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    120a:	6d98      	ldr	r0, [r3, #88]	; 0x58
    120c:	3004      	adds	r0, #4
    120e:	4b14      	ldr	r3, [pc, #80]	; (1260 <prvAddCurrentTaskToDelayedList+0x60>)
    1210:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1212:	1c63      	adds	r3, r4, #1
    1214:	d012      	beq.n	123c <prvAddCurrentTaskToDelayedList+0x3c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    1216:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1218:	4b10      	ldr	r3, [pc, #64]	; (125c <prvAddCurrentTaskToDelayedList+0x5c>)
    121a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    121c:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
    121e:	42a6      	cmp	r6, r4
    1220:	d815      	bhi.n	124e <prvAddCurrentTaskToDelayedList+0x4e>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1222:	4d10      	ldr	r5, [pc, #64]	; (1264 <prvAddCurrentTaskToDelayedList+0x64>)
    1224:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    1226:	4b0d      	ldr	r3, [pc, #52]	; (125c <prvAddCurrentTaskToDelayedList+0x5c>)
    1228:	6d99      	ldr	r1, [r3, #88]	; 0x58
    122a:	3104      	adds	r1, #4
    122c:	4b0e      	ldr	r3, [pc, #56]	; (1268 <prvAddCurrentTaskToDelayedList+0x68>)
    122e:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    1230:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    1232:	429c      	cmp	r4, r3
    1234:	d211      	bcs.n	125a <prvAddCurrentTaskToDelayedList+0x5a>
				{
					xNextTaskUnblockTime = xTimeToWake;
    1236:	4b0b      	ldr	r3, [pc, #44]	; (1264 <prvAddCurrentTaskToDelayedList+0x64>)
    1238:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    123a:	e00e      	b.n	125a <prvAddCurrentTaskToDelayedList+0x5a>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    123c:	2d00      	cmp	r5, #0
    123e:	d0ea      	beq.n	1216 <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1240:	4b06      	ldr	r3, [pc, #24]	; (125c <prvAddCurrentTaskToDelayedList+0x5c>)
    1242:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1244:	3104      	adds	r1, #4
    1246:	4807      	ldr	r0, [pc, #28]	; (1264 <prvAddCurrentTaskToDelayedList+0x64>)
    1248:	4b08      	ldr	r3, [pc, #32]	; (126c <prvAddCurrentTaskToDelayedList+0x6c>)
    124a:	4798      	blx	r3
    124c:	e005      	b.n	125a <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    124e:	4b03      	ldr	r3, [pc, #12]	; (125c <prvAddCurrentTaskToDelayedList+0x5c>)
    1250:	6d18      	ldr	r0, [r3, #80]	; 0x50
    1252:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1254:	3104      	adds	r1, #4
    1256:	4b04      	ldr	r3, [pc, #16]	; (1268 <prvAddCurrentTaskToDelayedList+0x68>)
    1258:	4798      	blx	r3
}
    125a:	bd70      	pop	{r4, r5, r6, pc}
    125c:	20004388 	.word	0x20004388
    1260:	00000375 	.word	0x00000375
    1264:	20004308 	.word	0x20004308
    1268:	00000345 	.word	0x00000345
    126c:	0000032d 	.word	0x0000032d

00001270 <xTaskCreate>:
	{
    1270:	b5f0      	push	{r4, r5, r6, r7, lr}
    1272:	b087      	sub	sp, #28
    1274:	9004      	str	r0, [sp, #16]
    1276:	9105      	str	r1, [sp, #20]
    1278:	0014      	movs	r4, r2
    127a:	001f      	movs	r7, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    127c:	0090      	lsls	r0, r2, #2
    127e:	4b14      	ldr	r3, [pc, #80]	; (12d0 <xTaskCreate+0x60>)
    1280:	4798      	blx	r3
    1282:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
    1284:	d01e      	beq.n	12c4 <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1286:	2054      	movs	r0, #84	; 0x54
    1288:	4b11      	ldr	r3, [pc, #68]	; (12d0 <xTaskCreate+0x60>)
    128a:	4798      	blx	r3
    128c:	1e05      	subs	r5, r0, #0
				if( pxNewTCB != NULL )
    128e:	d015      	beq.n	12bc <xTaskCreate+0x4c>
					pxNewTCB->pxStack = pxStack;
    1290:	6306      	str	r6, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
    1292:	2d00      	cmp	r5, #0
    1294:	d018      	beq.n	12c8 <xTaskCreate+0x58>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    1296:	2300      	movs	r3, #0
    1298:	9303      	str	r3, [sp, #12]
    129a:	9502      	str	r5, [sp, #8]
    129c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    129e:	9301      	str	r3, [sp, #4]
    12a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    12a2:	9300      	str	r3, [sp, #0]
    12a4:	003b      	movs	r3, r7
    12a6:	0022      	movs	r2, r4
    12a8:	9905      	ldr	r1, [sp, #20]
    12aa:	9804      	ldr	r0, [sp, #16]
    12ac:	4c09      	ldr	r4, [pc, #36]	; (12d4 <xTaskCreate+0x64>)
    12ae:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
    12b0:	0028      	movs	r0, r5
    12b2:	4b09      	ldr	r3, [pc, #36]	; (12d8 <xTaskCreate+0x68>)
    12b4:	4798      	blx	r3
			xReturn = pdPASS;
    12b6:	2001      	movs	r0, #1
	}
    12b8:	b007      	add	sp, #28
    12ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
    12bc:	0030      	movs	r0, r6
    12be:	4b07      	ldr	r3, [pc, #28]	; (12dc <xTaskCreate+0x6c>)
    12c0:	4798      	blx	r3
    12c2:	e7e6      	b.n	1292 <xTaskCreate+0x22>
				pxNewTCB = NULL;
    12c4:	2500      	movs	r5, #0
    12c6:	e7e4      	b.n	1292 <xTaskCreate+0x22>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    12c8:	2001      	movs	r0, #1
    12ca:	4240      	negs	r0, r0
		return xReturn;
    12cc:	e7f4      	b.n	12b8 <xTaskCreate+0x48>
    12ce:	46c0      	nop			; (mov r8, r8)
    12d0:	00000219 	.word	0x00000219
    12d4:	00000ff1 	.word	0x00000ff1
    12d8:	000010f9 	.word	0x000010f9
    12dc:	000002c9 	.word	0x000002c9

000012e0 <vTaskStartScheduler>:
{
    12e0:	b510      	push	{r4, lr}
    12e2:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
    12e4:	4b11      	ldr	r3, [pc, #68]	; (132c <vTaskStartScheduler+0x4c>)
    12e6:	3374      	adds	r3, #116	; 0x74
    12e8:	9301      	str	r3, [sp, #4]
    12ea:	2300      	movs	r3, #0
    12ec:	9300      	str	r3, [sp, #0]
    12ee:	2246      	movs	r2, #70	; 0x46
    12f0:	490f      	ldr	r1, [pc, #60]	; (1330 <vTaskStartScheduler+0x50>)
    12f2:	4810      	ldr	r0, [pc, #64]	; (1334 <vTaskStartScheduler+0x54>)
    12f4:	4c10      	ldr	r4, [pc, #64]	; (1338 <vTaskStartScheduler+0x58>)
    12f6:	47a0      	blx	r4
		if( xReturn == pdPASS )
    12f8:	2801      	cmp	r0, #1
    12fa:	d005      	beq.n	1308 <vTaskStartScheduler+0x28>
	if( xReturn == pdPASS )
    12fc:	2801      	cmp	r0, #1
    12fe:	d006      	beq.n	130e <vTaskStartScheduler+0x2e>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1300:	1c43      	adds	r3, r0, #1
    1302:	d011      	beq.n	1328 <vTaskStartScheduler+0x48>
}
    1304:	b002      	add	sp, #8
    1306:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    1308:	4b0c      	ldr	r3, [pc, #48]	; (133c <vTaskStartScheduler+0x5c>)
    130a:	4798      	blx	r3
    130c:	e7f6      	b.n	12fc <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    130e:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    1310:	2201      	movs	r2, #1
    1312:	4252      	negs	r2, r2
    1314:	4b0a      	ldr	r3, [pc, #40]	; (1340 <vTaskStartScheduler+0x60>)
    1316:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
    1318:	4b04      	ldr	r3, [pc, #16]	; (132c <vTaskStartScheduler+0x4c>)
    131a:	3202      	adds	r2, #2
    131c:	65da      	str	r2, [r3, #92]	; 0x5c
		xTickCount = ( TickType_t ) 0U;
    131e:	2200      	movs	r2, #0
    1320:	66da      	str	r2, [r3, #108]	; 0x6c
		if( xPortStartScheduler() != pdFALSE )
    1322:	4b08      	ldr	r3, [pc, #32]	; (1344 <vTaskStartScheduler+0x64>)
    1324:	4798      	blx	r3
    1326:	e7ed      	b.n	1304 <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1328:	b672      	cpsid	i
    132a:	e7fe      	b.n	132a <vTaskStartScheduler+0x4a>
    132c:	20004388 	.word	0x20004388
    1330:	00001fa0 	.word	0x00001fa0
    1334:	000011e1 	.word	0x000011e1
    1338:	00001271 	.word	0x00001271
    133c:	00001905 	.word	0x00001905
    1340:	20004308 	.word	0x20004308
    1344:	0000072d 	.word	0x0000072d

00001348 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    1348:	4a02      	ldr	r2, [pc, #8]	; (1354 <vTaskSuspendAll+0xc>)
    134a:	6f13      	ldr	r3, [r2, #112]	; 0x70
    134c:	3301      	adds	r3, #1
    134e:	6713      	str	r3, [r2, #112]	; 0x70
}
    1350:	4770      	bx	lr
    1352:	46c0      	nop			; (mov r8, r8)
    1354:	20004388 	.word	0x20004388

00001358 <xTaskGetTickCount>:
		xTicks = xTickCount;
    1358:	4b01      	ldr	r3, [pc, #4]	; (1360 <xTaskGetTickCount+0x8>)
    135a:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
}
    135c:	4770      	bx	lr
    135e:	46c0      	nop			; (mov r8, r8)
    1360:	20004388 	.word	0x20004388

00001364 <xTaskIncrementTick>:
{
    1364:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1366:	4b3c      	ldr	r3, [pc, #240]	; (1458 <xTaskIncrementTick+0xf4>)
    1368:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    136a:	2b00      	cmp	r3, #0
    136c:	d167      	bne.n	143e <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    136e:	4b3a      	ldr	r3, [pc, #232]	; (1458 <xTaskIncrementTick+0xf4>)
    1370:	6edd      	ldr	r5, [r3, #108]	; 0x6c
    1372:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
    1374:	66dd      	str	r5, [r3, #108]	; 0x6c
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1376:	2d00      	cmp	r5, #0
    1378:	d111      	bne.n	139e <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
    137a:	4b38      	ldr	r3, [pc, #224]	; (145c <xTaskIncrementTick+0xf8>)
    137c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    137e:	681b      	ldr	r3, [r3, #0]
    1380:	2b00      	cmp	r3, #0
    1382:	d001      	beq.n	1388 <xTaskIncrementTick+0x24>
    1384:	b672      	cpsid	i
    1386:	e7fe      	b.n	1386 <xTaskIncrementTick+0x22>
    1388:	4a34      	ldr	r2, [pc, #208]	; (145c <xTaskIncrementTick+0xf8>)
    138a:	6a91      	ldr	r1, [r2, #40]	; 0x28
    138c:	4b32      	ldr	r3, [pc, #200]	; (1458 <xTaskIncrementTick+0xf4>)
    138e:	6d18      	ldr	r0, [r3, #80]	; 0x50
    1390:	6290      	str	r0, [r2, #40]	; 0x28
    1392:	6519      	str	r1, [r3, #80]	; 0x50
    1394:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1396:	3201      	adds	r2, #1
    1398:	679a      	str	r2, [r3, #120]	; 0x78
    139a:	4b31      	ldr	r3, [pc, #196]	; (1460 <xTaskIncrementTick+0xfc>)
    139c:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    139e:	4b2f      	ldr	r3, [pc, #188]	; (145c <xTaskIncrementTick+0xf8>)
    13a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    13a2:	429d      	cmp	r5, r3
    13a4:	d23f      	bcs.n	1426 <xTaskIncrementTick+0xc2>
BaseType_t xSwitchRequired = pdFALSE;
    13a6:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    13a8:	4b2b      	ldr	r3, [pc, #172]	; (1458 <xTaskIncrementTick+0xf4>)
    13aa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    13ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    13ae:	0093      	lsls	r3, r2, #2
    13b0:	189b      	adds	r3, r3, r2
    13b2:	009a      	lsls	r2, r3, #2
    13b4:	4b29      	ldr	r3, [pc, #164]	; (145c <xTaskIncrementTick+0xf8>)
    13b6:	189b      	adds	r3, r3, r2
    13b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    13ba:	2b01      	cmp	r3, #1
    13bc:	d944      	bls.n	1448 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    13be:	2401      	movs	r4, #1
    13c0:	e042      	b.n	1448 <xTaskIncrementTick+0xe4>
							xSwitchRequired = pdTRUE;
    13c2:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    13c4:	4b25      	ldr	r3, [pc, #148]	; (145c <xTaskIncrementTick+0xf8>)
    13c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    13c8:	681b      	ldr	r3, [r3, #0]
    13ca:	2b00      	cmp	r3, #0
    13cc:	d02d      	beq.n	142a <xTaskIncrementTick+0xc6>
    13ce:	2300      	movs	r3, #0
    13d0:	2b00      	cmp	r3, #0
    13d2:	d12c      	bne.n	142e <xTaskIncrementTick+0xca>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    13d4:	4b21      	ldr	r3, [pc, #132]	; (145c <xTaskIncrementTick+0xf8>)
    13d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    13d8:	68db      	ldr	r3, [r3, #12]
    13da:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    13dc:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
    13de:	429d      	cmp	r5, r3
    13e0:	d32a      	bcc.n	1438 <xTaskIncrementTick+0xd4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    13e2:	1d37      	adds	r7, r6, #4
    13e4:	0038      	movs	r0, r7
    13e6:	4b1f      	ldr	r3, [pc, #124]	; (1464 <xTaskIncrementTick+0x100>)
    13e8:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    13ea:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    13ec:	2b00      	cmp	r3, #0
    13ee:	d003      	beq.n	13f8 <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    13f0:	0030      	movs	r0, r6
    13f2:	3018      	adds	r0, #24
    13f4:	4b1b      	ldr	r3, [pc, #108]	; (1464 <xTaskIncrementTick+0x100>)
    13f6:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    13f8:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    13fa:	4b17      	ldr	r3, [pc, #92]	; (1458 <xTaskIncrementTick+0xf4>)
    13fc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    13fe:	429a      	cmp	r2, r3
    1400:	d901      	bls.n	1406 <xTaskIncrementTick+0xa2>
    1402:	4b15      	ldr	r3, [pc, #84]	; (1458 <xTaskIncrementTick+0xf4>)
    1404:	665a      	str	r2, [r3, #100]	; 0x64
    1406:	0093      	lsls	r3, r2, #2
    1408:	189b      	adds	r3, r3, r2
    140a:	009a      	lsls	r2, r3, #2
    140c:	4813      	ldr	r0, [pc, #76]	; (145c <xTaskIncrementTick+0xf8>)
    140e:	3030      	adds	r0, #48	; 0x30
    1410:	1880      	adds	r0, r0, r2
    1412:	0039      	movs	r1, r7
    1414:	4b14      	ldr	r3, [pc, #80]	; (1468 <xTaskIncrementTick+0x104>)
    1416:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1418:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    141a:	4b0f      	ldr	r3, [pc, #60]	; (1458 <xTaskIncrementTick+0xf4>)
    141c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    141e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1420:	429a      	cmp	r2, r3
    1422:	d2ce      	bcs.n	13c2 <xTaskIncrementTick+0x5e>
    1424:	e7ce      	b.n	13c4 <xTaskIncrementTick+0x60>
    1426:	2400      	movs	r4, #0
    1428:	e7cc      	b.n	13c4 <xTaskIncrementTick+0x60>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    142a:	3301      	adds	r3, #1
    142c:	e7d0      	b.n	13d0 <xTaskIncrementTick+0x6c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    142e:	2201      	movs	r2, #1
    1430:	4252      	negs	r2, r2
    1432:	4b0a      	ldr	r3, [pc, #40]	; (145c <xTaskIncrementTick+0xf8>)
    1434:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
    1436:	e7b7      	b.n	13a8 <xTaskIncrementTick+0x44>
						xNextTaskUnblockTime = xItemValue;
    1438:	4a08      	ldr	r2, [pc, #32]	; (145c <xTaskIncrementTick+0xf8>)
    143a:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    143c:	e7b4      	b.n	13a8 <xTaskIncrementTick+0x44>
		++uxPendedTicks;
    143e:	4a06      	ldr	r2, [pc, #24]	; (1458 <xTaskIncrementTick+0xf4>)
    1440:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    1442:	3301      	adds	r3, #1
    1444:	67d3      	str	r3, [r2, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    1446:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    1448:	4b08      	ldr	r3, [pc, #32]	; (146c <xTaskIncrementTick+0x108>)
    144a:	681b      	ldr	r3, [r3, #0]
    144c:	2b00      	cmp	r3, #0
    144e:	d000      	beq.n	1452 <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    1450:	2401      	movs	r4, #1
}
    1452:	0020      	movs	r0, r4
    1454:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1456:	46c0      	nop			; (mov r8, r8)
    1458:	20004388 	.word	0x20004388
    145c:	20004308 	.word	0x20004308
    1460:	00000fad 	.word	0x00000fad
    1464:	00000375 	.word	0x00000375
    1468:	0000032d 	.word	0x0000032d
    146c:	20004408 	.word	0x20004408

00001470 <xTaskResumeAll>:
{
    1470:	b570      	push	{r4, r5, r6, lr}
	configASSERT( uxSchedulerSuspended );
    1472:	4b32      	ldr	r3, [pc, #200]	; (153c <xTaskResumeAll+0xcc>)
    1474:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1476:	2b00      	cmp	r3, #0
    1478:	d101      	bne.n	147e <xTaskResumeAll+0xe>
    147a:	b672      	cpsid	i
    147c:	e7fe      	b.n	147c <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
    147e:	4b30      	ldr	r3, [pc, #192]	; (1540 <xTaskResumeAll+0xd0>)
    1480:	4798      	blx	r3
		--uxSchedulerSuspended;
    1482:	4b2e      	ldr	r3, [pc, #184]	; (153c <xTaskResumeAll+0xcc>)
    1484:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    1486:	3a01      	subs	r2, #1
    1488:	671a      	str	r2, [r3, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    148a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    148c:	2b00      	cmp	r3, #0
    148e:	d150      	bne.n	1532 <xTaskResumeAll+0xc2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1490:	4b2a      	ldr	r3, [pc, #168]	; (153c <xTaskResumeAll+0xcc>)
    1492:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    1494:	2b00      	cmp	r3, #0
    1496:	d104      	bne.n	14a2 <xTaskResumeAll+0x32>
BaseType_t xAlreadyYielded = pdFALSE;
    1498:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    149a:	4b2a      	ldr	r3, [pc, #168]	; (1544 <xTaskResumeAll+0xd4>)
    149c:	4798      	blx	r3
}
    149e:	0020      	movs	r0, r4
    14a0:	bd70      	pop	{r4, r5, r6, pc}
    14a2:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    14a4:	4b28      	ldr	r3, [pc, #160]	; (1548 <xTaskResumeAll+0xd8>)
    14a6:	695b      	ldr	r3, [r3, #20]
    14a8:	2b00      	cmp	r3, #0
    14aa:	d023      	beq.n	14f4 <xTaskResumeAll+0x84>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    14ac:	4b26      	ldr	r3, [pc, #152]	; (1548 <xTaskResumeAll+0xd8>)
    14ae:	6a1b      	ldr	r3, [r3, #32]
    14b0:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    14b2:	0020      	movs	r0, r4
    14b4:	3018      	adds	r0, #24
    14b6:	4e25      	ldr	r6, [pc, #148]	; (154c <xTaskResumeAll+0xdc>)
    14b8:	47b0      	blx	r6
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    14ba:	1d25      	adds	r5, r4, #4
    14bc:	0028      	movs	r0, r5
    14be:	47b0      	blx	r6
					prvAddTaskToReadyList( pxTCB );
    14c0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    14c2:	4b1e      	ldr	r3, [pc, #120]	; (153c <xTaskResumeAll+0xcc>)
    14c4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    14c6:	429a      	cmp	r2, r3
    14c8:	d901      	bls.n	14ce <xTaskResumeAll+0x5e>
    14ca:	4b1c      	ldr	r3, [pc, #112]	; (153c <xTaskResumeAll+0xcc>)
    14cc:	665a      	str	r2, [r3, #100]	; 0x64
    14ce:	0093      	lsls	r3, r2, #2
    14d0:	189b      	adds	r3, r3, r2
    14d2:	009a      	lsls	r2, r3, #2
    14d4:	481c      	ldr	r0, [pc, #112]	; (1548 <xTaskResumeAll+0xd8>)
    14d6:	3030      	adds	r0, #48	; 0x30
    14d8:	1880      	adds	r0, r0, r2
    14da:	0029      	movs	r1, r5
    14dc:	4b1c      	ldr	r3, [pc, #112]	; (1550 <xTaskResumeAll+0xe0>)
    14de:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    14e0:	4b16      	ldr	r3, [pc, #88]	; (153c <xTaskResumeAll+0xcc>)
    14e2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    14e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    14e6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    14e8:	429a      	cmp	r2, r3
    14ea:	d3db      	bcc.n	14a4 <xTaskResumeAll+0x34>
						xYieldPending = pdTRUE;
    14ec:	2201      	movs	r2, #1
    14ee:	4b19      	ldr	r3, [pc, #100]	; (1554 <xTaskResumeAll+0xe4>)
    14f0:	601a      	str	r2, [r3, #0]
    14f2:	e7d7      	b.n	14a4 <xTaskResumeAll+0x34>
				if( pxTCB != NULL )
    14f4:	2c00      	cmp	r4, #0
    14f6:	d001      	beq.n	14fc <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
    14f8:	4b17      	ldr	r3, [pc, #92]	; (1558 <xTaskResumeAll+0xe8>)
    14fa:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    14fc:	4b0f      	ldr	r3, [pc, #60]	; (153c <xTaskResumeAll+0xcc>)
    14fe:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1500:	2c00      	cmp	r4, #0
    1502:	d10a      	bne.n	151a <xTaskResumeAll+0xaa>
				if( xYieldPending != pdFALSE )
    1504:	4b13      	ldr	r3, [pc, #76]	; (1554 <xTaskResumeAll+0xe4>)
    1506:	681b      	ldr	r3, [r3, #0]
    1508:	2b00      	cmp	r3, #0
    150a:	d014      	beq.n	1536 <xTaskResumeAll+0xc6>
					taskYIELD_IF_USING_PREEMPTION();
    150c:	4b13      	ldr	r3, [pc, #76]	; (155c <xTaskResumeAll+0xec>)
    150e:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    1510:	2401      	movs	r4, #1
    1512:	e7c2      	b.n	149a <xTaskResumeAll+0x2a>
							--uxPendedCounts;
    1514:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1516:	2c00      	cmp	r4, #0
    1518:	d007      	beq.n	152a <xTaskResumeAll+0xba>
							if( xTaskIncrementTick() != pdFALSE )
    151a:	4b11      	ldr	r3, [pc, #68]	; (1560 <xTaskResumeAll+0xf0>)
    151c:	4798      	blx	r3
    151e:	2800      	cmp	r0, #0
    1520:	d0f8      	beq.n	1514 <xTaskResumeAll+0xa4>
								xYieldPending = pdTRUE;
    1522:	2201      	movs	r2, #1
    1524:	4b0b      	ldr	r3, [pc, #44]	; (1554 <xTaskResumeAll+0xe4>)
    1526:	601a      	str	r2, [r3, #0]
    1528:	e7f4      	b.n	1514 <xTaskResumeAll+0xa4>
						uxPendedTicks = 0;
    152a:	2200      	movs	r2, #0
    152c:	4b03      	ldr	r3, [pc, #12]	; (153c <xTaskResumeAll+0xcc>)
    152e:	67da      	str	r2, [r3, #124]	; 0x7c
    1530:	e7e8      	b.n	1504 <xTaskResumeAll+0x94>
BaseType_t xAlreadyYielded = pdFALSE;
    1532:	2400      	movs	r4, #0
    1534:	e7b1      	b.n	149a <xTaskResumeAll+0x2a>
    1536:	2400      	movs	r4, #0
    1538:	e7af      	b.n	149a <xTaskResumeAll+0x2a>
    153a:	46c0      	nop			; (mov r8, r8)
    153c:	20004388 	.word	0x20004388
    1540:	00000791 	.word	0x00000791
    1544:	000007a9 	.word	0x000007a9
    1548:	20004308 	.word	0x20004308
    154c:	00000375 	.word	0x00000375
    1550:	0000032d 	.word	0x0000032d
    1554:	20004408 	.word	0x20004408
    1558:	00000fad 	.word	0x00000fad
    155c:	00000779 	.word	0x00000779
    1560:	00001365 	.word	0x00001365

00001564 <vTaskDelay>:
	{
    1564:	b510      	push	{r4, lr}
    1566:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
    1568:	d00e      	beq.n	1588 <vTaskDelay+0x24>
			configASSERT( uxSchedulerSuspended == 0 );
    156a:	4b0a      	ldr	r3, [pc, #40]	; (1594 <vTaskDelay+0x30>)
    156c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    156e:	2b00      	cmp	r3, #0
    1570:	d001      	beq.n	1576 <vTaskDelay+0x12>
    1572:	b672      	cpsid	i
    1574:	e7fe      	b.n	1574 <vTaskDelay+0x10>
			vTaskSuspendAll();
    1576:	4b08      	ldr	r3, [pc, #32]	; (1598 <vTaskDelay+0x34>)
    1578:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    157a:	2100      	movs	r1, #0
    157c:	0020      	movs	r0, r4
    157e:	4b07      	ldr	r3, [pc, #28]	; (159c <vTaskDelay+0x38>)
    1580:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
    1582:	4b07      	ldr	r3, [pc, #28]	; (15a0 <vTaskDelay+0x3c>)
    1584:	4798      	blx	r3
    1586:	e000      	b.n	158a <vTaskDelay+0x26>
	BaseType_t xAlreadyYielded = pdFALSE;
    1588:	2000      	movs	r0, #0
		if( xAlreadyYielded == pdFALSE )
    158a:	2800      	cmp	r0, #0
    158c:	d101      	bne.n	1592 <vTaskDelay+0x2e>
			portYIELD_WITHIN_API();
    158e:	4b05      	ldr	r3, [pc, #20]	; (15a4 <vTaskDelay+0x40>)
    1590:	4798      	blx	r3
	}
    1592:	bd10      	pop	{r4, pc}
    1594:	20004388 	.word	0x20004388
    1598:	00001349 	.word	0x00001349
    159c:	00001201 	.word	0x00001201
    15a0:	00001471 	.word	0x00001471
    15a4:	00000779 	.word	0x00000779

000015a8 <vTaskSwitchContext>:
{
    15a8:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    15aa:	4b1d      	ldr	r3, [pc, #116]	; (1620 <vTaskSwitchContext+0x78>)
    15ac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    15ae:	2b00      	cmp	r3, #0
    15b0:	d110      	bne.n	15d4 <vTaskSwitchContext+0x2c>
		xYieldPending = pdFALSE;
    15b2:	2200      	movs	r2, #0
    15b4:	4b1b      	ldr	r3, [pc, #108]	; (1624 <vTaskSwitchContext+0x7c>)
    15b6:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    15b8:	4b19      	ldr	r3, [pc, #100]	; (1620 <vTaskSwitchContext+0x78>)
    15ba:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    15bc:	009a      	lsls	r2, r3, #2
    15be:	18d2      	adds	r2, r2, r3
    15c0:	0091      	lsls	r1, r2, #2
    15c2:	4a19      	ldr	r2, [pc, #100]	; (1628 <vTaskSwitchContext+0x80>)
    15c4:	1852      	adds	r2, r2, r1
    15c6:	6b12      	ldr	r2, [r2, #48]	; 0x30
    15c8:	2a00      	cmp	r2, #0
    15ca:	d109      	bne.n	15e0 <vTaskSwitchContext+0x38>
    15cc:	2b00      	cmp	r3, #0
    15ce:	d005      	beq.n	15dc <vTaskSwitchContext+0x34>
    15d0:	3b01      	subs	r3, #1
    15d2:	e7f3      	b.n	15bc <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
    15d4:	2201      	movs	r2, #1
    15d6:	4b13      	ldr	r3, [pc, #76]	; (1624 <vTaskSwitchContext+0x7c>)
    15d8:	601a      	str	r2, [r3, #0]
}
    15da:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    15dc:	b672      	cpsid	i
    15de:	e7fe      	b.n	15de <vTaskSwitchContext+0x36>
    15e0:	4a11      	ldr	r2, [pc, #68]	; (1628 <vTaskSwitchContext+0x80>)
    15e2:	0099      	lsls	r1, r3, #2
    15e4:	18cc      	adds	r4, r1, r3
    15e6:	00a0      	lsls	r0, r4, #2
    15e8:	1810      	adds	r0, r2, r0
    15ea:	6b44      	ldr	r4, [r0, #52]	; 0x34
    15ec:	6864      	ldr	r4, [r4, #4]
    15ee:	6344      	str	r4, [r0, #52]	; 0x34
    15f0:	3230      	adds	r2, #48	; 0x30
    15f2:	18c9      	adds	r1, r1, r3
    15f4:	0088      	lsls	r0, r1, #2
    15f6:	3008      	adds	r0, #8
    15f8:	1812      	adds	r2, r2, r0
    15fa:	4294      	cmp	r4, r2
    15fc:	d00a      	beq.n	1614 <vTaskSwitchContext+0x6c>
    15fe:	009a      	lsls	r2, r3, #2
    1600:	18d2      	adds	r2, r2, r3
    1602:	0091      	lsls	r1, r2, #2
    1604:	4a08      	ldr	r2, [pc, #32]	; (1628 <vTaskSwitchContext+0x80>)
    1606:	1852      	adds	r2, r2, r1
    1608:	6b52      	ldr	r2, [r2, #52]	; 0x34
    160a:	68d1      	ldr	r1, [r2, #12]
    160c:	4a04      	ldr	r2, [pc, #16]	; (1620 <vTaskSwitchContext+0x78>)
    160e:	6591      	str	r1, [r2, #88]	; 0x58
    1610:	6653      	str	r3, [r2, #100]	; 0x64
}
    1612:	e7e2      	b.n	15da <vTaskSwitchContext+0x32>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1614:	6860      	ldr	r0, [r4, #4]
    1616:	0089      	lsls	r1, r1, #2
    1618:	4a03      	ldr	r2, [pc, #12]	; (1628 <vTaskSwitchContext+0x80>)
    161a:	1852      	adds	r2, r2, r1
    161c:	6350      	str	r0, [r2, #52]	; 0x34
    161e:	e7ee      	b.n	15fe <vTaskSwitchContext+0x56>
    1620:	20004388 	.word	0x20004388
    1624:	20004408 	.word	0x20004408
    1628:	20004308 	.word	0x20004308

0000162c <vTaskPlaceOnEventList>:
{
    162c:	b510      	push	{r4, lr}
    162e:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    1630:	2800      	cmp	r0, #0
    1632:	d101      	bne.n	1638 <vTaskPlaceOnEventList+0xc>
    1634:	b672      	cpsid	i
    1636:	e7fe      	b.n	1636 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1638:	4b04      	ldr	r3, [pc, #16]	; (164c <vTaskPlaceOnEventList+0x20>)
    163a:	6d99      	ldr	r1, [r3, #88]	; 0x58
    163c:	3118      	adds	r1, #24
    163e:	4b04      	ldr	r3, [pc, #16]	; (1650 <vTaskPlaceOnEventList+0x24>)
    1640:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1642:	2101      	movs	r1, #1
    1644:	0020      	movs	r0, r4
    1646:	4b03      	ldr	r3, [pc, #12]	; (1654 <vTaskPlaceOnEventList+0x28>)
    1648:	4798      	blx	r3
}
    164a:	bd10      	pop	{r4, pc}
    164c:	20004388 	.word	0x20004388
    1650:	00000345 	.word	0x00000345
    1654:	00001201 	.word	0x00001201

00001658 <vTaskPlaceOnEventListRestricted>:
	{
    1658:	b570      	push	{r4, r5, r6, lr}
    165a:	000c      	movs	r4, r1
    165c:	0015      	movs	r5, r2
		configASSERT( pxEventList );
    165e:	2800      	cmp	r0, #0
    1660:	d00d      	beq.n	167e <vTaskPlaceOnEventListRestricted+0x26>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1662:	4b08      	ldr	r3, [pc, #32]	; (1684 <vTaskPlaceOnEventListRestricted+0x2c>)
    1664:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1666:	3118      	adds	r1, #24
    1668:	4b07      	ldr	r3, [pc, #28]	; (1688 <vTaskPlaceOnEventListRestricted+0x30>)
    166a:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
    166c:	2d00      	cmp	r5, #0
    166e:	d001      	beq.n	1674 <vTaskPlaceOnEventListRestricted+0x1c>
			xTicksToWait = portMAX_DELAY;
    1670:	2401      	movs	r4, #1
    1672:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    1674:	0029      	movs	r1, r5
    1676:	0020      	movs	r0, r4
    1678:	4b04      	ldr	r3, [pc, #16]	; (168c <vTaskPlaceOnEventListRestricted+0x34>)
    167a:	4798      	blx	r3
	}
    167c:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxEventList );
    167e:	b672      	cpsid	i
    1680:	e7fe      	b.n	1680 <vTaskPlaceOnEventListRestricted+0x28>
    1682:	46c0      	nop			; (mov r8, r8)
    1684:	20004388 	.word	0x20004388
    1688:	0000032d 	.word	0x0000032d
    168c:	00001201 	.word	0x00001201

00001690 <xTaskRemoveFromEventList>:
{
    1690:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1692:	68c3      	ldr	r3, [r0, #12]
    1694:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    1696:	2c00      	cmp	r4, #0
    1698:	d027      	beq.n	16ea <xTaskRemoveFromEventList+0x5a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    169a:	0025      	movs	r5, r4
    169c:	3518      	adds	r5, #24
    169e:	0028      	movs	r0, r5
    16a0:	4b17      	ldr	r3, [pc, #92]	; (1700 <xTaskRemoveFromEventList+0x70>)
    16a2:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    16a4:	4b17      	ldr	r3, [pc, #92]	; (1704 <xTaskRemoveFromEventList+0x74>)
    16a6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    16a8:	2b00      	cmp	r3, #0
    16aa:	d120      	bne.n	16ee <xTaskRemoveFromEventList+0x5e>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    16ac:	1d25      	adds	r5, r4, #4
    16ae:	0028      	movs	r0, r5
    16b0:	4b13      	ldr	r3, [pc, #76]	; (1700 <xTaskRemoveFromEventList+0x70>)
    16b2:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    16b4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    16b6:	4b13      	ldr	r3, [pc, #76]	; (1704 <xTaskRemoveFromEventList+0x74>)
    16b8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    16ba:	429a      	cmp	r2, r3
    16bc:	d901      	bls.n	16c2 <xTaskRemoveFromEventList+0x32>
    16be:	4b11      	ldr	r3, [pc, #68]	; (1704 <xTaskRemoveFromEventList+0x74>)
    16c0:	665a      	str	r2, [r3, #100]	; 0x64
    16c2:	0093      	lsls	r3, r2, #2
    16c4:	189b      	adds	r3, r3, r2
    16c6:	009a      	lsls	r2, r3, #2
    16c8:	480f      	ldr	r0, [pc, #60]	; (1708 <xTaskRemoveFromEventList+0x78>)
    16ca:	3030      	adds	r0, #48	; 0x30
    16cc:	1880      	adds	r0, r0, r2
    16ce:	0029      	movs	r1, r5
    16d0:	4b0e      	ldr	r3, [pc, #56]	; (170c <xTaskRemoveFromEventList+0x7c>)
    16d2:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    16d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    16d6:	4b0b      	ldr	r3, [pc, #44]	; (1704 <xTaskRemoveFromEventList+0x74>)
    16d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    16da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16dc:	429a      	cmp	r2, r3
    16de:	d90c      	bls.n	16fa <xTaskRemoveFromEventList+0x6a>
		xYieldPending = pdTRUE;
    16e0:	2201      	movs	r2, #1
    16e2:	4b0b      	ldr	r3, [pc, #44]	; (1710 <xTaskRemoveFromEventList+0x80>)
    16e4:	601a      	str	r2, [r3, #0]
		xReturn = pdTRUE;
    16e6:	2001      	movs	r0, #1
}
    16e8:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxUnblockedTCB );
    16ea:	b672      	cpsid	i
    16ec:	e7fe      	b.n	16ec <xTaskRemoveFromEventList+0x5c>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    16ee:	0029      	movs	r1, r5
    16f0:	4805      	ldr	r0, [pc, #20]	; (1708 <xTaskRemoveFromEventList+0x78>)
    16f2:	3014      	adds	r0, #20
    16f4:	4b05      	ldr	r3, [pc, #20]	; (170c <xTaskRemoveFromEventList+0x7c>)
    16f6:	4798      	blx	r3
    16f8:	e7ec      	b.n	16d4 <xTaskRemoveFromEventList+0x44>
		xReturn = pdFALSE;
    16fa:	2000      	movs	r0, #0
	return xReturn;
    16fc:	e7f4      	b.n	16e8 <xTaskRemoveFromEventList+0x58>
    16fe:	46c0      	nop			; (mov r8, r8)
    1700:	00000375 	.word	0x00000375
    1704:	20004388 	.word	0x20004388
    1708:	20004308 	.word	0x20004308
    170c:	0000032d 	.word	0x0000032d
    1710:	20004408 	.word	0x20004408

00001714 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1714:	4b02      	ldr	r3, [pc, #8]	; (1720 <vTaskInternalSetTimeOutState+0xc>)
    1716:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1718:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    171a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    171c:	6043      	str	r3, [r0, #4]
}
    171e:	4770      	bx	lr
    1720:	20004388 	.word	0x20004388

00001724 <xTaskCheckForTimeOut>:
{
    1724:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1726:	0005      	movs	r5, r0
    1728:	000c      	movs	r4, r1
	configASSERT( pxTimeOut );
    172a:	2800      	cmp	r0, #0
    172c:	d01a      	beq.n	1764 <xTaskCheckForTimeOut+0x40>
	configASSERT( pxTicksToWait );
    172e:	2900      	cmp	r1, #0
    1730:	d01a      	beq.n	1768 <xTaskCheckForTimeOut+0x44>
	taskENTER_CRITICAL();
    1732:	4b14      	ldr	r3, [pc, #80]	; (1784 <xTaskCheckForTimeOut+0x60>)
    1734:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    1736:	4b14      	ldr	r3, [pc, #80]	; (1788 <xTaskCheckForTimeOut+0x64>)
    1738:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    173a:	6869      	ldr	r1, [r5, #4]
    173c:	1a42      	subs	r2, r0, r1
			if( *pxTicksToWait == portMAX_DELAY )
    173e:	6823      	ldr	r3, [r4, #0]
    1740:	1c5e      	adds	r6, r3, #1
    1742:	d01a      	beq.n	177a <xTaskCheckForTimeOut+0x56>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1744:	4e10      	ldr	r6, [pc, #64]	; (1788 <xTaskCheckForTimeOut+0x64>)
    1746:	6fb6      	ldr	r6, [r6, #120]	; 0x78
    1748:	682f      	ldr	r7, [r5, #0]
    174a:	42b7      	cmp	r7, r6
    174c:	d001      	beq.n	1752 <xTaskCheckForTimeOut+0x2e>
    174e:	4288      	cmp	r0, r1
    1750:	d215      	bcs.n	177e <xTaskCheckForTimeOut+0x5a>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1752:	429a      	cmp	r2, r3
    1754:	d30a      	bcc.n	176c <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait = 0;
    1756:	2300      	movs	r3, #0
    1758:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
    175a:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    175c:	4b0b      	ldr	r3, [pc, #44]	; (178c <xTaskCheckForTimeOut+0x68>)
    175e:	4798      	blx	r3
}
    1760:	0020      	movs	r0, r4
    1762:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	configASSERT( pxTimeOut );
    1764:	b672      	cpsid	i
    1766:	e7fe      	b.n	1766 <xTaskCheckForTimeOut+0x42>
	configASSERT( pxTicksToWait );
    1768:	b672      	cpsid	i
    176a:	e7fe      	b.n	176a <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= xElapsedTime;
    176c:	1a9b      	subs	r3, r3, r2
    176e:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    1770:	0028      	movs	r0, r5
    1772:	4b07      	ldr	r3, [pc, #28]	; (1790 <xTaskCheckForTimeOut+0x6c>)
    1774:	4798      	blx	r3
			xReturn = pdFALSE;
    1776:	2400      	movs	r4, #0
    1778:	e7f0      	b.n	175c <xTaskCheckForTimeOut+0x38>
				xReturn = pdFALSE;
    177a:	2400      	movs	r4, #0
    177c:	e7ee      	b.n	175c <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
    177e:	2401      	movs	r4, #1
    1780:	e7ec      	b.n	175c <xTaskCheckForTimeOut+0x38>
    1782:	46c0      	nop			; (mov r8, r8)
    1784:	00000791 	.word	0x00000791
    1788:	20004388 	.word	0x20004388
    178c:	000007a9 	.word	0x000007a9
    1790:	00001715 	.word	0x00001715

00001794 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    1794:	2201      	movs	r2, #1
    1796:	4b01      	ldr	r3, [pc, #4]	; (179c <vTaskMissedYield+0x8>)
    1798:	601a      	str	r2, [r3, #0]
}
    179a:	4770      	bx	lr
    179c:	20004408 	.word	0x20004408

000017a0 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    17a0:	4b06      	ldr	r3, [pc, #24]	; (17bc <xTaskGetSchedulerState+0x1c>)
    17a2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    17a4:	2b00      	cmp	r3, #0
    17a6:	d005      	beq.n	17b4 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    17a8:	4b04      	ldr	r3, [pc, #16]	; (17bc <xTaskGetSchedulerState+0x1c>)
    17aa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    17ac:	2b00      	cmp	r3, #0
    17ae:	d103      	bne.n	17b8 <xTaskGetSchedulerState+0x18>
				xReturn = taskSCHEDULER_RUNNING;
    17b0:	2002      	movs	r0, #2
	}
    17b2:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
    17b4:	2001      	movs	r0, #1
    17b6:	e7fc      	b.n	17b2 <xTaskGetSchedulerState+0x12>
				xReturn = taskSCHEDULER_SUSPENDED;
    17b8:	2000      	movs	r0, #0
		return xReturn;
    17ba:	e7fa      	b.n	17b2 <xTaskGetSchedulerState+0x12>
    17bc:	20004388 	.word	0x20004388

000017c0 <xTaskPriorityDisinherit>:
	{
    17c0:	b570      	push	{r4, r5, r6, lr}
    17c2:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    17c4:	d02c      	beq.n	1820 <xTaskPriorityDisinherit+0x60>
			configASSERT( pxTCB == pxCurrentTCB );
    17c6:	4b19      	ldr	r3, [pc, #100]	; (182c <xTaskPriorityDisinherit+0x6c>)
    17c8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    17ca:	4298      	cmp	r0, r3
    17cc:	d001      	beq.n	17d2 <xTaskPriorityDisinherit+0x12>
    17ce:	b672      	cpsid	i
    17d0:	e7fe      	b.n	17d0 <xTaskPriorityDisinherit+0x10>
			configASSERT( pxTCB->uxMutexesHeld );
    17d2:	6c83      	ldr	r3, [r0, #72]	; 0x48
    17d4:	2b00      	cmp	r3, #0
    17d6:	d101      	bne.n	17dc <xTaskPriorityDisinherit+0x1c>
    17d8:	b672      	cpsid	i
    17da:	e7fe      	b.n	17da <xTaskPriorityDisinherit+0x1a>
			( pxTCB->uxMutexesHeld )--;
    17dc:	3b01      	subs	r3, #1
    17de:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    17e0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    17e2:	6c41      	ldr	r1, [r0, #68]	; 0x44
    17e4:	428a      	cmp	r2, r1
    17e6:	d01d      	beq.n	1824 <xTaskPriorityDisinherit+0x64>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    17e8:	2b00      	cmp	r3, #0
    17ea:	d11d      	bne.n	1828 <xTaskPriorityDisinherit+0x68>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    17ec:	1d05      	adds	r5, r0, #4
    17ee:	0028      	movs	r0, r5
    17f0:	4b0f      	ldr	r3, [pc, #60]	; (1830 <xTaskPriorityDisinherit+0x70>)
    17f2:	4798      	blx	r3
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    17f4:	6c63      	ldr	r3, [r4, #68]	; 0x44
    17f6:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17f8:	2205      	movs	r2, #5
    17fa:	1ad2      	subs	r2, r2, r3
    17fc:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
    17fe:	4a0b      	ldr	r2, [pc, #44]	; (182c <xTaskPriorityDisinherit+0x6c>)
    1800:	6e52      	ldr	r2, [r2, #100]	; 0x64
    1802:	4293      	cmp	r3, r2
    1804:	d901      	bls.n	180a <xTaskPriorityDisinherit+0x4a>
    1806:	4a09      	ldr	r2, [pc, #36]	; (182c <xTaskPriorityDisinherit+0x6c>)
    1808:	6653      	str	r3, [r2, #100]	; 0x64
    180a:	009a      	lsls	r2, r3, #2
    180c:	18d3      	adds	r3, r2, r3
    180e:	009a      	lsls	r2, r3, #2
    1810:	4808      	ldr	r0, [pc, #32]	; (1834 <xTaskPriorityDisinherit+0x74>)
    1812:	3030      	adds	r0, #48	; 0x30
    1814:	1880      	adds	r0, r0, r2
    1816:	0029      	movs	r1, r5
    1818:	4b07      	ldr	r3, [pc, #28]	; (1838 <xTaskPriorityDisinherit+0x78>)
    181a:	4798      	blx	r3
					xReturn = pdTRUE;
    181c:	2001      	movs	r0, #1
	}
    181e:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xReturn = pdFALSE;
    1820:	2000      	movs	r0, #0
    1822:	e7fc      	b.n	181e <xTaskPriorityDisinherit+0x5e>
    1824:	2000      	movs	r0, #0
    1826:	e7fa      	b.n	181e <xTaskPriorityDisinherit+0x5e>
    1828:	2000      	movs	r0, #0
		return xReturn;
    182a:	e7f8      	b.n	181e <xTaskPriorityDisinherit+0x5e>
    182c:	20004388 	.word	0x20004388
    1830:	00000375 	.word	0x00000375
    1834:	20004308 	.word	0x20004308
    1838:	0000032d 	.word	0x0000032d

0000183c <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    183c:	4b06      	ldr	r3, [pc, #24]	; (1858 <prvGetNextExpireTime+0x1c>)
    183e:	681a      	ldr	r2, [r3, #0]
    1840:	6813      	ldr	r3, [r2, #0]
    1842:	4259      	negs	r1, r3
    1844:	414b      	adcs	r3, r1
    1846:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
    1848:	2b00      	cmp	r3, #0
    184a:	d102      	bne.n	1852 <prvGetNextExpireTime+0x16>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    184c:	68d3      	ldr	r3, [r2, #12]
    184e:	6818      	ldr	r0, [r3, #0]
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
	}

	return xNextExpireTime;
}
    1850:	4770      	bx	lr
		xNextExpireTime = ( TickType_t ) 0U;
    1852:	2000      	movs	r0, #0
	return xNextExpireTime;
    1854:	e7fc      	b.n	1850 <prvGetNextExpireTime+0x14>
    1856:	46c0      	nop			; (mov r8, r8)
    1858:	2000440c 	.word	0x2000440c

0000185c <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    185c:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    185e:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1860:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    1862:	4291      	cmp	r1, r2
    1864:	d80c      	bhi.n	1880 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1866:	1ad2      	subs	r2, r2, r3
    1868:	6983      	ldr	r3, [r0, #24]
    186a:	429a      	cmp	r2, r3
    186c:	d301      	bcc.n	1872 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    186e:	2001      	movs	r0, #1
    1870:	e010      	b.n	1894 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1872:	1d01      	adds	r1, r0, #4
    1874:	4b09      	ldr	r3, [pc, #36]	; (189c <prvInsertTimerInActiveList+0x40>)
    1876:	6858      	ldr	r0, [r3, #4]
    1878:	4b09      	ldr	r3, [pc, #36]	; (18a0 <prvInsertTimerInActiveList+0x44>)
    187a:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    187c:	2000      	movs	r0, #0
    187e:	e009      	b.n	1894 <prvInsertTimerInActiveList+0x38>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1880:	429a      	cmp	r2, r3
    1882:	d201      	bcs.n	1888 <prvInsertTimerInActiveList+0x2c>
    1884:	4299      	cmp	r1, r3
    1886:	d206      	bcs.n	1896 <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1888:	1d01      	adds	r1, r0, #4
    188a:	4b04      	ldr	r3, [pc, #16]	; (189c <prvInsertTimerInActiveList+0x40>)
    188c:	6818      	ldr	r0, [r3, #0]
    188e:	4b04      	ldr	r3, [pc, #16]	; (18a0 <prvInsertTimerInActiveList+0x44>)
    1890:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1892:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    1894:	bd10      	pop	{r4, pc}
			xProcessTimerNow = pdTRUE;
    1896:	2001      	movs	r0, #1
	return xProcessTimerNow;
    1898:	e7fc      	b.n	1894 <prvInsertTimerInActiveList+0x38>
    189a:	46c0      	nop			; (mov r8, r8)
    189c:	2000440c 	.word	0x2000440c
    18a0:	00000345 	.word	0x00000345

000018a4 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    18a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    18a6:	4b10      	ldr	r3, [pc, #64]	; (18e8 <prvCheckForValidListAndQueue+0x44>)
    18a8:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    18aa:	4b10      	ldr	r3, [pc, #64]	; (18ec <prvCheckForValidListAndQueue+0x48>)
    18ac:	689b      	ldr	r3, [r3, #8]
    18ae:	2b00      	cmp	r3, #0
    18b0:	d002      	beq.n	18b8 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    18b2:	4b0f      	ldr	r3, [pc, #60]	; (18f0 <prvCheckForValidListAndQueue+0x4c>)
    18b4:	4798      	blx	r3
}
    18b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    18b8:	4c0c      	ldr	r4, [pc, #48]	; (18ec <prvCheckForValidListAndQueue+0x48>)
    18ba:	0026      	movs	r6, r4
    18bc:	360c      	adds	r6, #12
    18be:	0030      	movs	r0, r6
    18c0:	4f0c      	ldr	r7, [pc, #48]	; (18f4 <prvCheckForValidListAndQueue+0x50>)
    18c2:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    18c4:	0025      	movs	r5, r4
    18c6:	3520      	adds	r5, #32
    18c8:	0028      	movs	r0, r5
    18ca:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
    18cc:	6026      	str	r6, [r4, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    18ce:	6065      	str	r5, [r4, #4]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    18d0:	2200      	movs	r2, #0
    18d2:	210c      	movs	r1, #12
    18d4:	2005      	movs	r0, #5
    18d6:	4b08      	ldr	r3, [pc, #32]	; (18f8 <prvCheckForValidListAndQueue+0x54>)
    18d8:	4798      	blx	r3
    18da:	60a0      	str	r0, [r4, #8]
				if( xTimerQueue != NULL )
    18dc:	2800      	cmp	r0, #0
    18de:	d0e8      	beq.n	18b2 <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    18e0:	4906      	ldr	r1, [pc, #24]	; (18fc <prvCheckForValidListAndQueue+0x58>)
    18e2:	4b07      	ldr	r3, [pc, #28]	; (1900 <prvCheckForValidListAndQueue+0x5c>)
    18e4:	4798      	blx	r3
    18e6:	e7e4      	b.n	18b2 <prvCheckForValidListAndQueue+0xe>
    18e8:	00000791 	.word	0x00000791
    18ec:	2000440c 	.word	0x2000440c
    18f0:	000007a9 	.word	0x000007a9
    18f4:	00000311 	.word	0x00000311
    18f8:	00000b09 	.word	0x00000b09
    18fc:	00001fe0 	.word	0x00001fe0
    1900:	00000f29 	.word	0x00000f29

00001904 <xTimerCreateTimerTask>:
{
    1904:	b510      	push	{r4, lr}
    1906:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    1908:	4b0c      	ldr	r3, [pc, #48]	; (193c <xTimerCreateTimerTask+0x38>)
    190a:	4798      	blx	r3
	if( xTimerQueue != NULL )
    190c:	4b0c      	ldr	r3, [pc, #48]	; (1940 <xTimerCreateTimerTask+0x3c>)
    190e:	689b      	ldr	r3, [r3, #8]
    1910:	2b00      	cmp	r3, #0
    1912:	d00e      	beq.n	1932 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    1914:	4b0a      	ldr	r3, [pc, #40]	; (1940 <xTimerCreateTimerTask+0x3c>)
    1916:	3334      	adds	r3, #52	; 0x34
    1918:	9301      	str	r3, [sp, #4]
    191a:	2302      	movs	r3, #2
    191c:	9300      	str	r3, [sp, #0]
    191e:	2300      	movs	r3, #0
    1920:	2250      	movs	r2, #80	; 0x50
    1922:	4908      	ldr	r1, [pc, #32]	; (1944 <xTimerCreateTimerTask+0x40>)
    1924:	4808      	ldr	r0, [pc, #32]	; (1948 <xTimerCreateTimerTask+0x44>)
    1926:	4c09      	ldr	r4, [pc, #36]	; (194c <xTimerCreateTimerTask+0x48>)
    1928:	47a0      	blx	r4
	configASSERT( xReturn );
    192a:	2800      	cmp	r0, #0
    192c:	d103      	bne.n	1936 <xTimerCreateTimerTask+0x32>
    192e:	b672      	cpsid	i
    1930:	e7fe      	b.n	1930 <xTimerCreateTimerTask+0x2c>
BaseType_t xReturn = pdFAIL;
    1932:	2000      	movs	r0, #0
    1934:	e7f9      	b.n	192a <xTimerCreateTimerTask+0x26>
}
    1936:	b002      	add	sp, #8
    1938:	bd10      	pop	{r4, pc}
    193a:	46c0      	nop			; (mov r8, r8)
    193c:	000018a5 	.word	0x000018a5
    1940:	2000440c 	.word	0x2000440c
    1944:	00001fe8 	.word	0x00001fe8
    1948:	00001c09 	.word	0x00001c09
    194c:	00001271 	.word	0x00001271

00001950 <xTimerGenericCommand>:
{
    1950:	b530      	push	{r4, r5, lr}
    1952:	b085      	sub	sp, #20
    1954:	0004      	movs	r4, r0
    1956:	001d      	movs	r5, r3
	configASSERT( xTimer );
    1958:	2800      	cmp	r0, #0
    195a:	d014      	beq.n	1986 <xTimerGenericCommand+0x36>
	if( xTimerQueue != NULL )
    195c:	4b13      	ldr	r3, [pc, #76]	; (19ac <xTimerGenericCommand+0x5c>)
    195e:	6898      	ldr	r0, [r3, #8]
    1960:	2800      	cmp	r0, #0
    1962:	d021      	beq.n	19a8 <xTimerGenericCommand+0x58>
		xMessage.xMessageID = xCommandID;
    1964:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1966:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1968:	9403      	str	r4, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    196a:	2905      	cmp	r1, #5
    196c:	dc15      	bgt.n	199a <xTimerGenericCommand+0x4a>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    196e:	4b10      	ldr	r3, [pc, #64]	; (19b0 <xTimerGenericCommand+0x60>)
    1970:	4798      	blx	r3
    1972:	2802      	cmp	r0, #2
    1974:	d009      	beq.n	198a <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1976:	4b0d      	ldr	r3, [pc, #52]	; (19ac <xTimerGenericCommand+0x5c>)
    1978:	6898      	ldr	r0, [r3, #8]
    197a:	2300      	movs	r3, #0
    197c:	2200      	movs	r2, #0
    197e:	a901      	add	r1, sp, #4
    1980:	4c0c      	ldr	r4, [pc, #48]	; (19b4 <xTimerGenericCommand+0x64>)
    1982:	47a0      	blx	r4
    1984:	e00e      	b.n	19a4 <xTimerGenericCommand+0x54>
	configASSERT( xTimer );
    1986:	b672      	cpsid	i
    1988:	e7fe      	b.n	1988 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    198a:	4b08      	ldr	r3, [pc, #32]	; (19ac <xTimerGenericCommand+0x5c>)
    198c:	6898      	ldr	r0, [r3, #8]
    198e:	2300      	movs	r3, #0
    1990:	9a08      	ldr	r2, [sp, #32]
    1992:	a901      	add	r1, sp, #4
    1994:	4c07      	ldr	r4, [pc, #28]	; (19b4 <xTimerGenericCommand+0x64>)
    1996:	47a0      	blx	r4
    1998:	e004      	b.n	19a4 <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    199a:	2300      	movs	r3, #0
    199c:	002a      	movs	r2, r5
    199e:	a901      	add	r1, sp, #4
    19a0:	4c05      	ldr	r4, [pc, #20]	; (19b8 <xTimerGenericCommand+0x68>)
    19a2:	47a0      	blx	r4
}
    19a4:	b005      	add	sp, #20
    19a6:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
    19a8:	2000      	movs	r0, #0
	return xReturn;
    19aa:	e7fb      	b.n	19a4 <xTimerGenericCommand+0x54>
    19ac:	2000440c 	.word	0x2000440c
    19b0:	000017a1 	.word	0x000017a1
    19b4:	00000b51 	.word	0x00000b51
    19b8:	00000ce1 	.word	0x00000ce1

000019bc <prvSwitchTimerLists>:
{
    19bc:	b570      	push	{r4, r5, r6, lr}
    19be:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    19c0:	4b17      	ldr	r3, [pc, #92]	; (1a20 <prvSwitchTimerLists+0x64>)
    19c2:	681b      	ldr	r3, [r3, #0]
    19c4:	681a      	ldr	r2, [r3, #0]
    19c6:	2a00      	cmp	r2, #0
    19c8:	d023      	beq.n	1a12 <prvSwitchTimerLists+0x56>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    19ca:	68db      	ldr	r3, [r3, #12]
    19cc:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    19ce:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    19d0:	1d25      	adds	r5, r4, #4
    19d2:	0028      	movs	r0, r5
    19d4:	4b13      	ldr	r3, [pc, #76]	; (1a24 <prvSwitchTimerLists+0x68>)
    19d6:	4798      	blx	r3
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    19d8:	0020      	movs	r0, r4
    19da:	6a63      	ldr	r3, [r4, #36]	; 0x24
    19dc:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    19de:	69e3      	ldr	r3, [r4, #28]
    19e0:	2b01      	cmp	r3, #1
    19e2:	d1ed      	bne.n	19c0 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    19e4:	69a3      	ldr	r3, [r4, #24]
    19e6:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
    19e8:	429e      	cmp	r6, r3
    19ea:	d207      	bcs.n	19fc <prvSwitchTimerLists+0x40>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    19ec:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    19ee:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    19f0:	4b0b      	ldr	r3, [pc, #44]	; (1a20 <prvSwitchTimerLists+0x64>)
    19f2:	6818      	ldr	r0, [r3, #0]
    19f4:	0029      	movs	r1, r5
    19f6:	4b0c      	ldr	r3, [pc, #48]	; (1a28 <prvSwitchTimerLists+0x6c>)
    19f8:	4798      	blx	r3
    19fa:	e7e1      	b.n	19c0 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    19fc:	2300      	movs	r3, #0
    19fe:	9300      	str	r3, [sp, #0]
    1a00:	0032      	movs	r2, r6
    1a02:	2100      	movs	r1, #0
    1a04:	0020      	movs	r0, r4
    1a06:	4c09      	ldr	r4, [pc, #36]	; (1a2c <prvSwitchTimerLists+0x70>)
    1a08:	47a0      	blx	r4
				configASSERT( xResult );
    1a0a:	2800      	cmp	r0, #0
    1a0c:	d1d8      	bne.n	19c0 <prvSwitchTimerLists+0x4>
    1a0e:	b672      	cpsid	i
    1a10:	e7fe      	b.n	1a10 <prvSwitchTimerLists+0x54>
	pxCurrentTimerList = pxOverflowTimerList;
    1a12:	4a03      	ldr	r2, [pc, #12]	; (1a20 <prvSwitchTimerLists+0x64>)
    1a14:	6851      	ldr	r1, [r2, #4]
    1a16:	6011      	str	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
    1a18:	6053      	str	r3, [r2, #4]
}
    1a1a:	b002      	add	sp, #8
    1a1c:	bd70      	pop	{r4, r5, r6, pc}
    1a1e:	46c0      	nop			; (mov r8, r8)
    1a20:	2000440c 	.word	0x2000440c
    1a24:	00000375 	.word	0x00000375
    1a28:	00000345 	.word	0x00000345
    1a2c:	00001951 	.word	0x00001951

00001a30 <prvSampleTimeNow>:
{
    1a30:	b570      	push	{r4, r5, r6, lr}
    1a32:	0005      	movs	r5, r0
	xTimeNow = xTaskGetTickCount();
    1a34:	4b08      	ldr	r3, [pc, #32]	; (1a58 <prvSampleTimeNow+0x28>)
    1a36:	4798      	blx	r3
    1a38:	0004      	movs	r4, r0
	if( xTimeNow < xLastTime )
    1a3a:	4b08      	ldr	r3, [pc, #32]	; (1a5c <prvSampleTimeNow+0x2c>)
    1a3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1a3e:	4298      	cmp	r0, r3
    1a40:	d305      	bcc.n	1a4e <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
    1a42:	2300      	movs	r3, #0
    1a44:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
    1a46:	4b05      	ldr	r3, [pc, #20]	; (1a5c <prvSampleTimeNow+0x2c>)
    1a48:	639c      	str	r4, [r3, #56]	; 0x38
}
    1a4a:	0020      	movs	r0, r4
    1a4c:	bd70      	pop	{r4, r5, r6, pc}
		prvSwitchTimerLists();
    1a4e:	4b04      	ldr	r3, [pc, #16]	; (1a60 <prvSampleTimeNow+0x30>)
    1a50:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
    1a52:	2301      	movs	r3, #1
    1a54:	602b      	str	r3, [r5, #0]
    1a56:	e7f6      	b.n	1a46 <prvSampleTimeNow+0x16>
    1a58:	00001359 	.word	0x00001359
    1a5c:	2000440c 	.word	0x2000440c
    1a60:	000019bd 	.word	0x000019bd

00001a64 <prvProcessExpiredTimer>:
{
    1a64:	b570      	push	{r4, r5, r6, lr}
    1a66:	b082      	sub	sp, #8
    1a68:	0005      	movs	r5, r0
    1a6a:	000e      	movs	r6, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a6c:	4b11      	ldr	r3, [pc, #68]	; (1ab4 <prvProcessExpiredTimer+0x50>)
    1a6e:	681b      	ldr	r3, [r3, #0]
    1a70:	68db      	ldr	r3, [r3, #12]
    1a72:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1a74:	1d20      	adds	r0, r4, #4
    1a76:	4b10      	ldr	r3, [pc, #64]	; (1ab8 <prvProcessExpiredTimer+0x54>)
    1a78:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1a7a:	69e3      	ldr	r3, [r4, #28]
    1a7c:	2b01      	cmp	r3, #1
    1a7e:	d004      	beq.n	1a8a <prvProcessExpiredTimer+0x26>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1a80:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1a82:	0020      	movs	r0, r4
    1a84:	4798      	blx	r3
}
    1a86:	b002      	add	sp, #8
    1a88:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1a8a:	69a3      	ldr	r3, [r4, #24]
    1a8c:	1959      	adds	r1, r3, r5
    1a8e:	002b      	movs	r3, r5
    1a90:	0032      	movs	r2, r6
    1a92:	0020      	movs	r0, r4
    1a94:	4e09      	ldr	r6, [pc, #36]	; (1abc <prvProcessExpiredTimer+0x58>)
    1a96:	47b0      	blx	r6
    1a98:	2800      	cmp	r0, #0
    1a9a:	d0f1      	beq.n	1a80 <prvProcessExpiredTimer+0x1c>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1a9c:	2300      	movs	r3, #0
    1a9e:	9300      	str	r3, [sp, #0]
    1aa0:	002a      	movs	r2, r5
    1aa2:	2100      	movs	r1, #0
    1aa4:	0020      	movs	r0, r4
    1aa6:	4d06      	ldr	r5, [pc, #24]	; (1ac0 <prvProcessExpiredTimer+0x5c>)
    1aa8:	47a8      	blx	r5
			configASSERT( xResult );
    1aaa:	2800      	cmp	r0, #0
    1aac:	d1e8      	bne.n	1a80 <prvProcessExpiredTimer+0x1c>
    1aae:	b672      	cpsid	i
    1ab0:	e7fe      	b.n	1ab0 <prvProcessExpiredTimer+0x4c>
    1ab2:	46c0      	nop			; (mov r8, r8)
    1ab4:	2000440c 	.word	0x2000440c
    1ab8:	00000375 	.word	0x00000375
    1abc:	0000185d 	.word	0x0000185d
    1ac0:	00001951 	.word	0x00001951

00001ac4 <prvProcessTimerOrBlockTask>:
{
    1ac4:	b570      	push	{r4, r5, r6, lr}
    1ac6:	b082      	sub	sp, #8
    1ac8:	0005      	movs	r5, r0
    1aca:	000c      	movs	r4, r1
	vTaskSuspendAll();
    1acc:	4b16      	ldr	r3, [pc, #88]	; (1b28 <prvProcessTimerOrBlockTask+0x64>)
    1ace:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ad0:	a801      	add	r0, sp, #4
    1ad2:	4b16      	ldr	r3, [pc, #88]	; (1b2c <prvProcessTimerOrBlockTask+0x68>)
    1ad4:	4798      	blx	r3
    1ad6:	0006      	movs	r6, r0
		if( xTimerListsWereSwitched == pdFALSE )
    1ad8:	9b01      	ldr	r3, [sp, #4]
    1ada:	2b00      	cmp	r3, #0
    1adc:	d121      	bne.n	1b22 <prvProcessTimerOrBlockTask+0x5e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1ade:	2c00      	cmp	r4, #0
    1ae0:	d101      	bne.n	1ae6 <prvProcessTimerOrBlockTask+0x22>
    1ae2:	42a8      	cmp	r0, r5
    1ae4:	d213      	bcs.n	1b0e <prvProcessTimerOrBlockTask+0x4a>
				if( xListWasEmpty != pdFALSE )
    1ae6:	2c00      	cmp	r4, #0
    1ae8:	d005      	beq.n	1af6 <prvProcessTimerOrBlockTask+0x32>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1aea:	4b11      	ldr	r3, [pc, #68]	; (1b30 <prvProcessTimerOrBlockTask+0x6c>)
    1aec:	685b      	ldr	r3, [r3, #4]
    1aee:	681c      	ldr	r4, [r3, #0]
    1af0:	4263      	negs	r3, r4
    1af2:	415c      	adcs	r4, r3
    1af4:	b2e4      	uxtb	r4, r4
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1af6:	1ba9      	subs	r1, r5, r6
    1af8:	4b0d      	ldr	r3, [pc, #52]	; (1b30 <prvProcessTimerOrBlockTask+0x6c>)
    1afa:	6898      	ldr	r0, [r3, #8]
    1afc:	0022      	movs	r2, r4
    1afe:	4b0d      	ldr	r3, [pc, #52]	; (1b34 <prvProcessTimerOrBlockTask+0x70>)
    1b00:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    1b02:	4b0d      	ldr	r3, [pc, #52]	; (1b38 <prvProcessTimerOrBlockTask+0x74>)
    1b04:	4798      	blx	r3
    1b06:	2800      	cmp	r0, #0
    1b08:	d008      	beq.n	1b1c <prvProcessTimerOrBlockTask+0x58>
}
    1b0a:	b002      	add	sp, #8
    1b0c:	bd70      	pop	{r4, r5, r6, pc}
				( void ) xTaskResumeAll();
    1b0e:	4b0a      	ldr	r3, [pc, #40]	; (1b38 <prvProcessTimerOrBlockTask+0x74>)
    1b10:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    1b12:	0031      	movs	r1, r6
    1b14:	0028      	movs	r0, r5
    1b16:	4b09      	ldr	r3, [pc, #36]	; (1b3c <prvProcessTimerOrBlockTask+0x78>)
    1b18:	4798      	blx	r3
    1b1a:	e7f6      	b.n	1b0a <prvProcessTimerOrBlockTask+0x46>
					portYIELD_WITHIN_API();
    1b1c:	4b08      	ldr	r3, [pc, #32]	; (1b40 <prvProcessTimerOrBlockTask+0x7c>)
    1b1e:	4798      	blx	r3
    1b20:	e7f3      	b.n	1b0a <prvProcessTimerOrBlockTask+0x46>
			( void ) xTaskResumeAll();
    1b22:	4b05      	ldr	r3, [pc, #20]	; (1b38 <prvProcessTimerOrBlockTask+0x74>)
    1b24:	4798      	blx	r3
}
    1b26:	e7f0      	b.n	1b0a <prvProcessTimerOrBlockTask+0x46>
    1b28:	00001349 	.word	0x00001349
    1b2c:	00001a31 	.word	0x00001a31
    1b30:	2000440c 	.word	0x2000440c
    1b34:	00000f4d 	.word	0x00000f4d
    1b38:	00001471 	.word	0x00001471
    1b3c:	00001a65 	.word	0x00001a65
    1b40:	00000779 	.word	0x00000779

00001b44 <prvProcessReceivedCommands>:
{
    1b44:	b530      	push	{r4, r5, lr}
    1b46:	b087      	sub	sp, #28
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1b48:	4b27      	ldr	r3, [pc, #156]	; (1be8 <prvProcessReceivedCommands+0xa4>)
    1b4a:	6898      	ldr	r0, [r3, #8]
    1b4c:	2200      	movs	r2, #0
    1b4e:	a903      	add	r1, sp, #12
    1b50:	4b26      	ldr	r3, [pc, #152]	; (1bec <prvProcessReceivedCommands+0xa8>)
    1b52:	4798      	blx	r3
    1b54:	2800      	cmp	r0, #0
    1b56:	d045      	beq.n	1be4 <prvProcessReceivedCommands+0xa0>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1b58:	9b03      	ldr	r3, [sp, #12]
    1b5a:	2b00      	cmp	r3, #0
    1b5c:	dbf4      	blt.n	1b48 <prvProcessReceivedCommands+0x4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1b5e:	9c05      	ldr	r4, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    1b60:	6963      	ldr	r3, [r4, #20]
    1b62:	2b00      	cmp	r3, #0
    1b64:	d002      	beq.n	1b6c <prvProcessReceivedCommands+0x28>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1b66:	1d20      	adds	r0, r4, #4
    1b68:	4b21      	ldr	r3, [pc, #132]	; (1bf0 <prvProcessReceivedCommands+0xac>)
    1b6a:	4798      	blx	r3
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1b6c:	a802      	add	r0, sp, #8
    1b6e:	4b21      	ldr	r3, [pc, #132]	; (1bf4 <prvProcessReceivedCommands+0xb0>)
    1b70:	4798      	blx	r3
			switch( xMessage.xMessageID )
    1b72:	9b03      	ldr	r3, [sp, #12]
    1b74:	2b09      	cmp	r3, #9
    1b76:	d8e7      	bhi.n	1b48 <prvProcessReceivedCommands+0x4>
    1b78:	009b      	lsls	r3, r3, #2
    1b7a:	4a1f      	ldr	r2, [pc, #124]	; (1bf8 <prvProcessReceivedCommands+0xb4>)
    1b7c:	58d3      	ldr	r3, [r2, r3]
    1b7e:	469f      	mov	pc, r3
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1b80:	9b04      	ldr	r3, [sp, #16]
    1b82:	69a2      	ldr	r2, [r4, #24]
    1b84:	4694      	mov	ip, r2
    1b86:	4463      	add	r3, ip
    1b88:	0019      	movs	r1, r3
    1b8a:	9b04      	ldr	r3, [sp, #16]
    1b8c:	0002      	movs	r2, r0
    1b8e:	0020      	movs	r0, r4
    1b90:	4d1a      	ldr	r5, [pc, #104]	; (1bfc <prvProcessReceivedCommands+0xb8>)
    1b92:	47a8      	blx	r5
    1b94:	2800      	cmp	r0, #0
    1b96:	d0d7      	beq.n	1b48 <prvProcessReceivedCommands+0x4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1b98:	0020      	movs	r0, r4
    1b9a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1b9c:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1b9e:	69e3      	ldr	r3, [r4, #28]
    1ba0:	2b01      	cmp	r3, #1
    1ba2:	d1d1      	bne.n	1b48 <prvProcessReceivedCommands+0x4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1ba4:	9b04      	ldr	r3, [sp, #16]
    1ba6:	69a1      	ldr	r1, [r4, #24]
    1ba8:	468c      	mov	ip, r1
    1baa:	4463      	add	r3, ip
    1bac:	001a      	movs	r2, r3
    1bae:	2300      	movs	r3, #0
    1bb0:	9300      	str	r3, [sp, #0]
    1bb2:	2100      	movs	r1, #0
    1bb4:	0020      	movs	r0, r4
    1bb6:	4c12      	ldr	r4, [pc, #72]	; (1c00 <prvProcessReceivedCommands+0xbc>)
    1bb8:	47a0      	blx	r4
							configASSERT( xResult );
    1bba:	2800      	cmp	r0, #0
    1bbc:	d1c4      	bne.n	1b48 <prvProcessReceivedCommands+0x4>
    1bbe:	b672      	cpsid	i
    1bc0:	e7fe      	b.n	1bc0 <prvProcessReceivedCommands+0x7c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1bc2:	9904      	ldr	r1, [sp, #16]
    1bc4:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1bc6:	2900      	cmp	r1, #0
    1bc8:	d006      	beq.n	1bd8 <prvProcessReceivedCommands+0x94>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1bca:	1841      	adds	r1, r0, r1
    1bcc:	0003      	movs	r3, r0
    1bce:	0002      	movs	r2, r0
    1bd0:	0020      	movs	r0, r4
    1bd2:	4c0a      	ldr	r4, [pc, #40]	; (1bfc <prvProcessReceivedCommands+0xb8>)
    1bd4:	47a0      	blx	r4
					break;
    1bd6:	e7b7      	b.n	1b48 <prvProcessReceivedCommands+0x4>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1bd8:	b672      	cpsid	i
    1bda:	e7fe      	b.n	1bda <prvProcessReceivedCommands+0x96>
						vPortFree( pxTimer );
    1bdc:	0020      	movs	r0, r4
    1bde:	4b09      	ldr	r3, [pc, #36]	; (1c04 <prvProcessReceivedCommands+0xc0>)
    1be0:	4798      	blx	r3
					break;
    1be2:	e7b1      	b.n	1b48 <prvProcessReceivedCommands+0x4>
}
    1be4:	b007      	add	sp, #28
    1be6:	bd30      	pop	{r4, r5, pc}
    1be8:	2000440c 	.word	0x2000440c
    1bec:	00000dcd 	.word	0x00000dcd
    1bf0:	00000375 	.word	0x00000375
    1bf4:	00001a31 	.word	0x00001a31
    1bf8:	00001fb8 	.word	0x00001fb8
    1bfc:	0000185d 	.word	0x0000185d
    1c00:	00001951 	.word	0x00001951
    1c04:	000002c9 	.word	0x000002c9

00001c08 <prvTimerTask>:
{
    1c08:	b500      	push	{lr}
    1c0a:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    1c0c:	a801      	add	r0, sp, #4
    1c0e:	4b04      	ldr	r3, [pc, #16]	; (1c20 <prvTimerTask+0x18>)
    1c10:	4798      	blx	r3
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    1c12:	9901      	ldr	r1, [sp, #4]
    1c14:	4b03      	ldr	r3, [pc, #12]	; (1c24 <prvTimerTask+0x1c>)
    1c16:	4798      	blx	r3
		prvProcessReceivedCommands();
    1c18:	4b03      	ldr	r3, [pc, #12]	; (1c28 <prvTimerTask+0x20>)
    1c1a:	4798      	blx	r3
    1c1c:	e7f6      	b.n	1c0c <prvTimerTask+0x4>
    1c1e:	46c0      	nop			; (mov r8, r8)
    1c20:	0000183d 	.word	0x0000183d
    1c24:	00001ac5 	.word	0x00001ac5
    1c28:	00001b45 	.word	0x00001b45

00001c2c <initUART>:
/* Replace with your library code */
void initUART(void) {

	/* APBCMASK */
   /* SERCOM 0 enable*/
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0;
    1c2c:	4a1f      	ldr	r2, [pc, #124]	; (1cac <initUART+0x80>)
    1c2e:	6a13      	ldr	r3, [r2, #32]
    1c30:	2104      	movs	r1, #4
    1c32:	430b      	orrs	r3, r1
    1c34:	6213      	str	r3, [r2, #32]

	/*GCLK configuration for sercom0 module: using generic clock generator 0, ID for sercom0, enable GCLK*/
    GCLK->GENCTRL.reg=GCLK_GENCTRL_SRC_OSC8M|GCLK_GENCTRL_ID(0)|
    1c36:	4b1e      	ldr	r3, [pc, #120]	; (1cb0 <initUART+0x84>)
    1c38:	2283      	movs	r2, #131	; 0x83
    1c3a:	0252      	lsls	r2, r2, #9
    1c3c:	605a      	str	r2, [r3, #4]
	GCLK_GENCTRL_GENEN;

	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE) |
    1c3e:	4a1d      	ldr	r2, [pc, #116]	; (1cb4 <initUART+0x88>)
    1c40:	805a      	strh	r2, [r3, #2]
	GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);

  /*CONFIGURAR PA10 y PA11 como salidas tipo C (SERCOM 0) */
  PORT->Group[0].PINCFG[PIN_PA10].reg= PA10_TX;
    1c42:	4b1d      	ldr	r3, [pc, #116]	; (1cb8 <initUART+0x8c>)
    1c44:	3903      	subs	r1, #3
    1c46:	224a      	movs	r2, #74	; 0x4a
    1c48:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PINCFG[PIN_PA11].reg= PA11_RX;
    1c4a:	3106      	adds	r1, #6
    1c4c:	3201      	adds	r2, #1
    1c4e:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PMUX[5].bit.PMUXE=Type_C;
    1c50:	312e      	adds	r1, #46	; 0x2e
    1c52:	5c5a      	ldrb	r2, [r3, r1]
    1c54:	200f      	movs	r0, #15
    1c56:	4382      	bics	r2, r0
    1c58:	2002      	movs	r0, #2
    1c5a:	4302      	orrs	r2, r0
    1c5c:	545a      	strb	r2, [r3, r1]
  PORT->Group[0].PMUX[5].bit.PMUXO=Type_C;
    1c5e:	5c58      	ldrb	r0, [r3, r1]
    1c60:	220f      	movs	r2, #15
    1c62:	4002      	ands	r2, r0
    1c64:	2020      	movs	r0, #32
    1c66:	4302      	orrs	r2, r0
    1c68:	545a      	strb	r2, [r3, r1]
	
	//desahibilitar UART para inicializacion
	SERCOM0->USART.CTRLA.bit.ENABLE=0;
    1c6a:	4b14      	ldr	r3, [pc, #80]	; (1cbc <initUART+0x90>)
    1c6c:	6819      	ldr	r1, [r3, #0]
    1c6e:	2202      	movs	r2, #2
    1c70:	4391      	bics	r1, r2
    1c72:	6019      	str	r1, [r3, #0]
   
   DEFINES:
   1)SERCOM_USART_CTRLA_DORD (_U(0x1) << SERCOM_USART_CTRLA_DORD_Pos)
   2)SERCOM_USART_CTRLA_MODE_USART_INT_CLK (0x1 << 2)
   3)SERCOM_USART_CTRLA_RXPO(value) (SERCOM_USART_CTRLA_RXPO_Msk & ((value) << SERCOM_USART_CTRLA_RXPO_Pos) */
	SERCOM0->USART.CTRLA.reg =
    1c74:	4a12      	ldr	r2, [pc, #72]	; (1cc0 <initUART+0x94>)
    1c76:	601a      	str	r2, [r3, #0]
	SERCOM_USART_CTRLA_DORD | SERCOM_USART_CTRLA_MODE_USART_INT_CLK |
	SERCOM_USART_CTRLA_RXPO(3) | SERCOM_USART_CTRLA_TXPO(1);
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1c78:	4b10      	ldr	r3, [pc, #64]	; (1cbc <initUART+0x90>)
    1c7a:	69db      	ldr	r3, [r3, #28]
    1c7c:	2b00      	cmp	r3, #0
    1c7e:	d1fb      	bne.n	1c78 <initUART+0x4c>
	uint64_t br = (uint64_t)65536 * (8000000 - 16 * 9600) / 8000000;

	SERCOM0->USART.BAUD.reg = (uint16_t)br;
    1c80:	4a10      	ldr	r2, [pc, #64]	; (1cc4 <initUART+0x98>)
    1c82:	4b0e      	ldr	r3, [pc, #56]	; (1cbc <initUART+0x90>)
    1c84:	819a      	strh	r2, [r3, #12]
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1c86:	4b0d      	ldr	r3, [pc, #52]	; (1cbc <initUART+0x90>)
    1c88:	69db      	ldr	r3, [r3, #28]
    1c8a:	2b00      	cmp	r3, #0
    1c8c:	d1fb      	bne.n	1c86 <initUART+0x5a>
	SERCOM0->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_CHSIZE(0/*8 bits*/);
    1c8e:	22c0      	movs	r2, #192	; 0xc0
    1c90:	0292      	lsls	r2, r2, #10
    1c92:	4b0a      	ldr	r3, [pc, #40]	; (1cbc <initUART+0x90>)
    1c94:	605a      	str	r2, [r3, #4]
    while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1c96:	4b09      	ldr	r3, [pc, #36]	; (1cbc <initUART+0x90>)
    1c98:	69db      	ldr	r3, [r3, #28]
    1c9a:	2b00      	cmp	r3, #0
    1c9c:	d1fb      	bne.n	1c96 <initUART+0x6a>
	SERCOM0->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    1c9e:	4a07      	ldr	r2, [pc, #28]	; (1cbc <initUART+0x90>)
    1ca0:	6813      	ldr	r3, [r2, #0]
    1ca2:	2102      	movs	r1, #2
    1ca4:	430b      	orrs	r3, r1
    1ca6:	6013      	str	r3, [r2, #0]
}
    1ca8:	4770      	bx	lr
    1caa:	46c0      	nop			; (mov r8, r8)
    1cac:	40000400 	.word	0x40000400
    1cb0:	40000c00 	.word	0x40000c00
    1cb4:	00004014 	.word	0x00004014
    1cb8:	41004400 	.word	0x41004400
    1cbc:	42000800 	.word	0x42000800
    1cc0:	40310004 	.word	0x40310004
    1cc4:	fffffb15 	.word	0xfffffb15

00001cc8 <__libc_init_array>:
    1cc8:	b570      	push	{r4, r5, r6, lr}
    1cca:	4e0d      	ldr	r6, [pc, #52]	; (1d00 <__libc_init_array+0x38>)
    1ccc:	4d0d      	ldr	r5, [pc, #52]	; (1d04 <__libc_init_array+0x3c>)
    1cce:	2400      	movs	r4, #0
    1cd0:	1bad      	subs	r5, r5, r6
    1cd2:	10ad      	asrs	r5, r5, #2
    1cd4:	d005      	beq.n	1ce2 <__libc_init_array+0x1a>
    1cd6:	00a3      	lsls	r3, r4, #2
    1cd8:	58f3      	ldr	r3, [r6, r3]
    1cda:	3401      	adds	r4, #1
    1cdc:	4798      	blx	r3
    1cde:	42a5      	cmp	r5, r4
    1ce0:	d1f9      	bne.n	1cd6 <__libc_init_array+0xe>
    1ce2:	f000 f987 	bl	1ff4 <_init>
    1ce6:	4e08      	ldr	r6, [pc, #32]	; (1d08 <__libc_init_array+0x40>)
    1ce8:	4d08      	ldr	r5, [pc, #32]	; (1d0c <__libc_init_array+0x44>)
    1cea:	2400      	movs	r4, #0
    1cec:	1bad      	subs	r5, r5, r6
    1cee:	10ad      	asrs	r5, r5, #2
    1cf0:	d005      	beq.n	1cfe <__libc_init_array+0x36>
    1cf2:	00a3      	lsls	r3, r4, #2
    1cf4:	58f3      	ldr	r3, [r6, r3]
    1cf6:	3401      	adds	r4, #1
    1cf8:	4798      	blx	r3
    1cfa:	42a5      	cmp	r5, r4
    1cfc:	d1f9      	bne.n	1cf2 <__libc_init_array+0x2a>
    1cfe:	bd70      	pop	{r4, r5, r6, pc}
    1d00:	00002000 	.word	0x00002000
    1d04:	00002000 	.word	0x00002000
    1d08:	00002000 	.word	0x00002000
    1d0c:	00002008 	.word	0x00002008

00001d10 <memcpy>:
    1d10:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d12:	0005      	movs	r5, r0
    1d14:	2a0f      	cmp	r2, #15
    1d16:	d92f      	bls.n	1d78 <memcpy+0x68>
    1d18:	000b      	movs	r3, r1
    1d1a:	4303      	orrs	r3, r0
    1d1c:	079b      	lsls	r3, r3, #30
    1d1e:	d134      	bne.n	1d8a <memcpy+0x7a>
    1d20:	0016      	movs	r6, r2
    1d22:	000c      	movs	r4, r1
    1d24:	0003      	movs	r3, r0
    1d26:	3e10      	subs	r6, #16
    1d28:	0935      	lsrs	r5, r6, #4
    1d2a:	3501      	adds	r5, #1
    1d2c:	012d      	lsls	r5, r5, #4
    1d2e:	1945      	adds	r5, r0, r5
    1d30:	6827      	ldr	r7, [r4, #0]
    1d32:	601f      	str	r7, [r3, #0]
    1d34:	6867      	ldr	r7, [r4, #4]
    1d36:	605f      	str	r7, [r3, #4]
    1d38:	68a7      	ldr	r7, [r4, #8]
    1d3a:	609f      	str	r7, [r3, #8]
    1d3c:	68e7      	ldr	r7, [r4, #12]
    1d3e:	3410      	adds	r4, #16
    1d40:	60df      	str	r7, [r3, #12]
    1d42:	3310      	adds	r3, #16
    1d44:	429d      	cmp	r5, r3
    1d46:	d1f3      	bne.n	1d30 <memcpy+0x20>
    1d48:	230f      	movs	r3, #15
    1d4a:	439e      	bics	r6, r3
    1d4c:	3610      	adds	r6, #16
    1d4e:	1985      	adds	r5, r0, r6
    1d50:	1989      	adds	r1, r1, r6
    1d52:	4013      	ands	r3, r2
    1d54:	2b03      	cmp	r3, #3
    1d56:	d91a      	bls.n	1d8e <memcpy+0x7e>
    1d58:	1f1e      	subs	r6, r3, #4
    1d5a:	2300      	movs	r3, #0
    1d5c:	08b4      	lsrs	r4, r6, #2
    1d5e:	3401      	adds	r4, #1
    1d60:	00a4      	lsls	r4, r4, #2
    1d62:	58cf      	ldr	r7, [r1, r3]
    1d64:	50ef      	str	r7, [r5, r3]
    1d66:	3304      	adds	r3, #4
    1d68:	42a3      	cmp	r3, r4
    1d6a:	d1fa      	bne.n	1d62 <memcpy+0x52>
    1d6c:	2403      	movs	r4, #3
    1d6e:	43a6      	bics	r6, r4
    1d70:	1d33      	adds	r3, r6, #4
    1d72:	4022      	ands	r2, r4
    1d74:	18c9      	adds	r1, r1, r3
    1d76:	18ed      	adds	r5, r5, r3
    1d78:	2a00      	cmp	r2, #0
    1d7a:	d005      	beq.n	1d88 <memcpy+0x78>
    1d7c:	2300      	movs	r3, #0
    1d7e:	5ccc      	ldrb	r4, [r1, r3]
    1d80:	54ec      	strb	r4, [r5, r3]
    1d82:	3301      	adds	r3, #1
    1d84:	4293      	cmp	r3, r2
    1d86:	d1fa      	bne.n	1d7e <memcpy+0x6e>
    1d88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d8a:	0005      	movs	r5, r0
    1d8c:	e7f6      	b.n	1d7c <memcpy+0x6c>
    1d8e:	001a      	movs	r2, r3
    1d90:	e7f2      	b.n	1d78 <memcpy+0x68>
    1d92:	46c0      	nop			; (mov r8, r8)

00001d94 <memset>:
    1d94:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d96:	0783      	lsls	r3, r0, #30
    1d98:	d043      	beq.n	1e22 <memset+0x8e>
    1d9a:	1e54      	subs	r4, r2, #1
    1d9c:	2a00      	cmp	r2, #0
    1d9e:	d03f      	beq.n	1e20 <memset+0x8c>
    1da0:	b2ce      	uxtb	r6, r1
    1da2:	0002      	movs	r2, r0
    1da4:	2503      	movs	r5, #3
    1da6:	e002      	b.n	1dae <memset+0x1a>
    1da8:	001a      	movs	r2, r3
    1daa:	3c01      	subs	r4, #1
    1dac:	d338      	bcc.n	1e20 <memset+0x8c>
    1dae:	1c53      	adds	r3, r2, #1
    1db0:	7016      	strb	r6, [r2, #0]
    1db2:	422b      	tst	r3, r5
    1db4:	d1f8      	bne.n	1da8 <memset+0x14>
    1db6:	2c03      	cmp	r4, #3
    1db8:	d92a      	bls.n	1e10 <memset+0x7c>
    1dba:	22ff      	movs	r2, #255	; 0xff
    1dbc:	400a      	ands	r2, r1
    1dbe:	0215      	lsls	r5, r2, #8
    1dc0:	4315      	orrs	r5, r2
    1dc2:	042a      	lsls	r2, r5, #16
    1dc4:	4315      	orrs	r5, r2
    1dc6:	2c0f      	cmp	r4, #15
    1dc8:	d914      	bls.n	1df4 <memset+0x60>
    1dca:	0027      	movs	r7, r4
    1dcc:	001a      	movs	r2, r3
    1dce:	3f10      	subs	r7, #16
    1dd0:	093e      	lsrs	r6, r7, #4
    1dd2:	3601      	adds	r6, #1
    1dd4:	0136      	lsls	r6, r6, #4
    1dd6:	199e      	adds	r6, r3, r6
    1dd8:	6015      	str	r5, [r2, #0]
    1dda:	6055      	str	r5, [r2, #4]
    1ddc:	6095      	str	r5, [r2, #8]
    1dde:	60d5      	str	r5, [r2, #12]
    1de0:	3210      	adds	r2, #16
    1de2:	4296      	cmp	r6, r2
    1de4:	d1f8      	bne.n	1dd8 <memset+0x44>
    1de6:	220f      	movs	r2, #15
    1de8:	4397      	bics	r7, r2
    1dea:	3710      	adds	r7, #16
    1dec:	19db      	adds	r3, r3, r7
    1dee:	4014      	ands	r4, r2
    1df0:	2c03      	cmp	r4, #3
    1df2:	d90d      	bls.n	1e10 <memset+0x7c>
    1df4:	001a      	movs	r2, r3
    1df6:	1f27      	subs	r7, r4, #4
    1df8:	08be      	lsrs	r6, r7, #2
    1dfa:	3601      	adds	r6, #1
    1dfc:	00b6      	lsls	r6, r6, #2
    1dfe:	199e      	adds	r6, r3, r6
    1e00:	c220      	stmia	r2!, {r5}
    1e02:	42b2      	cmp	r2, r6
    1e04:	d1fc      	bne.n	1e00 <memset+0x6c>
    1e06:	2203      	movs	r2, #3
    1e08:	4397      	bics	r7, r2
    1e0a:	3704      	adds	r7, #4
    1e0c:	19db      	adds	r3, r3, r7
    1e0e:	4014      	ands	r4, r2
    1e10:	2c00      	cmp	r4, #0
    1e12:	d005      	beq.n	1e20 <memset+0x8c>
    1e14:	b2c9      	uxtb	r1, r1
    1e16:	191c      	adds	r4, r3, r4
    1e18:	7019      	strb	r1, [r3, #0]
    1e1a:	3301      	adds	r3, #1
    1e1c:	429c      	cmp	r4, r3
    1e1e:	d1fb      	bne.n	1e18 <memset+0x84>
    1e20:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e22:	0014      	movs	r4, r2
    1e24:	0003      	movs	r3, r0
    1e26:	e7c6      	b.n	1db6 <memset+0x22>

00001e28 <register_fini>:
    1e28:	4b03      	ldr	r3, [pc, #12]	; (1e38 <register_fini+0x10>)
    1e2a:	b510      	push	{r4, lr}
    1e2c:	2b00      	cmp	r3, #0
    1e2e:	d002      	beq.n	1e36 <register_fini+0xe>
    1e30:	4802      	ldr	r0, [pc, #8]	; (1e3c <register_fini+0x14>)
    1e32:	f000 f805 	bl	1e40 <atexit>
    1e36:	bd10      	pop	{r4, pc}
    1e38:	00000000 	.word	0x00000000
    1e3c:	00001e51 	.word	0x00001e51

00001e40 <atexit>:
    1e40:	b510      	push	{r4, lr}
    1e42:	0001      	movs	r1, r0
    1e44:	2300      	movs	r3, #0
    1e46:	2200      	movs	r2, #0
    1e48:	2000      	movs	r0, #0
    1e4a:	f000 f81f 	bl	1e8c <__register_exitproc>
    1e4e:	bd10      	pop	{r4, pc}

00001e50 <__libc_fini_array>:
    1e50:	b570      	push	{r4, r5, r6, lr}
    1e52:	4b09      	ldr	r3, [pc, #36]	; (1e78 <__libc_fini_array+0x28>)
    1e54:	4c09      	ldr	r4, [pc, #36]	; (1e7c <__libc_fini_array+0x2c>)
    1e56:	1ae4      	subs	r4, r4, r3
    1e58:	10a4      	asrs	r4, r4, #2
    1e5a:	d009      	beq.n	1e70 <__libc_fini_array+0x20>
    1e5c:	4a08      	ldr	r2, [pc, #32]	; (1e80 <__libc_fini_array+0x30>)
    1e5e:	18a5      	adds	r5, r4, r2
    1e60:	00ad      	lsls	r5, r5, #2
    1e62:	18ed      	adds	r5, r5, r3
    1e64:	682b      	ldr	r3, [r5, #0]
    1e66:	3c01      	subs	r4, #1
    1e68:	4798      	blx	r3
    1e6a:	3d04      	subs	r5, #4
    1e6c:	2c00      	cmp	r4, #0
    1e6e:	d1f9      	bne.n	1e64 <__libc_fini_array+0x14>
    1e70:	f000 f8ca 	bl	2008 <_fini>
    1e74:	bd70      	pop	{r4, r5, r6, pc}
    1e76:	46c0      	nop			; (mov r8, r8)
    1e78:	00002014 	.word	0x00002014
    1e7c:	00002018 	.word	0x00002018
    1e80:	3fffffff 	.word	0x3fffffff

00001e84 <__retarget_lock_acquire_recursive>:
    1e84:	4770      	bx	lr
    1e86:	46c0      	nop			; (mov r8, r8)

00001e88 <__retarget_lock_release_recursive>:
    1e88:	4770      	bx	lr
    1e8a:	46c0      	nop			; (mov r8, r8)

00001e8c <__register_exitproc>:
    1e8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e8e:	464e      	mov	r6, r9
    1e90:	4645      	mov	r5, r8
    1e92:	46de      	mov	lr, fp
    1e94:	4657      	mov	r7, sl
    1e96:	b5e0      	push	{r5, r6, r7, lr}
    1e98:	4d36      	ldr	r5, [pc, #216]	; (1f74 <__register_exitproc+0xe8>)
    1e9a:	b083      	sub	sp, #12
    1e9c:	0006      	movs	r6, r0
    1e9e:	6828      	ldr	r0, [r5, #0]
    1ea0:	4698      	mov	r8, r3
    1ea2:	000f      	movs	r7, r1
    1ea4:	4691      	mov	r9, r2
    1ea6:	f7ff ffed 	bl	1e84 <__retarget_lock_acquire_recursive>
    1eaa:	4b33      	ldr	r3, [pc, #204]	; (1f78 <__register_exitproc+0xec>)
    1eac:	681c      	ldr	r4, [r3, #0]
    1eae:	23a4      	movs	r3, #164	; 0xa4
    1eb0:	005b      	lsls	r3, r3, #1
    1eb2:	58e0      	ldr	r0, [r4, r3]
    1eb4:	2800      	cmp	r0, #0
    1eb6:	d052      	beq.n	1f5e <__register_exitproc+0xd2>
    1eb8:	6843      	ldr	r3, [r0, #4]
    1eba:	2b1f      	cmp	r3, #31
    1ebc:	dc13      	bgt.n	1ee6 <__register_exitproc+0x5a>
    1ebe:	1c5a      	adds	r2, r3, #1
    1ec0:	9201      	str	r2, [sp, #4]
    1ec2:	2e00      	cmp	r6, #0
    1ec4:	d128      	bne.n	1f18 <__register_exitproc+0x8c>
    1ec6:	9a01      	ldr	r2, [sp, #4]
    1ec8:	3302      	adds	r3, #2
    1eca:	009b      	lsls	r3, r3, #2
    1ecc:	6042      	str	r2, [r0, #4]
    1ece:	501f      	str	r7, [r3, r0]
    1ed0:	6828      	ldr	r0, [r5, #0]
    1ed2:	f7ff ffd9 	bl	1e88 <__retarget_lock_release_recursive>
    1ed6:	2000      	movs	r0, #0
    1ed8:	b003      	add	sp, #12
    1eda:	bc3c      	pop	{r2, r3, r4, r5}
    1edc:	4690      	mov	r8, r2
    1ede:	4699      	mov	r9, r3
    1ee0:	46a2      	mov	sl, r4
    1ee2:	46ab      	mov	fp, r5
    1ee4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1ee6:	4b25      	ldr	r3, [pc, #148]	; (1f7c <__register_exitproc+0xf0>)
    1ee8:	2b00      	cmp	r3, #0
    1eea:	d03d      	beq.n	1f68 <__register_exitproc+0xdc>
    1eec:	20c8      	movs	r0, #200	; 0xc8
    1eee:	0040      	lsls	r0, r0, #1
    1ef0:	e000      	b.n	1ef4 <__register_exitproc+0x68>
    1ef2:	bf00      	nop
    1ef4:	2800      	cmp	r0, #0
    1ef6:	d037      	beq.n	1f68 <__register_exitproc+0xdc>
    1ef8:	22a4      	movs	r2, #164	; 0xa4
    1efa:	2300      	movs	r3, #0
    1efc:	0052      	lsls	r2, r2, #1
    1efe:	58a1      	ldr	r1, [r4, r2]
    1f00:	6043      	str	r3, [r0, #4]
    1f02:	6001      	str	r1, [r0, #0]
    1f04:	50a0      	str	r0, [r4, r2]
    1f06:	3240      	adds	r2, #64	; 0x40
    1f08:	5083      	str	r3, [r0, r2]
    1f0a:	3204      	adds	r2, #4
    1f0c:	5083      	str	r3, [r0, r2]
    1f0e:	3301      	adds	r3, #1
    1f10:	9301      	str	r3, [sp, #4]
    1f12:	2300      	movs	r3, #0
    1f14:	2e00      	cmp	r6, #0
    1f16:	d0d6      	beq.n	1ec6 <__register_exitproc+0x3a>
    1f18:	009a      	lsls	r2, r3, #2
    1f1a:	4692      	mov	sl, r2
    1f1c:	4482      	add	sl, r0
    1f1e:	464a      	mov	r2, r9
    1f20:	2188      	movs	r1, #136	; 0x88
    1f22:	4654      	mov	r4, sl
    1f24:	5062      	str	r2, [r4, r1]
    1f26:	22c4      	movs	r2, #196	; 0xc4
    1f28:	0052      	lsls	r2, r2, #1
    1f2a:	4691      	mov	r9, r2
    1f2c:	4481      	add	r9, r0
    1f2e:	464a      	mov	r2, r9
    1f30:	3987      	subs	r1, #135	; 0x87
    1f32:	4099      	lsls	r1, r3
    1f34:	6812      	ldr	r2, [r2, #0]
    1f36:	468b      	mov	fp, r1
    1f38:	430a      	orrs	r2, r1
    1f3a:	4694      	mov	ip, r2
    1f3c:	464a      	mov	r2, r9
    1f3e:	4661      	mov	r1, ip
    1f40:	6011      	str	r1, [r2, #0]
    1f42:	2284      	movs	r2, #132	; 0x84
    1f44:	4641      	mov	r1, r8
    1f46:	0052      	lsls	r2, r2, #1
    1f48:	50a1      	str	r1, [r4, r2]
    1f4a:	2e02      	cmp	r6, #2
    1f4c:	d1bb      	bne.n	1ec6 <__register_exitproc+0x3a>
    1f4e:	0002      	movs	r2, r0
    1f50:	465c      	mov	r4, fp
    1f52:	328d      	adds	r2, #141	; 0x8d
    1f54:	32ff      	adds	r2, #255	; 0xff
    1f56:	6811      	ldr	r1, [r2, #0]
    1f58:	430c      	orrs	r4, r1
    1f5a:	6014      	str	r4, [r2, #0]
    1f5c:	e7b3      	b.n	1ec6 <__register_exitproc+0x3a>
    1f5e:	0020      	movs	r0, r4
    1f60:	304d      	adds	r0, #77	; 0x4d
    1f62:	30ff      	adds	r0, #255	; 0xff
    1f64:	50e0      	str	r0, [r4, r3]
    1f66:	e7a7      	b.n	1eb8 <__register_exitproc+0x2c>
    1f68:	6828      	ldr	r0, [r5, #0]
    1f6a:	f7ff ff8d 	bl	1e88 <__retarget_lock_release_recursive>
    1f6e:	2001      	movs	r0, #1
    1f70:	4240      	negs	r0, r0
    1f72:	e7b1      	b.n	1ed8 <__register_exitproc+0x4c>
    1f74:	20000438 	.word	0x20000438
    1f78:	00001ff0 	.word	0x00001ff0
    1f7c:	00000000 	.word	0x00000000
    1f80:	6c65480a 	.word	0x6c65480a
    1f84:	57206f6c 	.word	0x57206f6c
    1f88:	646c726f 	.word	0x646c726f
    1f8c:	73617420 	.word	0x73617420
    1f90:	2031206b 	.word	0x2031206b
    1f94:	00006425 	.word	0x00006425
    1f98:	745f796d 	.word	0x745f796d
    1f9c:	006b7361 	.word	0x006b7361
    1fa0:	454c4449 	.word	0x454c4449
    1fa4:	00000000 	.word	0x00000000
    1fa8:	09632509 	.word	0x09632509
    1fac:	25097525 	.word	0x25097525
    1fb0:	75250975 	.word	0x75250975
    1fb4:	00000a0d 	.word	0x00000a0d
    1fb8:	00001b80 	.word	0x00001b80
    1fbc:	00001b80 	.word	0x00001b80
    1fc0:	00001b80 	.word	0x00001b80
    1fc4:	00001b48 	.word	0x00001b48
    1fc8:	00001bc2 	.word	0x00001bc2
    1fcc:	00001bdc 	.word	0x00001bdc
    1fd0:	00001b80 	.word	0x00001b80
    1fd4:	00001b80 	.word	0x00001b80
    1fd8:	00001b48 	.word	0x00001b48
    1fdc:	00001bc2 	.word	0x00001bc2
    1fe0:	51726d54 	.word	0x51726d54
    1fe4:	00000000 	.word	0x00000000
    1fe8:	20726d54 	.word	0x20726d54
    1fec:	00637653 	.word	0x00637653

00001ff0 <_global_impure_ptr>:
    1ff0:	20000010                                ... 

00001ff4 <_init>:
    1ff4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1ff6:	46c0      	nop			; (mov r8, r8)
    1ff8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    1ffa:	bc08      	pop	{r3}
    1ffc:	469e      	mov	lr, r3
    1ffe:	4770      	bx	lr

00002000 <__init_array_start>:
    2000:	00001e29 	.word	0x00001e29

00002004 <__frame_dummy_init_array_entry>:
    2004:	000000dd                                ....

00002008 <_fini>:
    2008:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    200a:	46c0      	nop			; (mov r8, r8)
    200c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    200e:	bc08      	pop	{r3}
    2010:	469e      	mov	lr, r3
    2012:	4770      	bx	lr

00002014 <__fini_array_start>:
    2014:	000000b5 	.word	0x000000b5
