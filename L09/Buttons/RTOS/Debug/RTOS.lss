
RTOS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002204  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  00002204  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004074  2000043c  00002640  0002043c  2**2
                  ALLOC
  3 .stack        00002000  200044b0  000066b4  0002043c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001346b  00000000  00000000  000204bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000019f2  00000000  00000000  00033928  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000688e  00000000  00000000  0003531a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000658  00000000  00000000  0003bba8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000007b8  00000000  00000000  0003c200  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000119d0  00000000  00000000  0003c9b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000052d4  00000000  00000000  0004e388  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0007a008  00000000  00000000  0005365c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000012ec  00000000  00000000  000cd664  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	b0 64 00 20 19 01 00 00 15 01 00 00 15 01 00 00     .d. ............
	...
      2c:	15 01 00 00 00 00 00 00 00 00 00 00 a1 09 00 00     ................
      3c:	e5 09 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      4c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      5c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      6c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      7c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      8c:	15 01 00 00 15 01 00 00 00 00 00 00 00 00 00 00     ................
      9c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      ac:	15 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000043c 	.word	0x2000043c
      d4:	00000000 	.word	0x00000000
      d8:	00002204 	.word	0x00002204

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000440 	.word	0x20000440
     108:	00002204 	.word	0x00002204
     10c:	00002204 	.word	0x00002204
     110:	00000000 	.word	0x00000000

00000114 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     114:	e7fe      	b.n	114 <Dummy_Handler>
	...

00000118 <Reset_Handler>:
{
     118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     11a:	4a23      	ldr	r2, [pc, #140]	; (1a8 <Reset_Handler+0x90>)
     11c:	4b23      	ldr	r3, [pc, #140]	; (1ac <Reset_Handler+0x94>)
     11e:	429a      	cmp	r2, r3
     120:	d009      	beq.n	136 <Reset_Handler+0x1e>
     122:	4b22      	ldr	r3, [pc, #136]	; (1ac <Reset_Handler+0x94>)
     124:	4a20      	ldr	r2, [pc, #128]	; (1a8 <Reset_Handler+0x90>)
     126:	e003      	b.n	130 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     128:	6811      	ldr	r1, [r2, #0]
     12a:	6019      	str	r1, [r3, #0]
     12c:	3304      	adds	r3, #4
     12e:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     130:	491f      	ldr	r1, [pc, #124]	; (1b0 <Reset_Handler+0x98>)
     132:	428b      	cmp	r3, r1
     134:	d3f8      	bcc.n	128 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     136:	4b1f      	ldr	r3, [pc, #124]	; (1b4 <Reset_Handler+0x9c>)
     138:	e002      	b.n	140 <Reset_Handler+0x28>
                *pDest++ = 0;
     13a:	2200      	movs	r2, #0
     13c:	601a      	str	r2, [r3, #0]
     13e:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     140:	4a1d      	ldr	r2, [pc, #116]	; (1b8 <Reset_Handler+0xa0>)
     142:	4293      	cmp	r3, r2
     144:	d3f9      	bcc.n	13a <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     146:	4a1d      	ldr	r2, [pc, #116]	; (1bc <Reset_Handler+0xa4>)
     148:	21ff      	movs	r1, #255	; 0xff
     14a:	4b1d      	ldr	r3, [pc, #116]	; (1c0 <Reset_Handler+0xa8>)
     14c:	438b      	bics	r3, r1
     14e:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     150:	39fd      	subs	r1, #253	; 0xfd
     152:	2390      	movs	r3, #144	; 0x90
     154:	005b      	lsls	r3, r3, #1
     156:	4a1b      	ldr	r2, [pc, #108]	; (1c4 <Reset_Handler+0xac>)
     158:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     15a:	4a1b      	ldr	r2, [pc, #108]	; (1c8 <Reset_Handler+0xb0>)
     15c:	78d3      	ldrb	r3, [r2, #3]
     15e:	2503      	movs	r5, #3
     160:	43ab      	bics	r3, r5
     162:	2402      	movs	r4, #2
     164:	4323      	orrs	r3, r4
     166:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     168:	78d3      	ldrb	r3, [r2, #3]
     16a:	270c      	movs	r7, #12
     16c:	43bb      	bics	r3, r7
     16e:	2608      	movs	r6, #8
     170:	4333      	orrs	r3, r6
     172:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     174:	4b15      	ldr	r3, [pc, #84]	; (1cc <Reset_Handler+0xb4>)
     176:	7b98      	ldrb	r0, [r3, #14]
     178:	2230      	movs	r2, #48	; 0x30
     17a:	4390      	bics	r0, r2
     17c:	2220      	movs	r2, #32
     17e:	4310      	orrs	r0, r2
     180:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     182:	7b99      	ldrb	r1, [r3, #14]
     184:	43b9      	bics	r1, r7
     186:	4331      	orrs	r1, r6
     188:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     18a:	7b9a      	ldrb	r2, [r3, #14]
     18c:	43aa      	bics	r2, r5
     18e:	4322      	orrs	r2, r4
     190:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     192:	4a0f      	ldr	r2, [pc, #60]	; (1d0 <Reset_Handler+0xb8>)
     194:	6851      	ldr	r1, [r2, #4]
     196:	2380      	movs	r3, #128	; 0x80
     198:	430b      	orrs	r3, r1
     19a:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     19c:	4b0d      	ldr	r3, [pc, #52]	; (1d4 <Reset_Handler+0xbc>)
     19e:	4798      	blx	r3
        main();
     1a0:	4b0d      	ldr	r3, [pc, #52]	; (1d8 <Reset_Handler+0xc0>)
     1a2:	4798      	blx	r3
     1a4:	e7fe      	b.n	1a4 <Reset_Handler+0x8c>
     1a6:	46c0      	nop			; (mov r8, r8)
     1a8:	00002204 	.word	0x00002204
     1ac:	20000000 	.word	0x20000000
     1b0:	2000043c 	.word	0x2000043c
     1b4:	2000043c 	.word	0x2000043c
     1b8:	200044b0 	.word	0x200044b0
     1bc:	e000ed00 	.word	0xe000ed00
     1c0:	00000000 	.word	0x00000000
     1c4:	41007000 	.word	0x41007000
     1c8:	41005000 	.word	0x41005000
     1cc:	41004800 	.word	0x41004800
     1d0:	41004000 	.word	0x41004000
     1d4:	00001e89 	.word	0x00001e89
     1d8:	000004f1 	.word	0x000004f1

000001dc <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
     1dc:	4a01      	ldr	r2, [pc, #4]	; (1e4 <SystemInit+0x8>)
     1de:	4b02      	ldr	r3, [pc, #8]	; (1e8 <SystemInit+0xc>)
     1e0:	601a      	str	r2, [r3, #0]
        return;
}
     1e2:	4770      	bx	lr
     1e4:	000f4240 	.word	0x000f4240
     1e8:	20000000 	.word	0x20000000

000001ec <prvHeapInit>:
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     1ec:	2207      	movs	r2, #7
     1ee:	4b07      	ldr	r3, [pc, #28]	; (20c <prvHeapInit+0x20>)
     1f0:	3308      	adds	r3, #8
     1f2:	4393      	bics	r3, r2

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     1f4:	4a06      	ldr	r2, [pc, #24]	; (210 <prvHeapInit+0x24>)
     1f6:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
     1f8:	2000      	movs	r0, #0
     1fa:	6050      	str	r0, [r2, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     1fc:	4905      	ldr	r1, [pc, #20]	; (214 <prvHeapInit+0x28>)
     1fe:	60d1      	str	r1, [r2, #12]
	xEnd.pxNextFreeBlock = NULL;
     200:	6090      	str	r0, [r2, #8]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     202:	6059      	str	r1, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     204:	3208      	adds	r2, #8
     206:	601a      	str	r2, [r3, #0]
}
     208:	4770      	bx	lr
     20a:	46c0      	nop			; (mov r8, r8)
     20c:	20000458 	.word	0x20000458
     210:	200042d8 	.word	0x200042d8
     214:	00003e78 	.word	0x00003e78

00000218 <pvPortMalloc>:
{
     218:	b570      	push	{r4, r5, r6, lr}
     21a:	0004      	movs	r4, r0
	vTaskSuspendAll();
     21c:	4b24      	ldr	r3, [pc, #144]	; (2b0 <pvPortMalloc+0x98>)
     21e:	4798      	blx	r3
		if( xHeapHasBeenInitialised == pdFALSE )
     220:	4b24      	ldr	r3, [pc, #144]	; (2b4 <pvPortMalloc+0x9c>)
     222:	691b      	ldr	r3, [r3, #16]
     224:	2b00      	cmp	r3, #0
     226:	d00e      	beq.n	246 <pvPortMalloc+0x2e>
		if( xWantedSize > 0 )
     228:	2c00      	cmp	r4, #0
     22a:	d005      	beq.n	238 <pvPortMalloc+0x20>
			xWantedSize += heapSTRUCT_SIZE;
     22c:	3408      	adds	r4, #8
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
     22e:	0763      	lsls	r3, r4, #29
     230:	d002      	beq.n	238 <pvPortMalloc+0x20>
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
     232:	2307      	movs	r3, #7
     234:	439c      	bics	r4, r3
     236:	3408      	adds	r4, #8
		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     238:	1e63      	subs	r3, r4, #1
     23a:	4a1f      	ldr	r2, [pc, #124]	; (2b8 <pvPortMalloc+0xa0>)
     23c:	4293      	cmp	r3, r2
     23e:	d832      	bhi.n	2a6 <pvPortMalloc+0x8e>
			pxBlock = xStart.pxNextFreeBlock;
     240:	491c      	ldr	r1, [pc, #112]	; (2b4 <pvPortMalloc+0x9c>)
     242:	680b      	ldr	r3, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     244:	e007      	b.n	256 <pvPortMalloc+0x3e>
			prvHeapInit();
     246:	4b1d      	ldr	r3, [pc, #116]	; (2bc <pvPortMalloc+0xa4>)
     248:	4798      	blx	r3
			xHeapHasBeenInitialised = pdTRUE;
     24a:	2201      	movs	r2, #1
     24c:	4b19      	ldr	r3, [pc, #100]	; (2b4 <pvPortMalloc+0x9c>)
     24e:	611a      	str	r2, [r3, #16]
     250:	e7ea      	b.n	228 <pvPortMalloc+0x10>
				pxPreviousBlock = pxBlock;
     252:	0019      	movs	r1, r3
				pxBlock = pxBlock->pxNextFreeBlock;
     254:	0013      	movs	r3, r2
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     256:	685a      	ldr	r2, [r3, #4]
     258:	4294      	cmp	r4, r2
     25a:	d902      	bls.n	262 <pvPortMalloc+0x4a>
     25c:	681a      	ldr	r2, [r3, #0]
     25e:	2a00      	cmp	r2, #0
     260:	d1f7      	bne.n	252 <pvPortMalloc+0x3a>
			if( pxBlock != &xEnd )
     262:	4a14      	ldr	r2, [pc, #80]	; (2b4 <pvPortMalloc+0x9c>)
     264:	3208      	adds	r2, #8
     266:	4293      	cmp	r3, r2
     268:	d01f      	beq.n	2aa <pvPortMalloc+0x92>
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     26a:	680d      	ldr	r5, [r1, #0]
     26c:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     26e:	681a      	ldr	r2, [r3, #0]
     270:	600a      	str	r2, [r1, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     272:	685a      	ldr	r2, [r3, #4]
     274:	1b12      	subs	r2, r2, r4
     276:	2a10      	cmp	r2, #16
     278:	d90c      	bls.n	294 <pvPortMalloc+0x7c>
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     27a:	191e      	adds	r6, r3, r4
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     27c:	6072      	str	r2, [r6, #4]
					pxBlock->xBlockSize = xWantedSize;
     27e:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     280:	6870      	ldr	r0, [r6, #4]
     282:	490c      	ldr	r1, [pc, #48]	; (2b4 <pvPortMalloc+0x9c>)
     284:	e000      	b.n	288 <pvPortMalloc+0x70>
     286:	0011      	movs	r1, r2
     288:	680a      	ldr	r2, [r1, #0]
     28a:	6854      	ldr	r4, [r2, #4]
     28c:	42a0      	cmp	r0, r4
     28e:	d8fa      	bhi.n	286 <pvPortMalloc+0x6e>
     290:	6032      	str	r2, [r6, #0]
     292:	600e      	str	r6, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     294:	685b      	ldr	r3, [r3, #4]
     296:	4a0a      	ldr	r2, [pc, #40]	; (2c0 <pvPortMalloc+0xa8>)
     298:	6811      	ldr	r1, [r2, #0]
     29a:	1acb      	subs	r3, r1, r3
     29c:	6013      	str	r3, [r2, #0]
	( void ) xTaskResumeAll();
     29e:	4b09      	ldr	r3, [pc, #36]	; (2c4 <pvPortMalloc+0xac>)
     2a0:	4798      	blx	r3
}
     2a2:	0028      	movs	r0, r5
     2a4:	bd70      	pop	{r4, r5, r6, pc}
void *pvReturn = NULL;
     2a6:	2500      	movs	r5, #0
     2a8:	e7f9      	b.n	29e <pvPortMalloc+0x86>
     2aa:	2500      	movs	r5, #0
     2ac:	e7f7      	b.n	29e <pvPortMalloc+0x86>
     2ae:	46c0      	nop			; (mov r8, r8)
     2b0:	00001509 	.word	0x00001509
     2b4:	200042d8 	.word	0x200042d8
     2b8:	00003e76 	.word	0x00003e76
     2bc:	000001ed 	.word	0x000001ed
     2c0:	20000004 	.word	0x20000004
     2c4:	00001631 	.word	0x00001631

000002c8 <vPortFree>:
{
     2c8:	b570      	push	{r4, r5, r6, lr}
     2ca:	1e04      	subs	r4, r0, #0
	if( pv != NULL )
     2cc:	d016      	beq.n	2fc <vPortFree+0x34>
		puc -= heapSTRUCT_SIZE;
     2ce:	0005      	movs	r5, r0
     2d0:	3d08      	subs	r5, #8
		vTaskSuspendAll();
     2d2:	4b0b      	ldr	r3, [pc, #44]	; (300 <vPortFree+0x38>)
     2d4:	4798      	blx	r3
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     2d6:	6869      	ldr	r1, [r5, #4]
     2d8:	4a0a      	ldr	r2, [pc, #40]	; (304 <vPortFree+0x3c>)
     2da:	e000      	b.n	2de <vPortFree+0x16>
     2dc:	001a      	movs	r2, r3
     2de:	6813      	ldr	r3, [r2, #0]
     2e0:	6858      	ldr	r0, [r3, #4]
     2e2:	4281      	cmp	r1, r0
     2e4:	d8fa      	bhi.n	2dc <vPortFree+0x14>
     2e6:	3c08      	subs	r4, #8
     2e8:	6023      	str	r3, [r4, #0]
     2ea:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
     2ec:	6863      	ldr	r3, [r4, #4]
     2ee:	4a06      	ldr	r2, [pc, #24]	; (308 <vPortFree+0x40>)
     2f0:	6811      	ldr	r1, [r2, #0]
     2f2:	468c      	mov	ip, r1
     2f4:	4463      	add	r3, ip
     2f6:	6013      	str	r3, [r2, #0]
		( void ) xTaskResumeAll();
     2f8:	4b04      	ldr	r3, [pc, #16]	; (30c <vPortFree+0x44>)
     2fa:	4798      	blx	r3
}
     2fc:	bd70      	pop	{r4, r5, r6, pc}
     2fe:	46c0      	nop			; (mov r8, r8)
     300:	00001509 	.word	0x00001509
     304:	200042d8 	.word	0x200042d8
     308:	20000004 	.word	0x20000004
     30c:	00001631 	.word	0x00001631

00000310 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     310:	0003      	movs	r3, r0
     312:	3308      	adds	r3, #8
     314:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     316:	2201      	movs	r2, #1
     318:	4252      	negs	r2, r2
     31a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     31c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     31e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     320:	2300      	movs	r3, #0
     322:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     324:	4770      	bx	lr

00000326 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     326:	2300      	movs	r3, #0
     328:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     32a:	4770      	bx	lr

0000032c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     32c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     32e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     330:	689a      	ldr	r2, [r3, #8]
     332:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     334:	689a      	ldr	r2, [r3, #8]
     336:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     338:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     33a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     33c:	6803      	ldr	r3, [r0, #0]
     33e:	3301      	adds	r3, #1
     340:	6003      	str	r3, [r0, #0]
}
     342:	4770      	bx	lr

00000344 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     344:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     346:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     348:	1c63      	adds	r3, r4, #1
     34a:	d002      	beq.n	352 <vListInsert+0xe>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     34c:	0002      	movs	r2, r0
     34e:	3208      	adds	r2, #8
     350:	e002      	b.n	358 <vListInsert+0x14>
		pxIterator = pxList->xListEnd.pxPrevious;
     352:	6902      	ldr	r2, [r0, #16]
     354:	e004      	b.n	360 <vListInsert+0x1c>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     356:	001a      	movs	r2, r3
     358:	6853      	ldr	r3, [r2, #4]
     35a:	681d      	ldr	r5, [r3, #0]
     35c:	42ac      	cmp	r4, r5
     35e:	d2fa      	bcs.n	356 <vListInsert+0x12>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     360:	6853      	ldr	r3, [r2, #4]
     362:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     364:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
     366:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
     368:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     36a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     36c:	6803      	ldr	r3, [r0, #0]
     36e:	3301      	adds	r3, #1
     370:	6003      	str	r3, [r0, #0]
}
     372:	bd30      	pop	{r4, r5, pc}

00000374 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     374:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     376:	6842      	ldr	r2, [r0, #4]
     378:	6881      	ldr	r1, [r0, #8]
     37a:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     37c:	6882      	ldr	r2, [r0, #8]
     37e:	6841      	ldr	r1, [r0, #4]
     380:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     382:	685a      	ldr	r2, [r3, #4]
     384:	4290      	cmp	r0, r2
     386:	d006      	beq.n	396 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     388:	2200      	movs	r2, #0
     38a:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     38c:	681a      	ldr	r2, [r3, #0]
     38e:	3a01      	subs	r2, #1
     390:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     392:	6818      	ldr	r0, [r3, #0]
}
     394:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     396:	6882      	ldr	r2, [r0, #8]
     398:	605a      	str	r2, [r3, #4]
     39a:	e7f5      	b.n	388 <uxListRemove+0x14>

0000039c <sender_task_1>:
#define myTASK_TASK_PRIORITY         	( tskIDLE_PRIORITY + 1 )

int states = 0;

xQueueHandle Global_Queue_Handle = 0;
void sender_task_1(void *p) {
     39c:	b510      	push	{r4, lr}
     39e:	b082      	sub	sp, #8
	uint32_t i = 0;
     3a0:	2300      	movs	r3, #0
     3a2:	9301      	str	r3, [sp, #4]
     3a4:	e00c      	b.n	3c0 <sender_task_1+0x24>
		
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA14 ) ) == _U_( 0x00000000 ) )
		{
			i = 1;
		} else
		 i= 0;
     3a6:	2300      	movs	r3, #0
     3a8:	9301      	str	r3, [sp, #4]
		xQueueSend(Global_Queue_Handle,&i,100);
     3aa:	4b09      	ldr	r3, [pc, #36]	; (3d0 <sender_task_1+0x34>)
     3ac:	6818      	ldr	r0, [r3, #0]
     3ae:	2300      	movs	r3, #0
     3b0:	2264      	movs	r2, #100	; 0x64
     3b2:	a901      	add	r1, sp, #4
     3b4:	4c07      	ldr	r4, [pc, #28]	; (3d4 <sender_task_1+0x38>)
     3b6:	47a0      	blx	r4
		
	
		
		vTaskDelay(wait_send);
     3b8:	2096      	movs	r0, #150	; 0x96
     3ba:	0040      	lsls	r0, r0, #1
     3bc:	4b06      	ldr	r3, [pc, #24]	; (3d8 <sender_task_1+0x3c>)
     3be:	4798      	blx	r3
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA14 ) ) == _U_( 0x00000000 ) )
     3c0:	4b06      	ldr	r3, [pc, #24]	; (3dc <sender_task_1+0x40>)
     3c2:	6a1b      	ldr	r3, [r3, #32]
     3c4:	045b      	lsls	r3, r3, #17
     3c6:	d4ee      	bmi.n	3a6 <sender_task_1+0xa>
			i = 1;
     3c8:	2301      	movs	r3, #1
     3ca:	9301      	str	r3, [sp, #4]
     3cc:	e7ed      	b.n	3aa <sender_task_1+0xe>
     3ce:	46c0      	nop			; (mov r8, r8)
     3d0:	200042ec 	.word	0x200042ec
     3d4:	00000d11 	.word	0x00000d11
     3d8:	00001725 	.word	0x00001725
     3dc:	41004400 	.word	0x41004400

000003e0 <sender_task_2>:
	}
}

void sender_task_2(void *p) {
     3e0:	b510      	push	{r4, lr}
     3e2:	b082      	sub	sp, #8
	uint32_t i = 0;
     3e4:	2300      	movs	r3, #0
     3e6:	9301      	str	r3, [sp, #4]
     3e8:	e00c      	b.n	404 <sender_task_2+0x24>
	while(1) {
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA09 ) ) == _U_( 0x00000000 ) )
		{
			i = 2;
		} else
		 i= 0;
     3ea:	2300      	movs	r3, #0
     3ec:	9301      	str	r3, [sp, #4]
		xQueueSend(Global_Queue_Handle,&i,100);
     3ee:	4b09      	ldr	r3, [pc, #36]	; (414 <sender_task_2+0x34>)
     3f0:	6818      	ldr	r0, [r3, #0]
     3f2:	2300      	movs	r3, #0
     3f4:	2264      	movs	r2, #100	; 0x64
     3f6:	a901      	add	r1, sp, #4
     3f8:	4c07      	ldr	r4, [pc, #28]	; (418 <sender_task_2+0x38>)
     3fa:	47a0      	blx	r4
		//if(!xQueueSend(Global_Queue_Handle,&i,100))
			//{
				//myprintf("\nFailed to send to the Queue \n");
			//}
		
		vTaskDelay(wait_send);
     3fc:	2096      	movs	r0, #150	; 0x96
     3fe:	0040      	lsls	r0, r0, #1
     400:	4b06      	ldr	r3, [pc, #24]	; (41c <sender_task_2+0x3c>)
     402:	4798      	blx	r3
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA09 ) ) == _U_( 0x00000000 ) )
     404:	4b06      	ldr	r3, [pc, #24]	; (420 <sender_task_2+0x40>)
     406:	6a1b      	ldr	r3, [r3, #32]
     408:	059b      	lsls	r3, r3, #22
     40a:	d4ee      	bmi.n	3ea <sender_task_2+0xa>
			i = 2;
     40c:	2302      	movs	r3, #2
     40e:	9301      	str	r3, [sp, #4]
     410:	e7ed      	b.n	3ee <sender_task_2+0xe>
     412:	46c0      	nop			; (mov r8, r8)
     414:	200042ec 	.word	0x200042ec
     418:	00000d11 	.word	0x00000d11
     41c:	00001725 	.word	0x00001725
     420:	41004400 	.word	0x41004400

00000424 <sender_task_3>:
	}
}

void sender_task_3(void *p) {
     424:	b510      	push	{r4, lr}
     426:	b082      	sub	sp, #8
	uint32_t i = 0;
     428:	2300      	movs	r3, #0
     42a:	9301      	str	r3, [sp, #4]
     42c:	e00c      	b.n	448 <sender_task_3+0x24>
		
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA08 ) ) == _U_( 0x00000000 ) )
		{
			i = 3;
		} else
		 i= 0;
     42e:	2300      	movs	r3, #0
     430:	9301      	str	r3, [sp, #4]
		xQueueSend(Global_Queue_Handle,&i,100);
     432:	4b09      	ldr	r3, [pc, #36]	; (458 <sender_task_3+0x34>)
     434:	6818      	ldr	r0, [r3, #0]
     436:	2300      	movs	r3, #0
     438:	2264      	movs	r2, #100	; 0x64
     43a:	a901      	add	r1, sp, #4
     43c:	4c07      	ldr	r4, [pc, #28]	; (45c <sender_task_3+0x38>)
     43e:	47a0      	blx	r4
		vTaskDelay(wait_send);
     440:	2096      	movs	r0, #150	; 0x96
     442:	0040      	lsls	r0, r0, #1
     444:	4b06      	ldr	r3, [pc, #24]	; (460 <sender_task_3+0x3c>)
     446:	4798      	blx	r3
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA08 ) ) == _U_( 0x00000000 ) )
     448:	4b06      	ldr	r3, [pc, #24]	; (464 <sender_task_3+0x40>)
     44a:	6a1b      	ldr	r3, [r3, #32]
     44c:	05db      	lsls	r3, r3, #23
     44e:	d4ee      	bmi.n	42e <sender_task_3+0xa>
			i = 3;
     450:	2303      	movs	r3, #3
     452:	9301      	str	r3, [sp, #4]
     454:	e7ed      	b.n	432 <sender_task_3+0xe>
     456:	46c0      	nop			; (mov r8, r8)
     458:	200042ec 	.word	0x200042ec
     45c:	00000d11 	.word	0x00000d11
     460:	00001725 	.word	0x00001725
     464:	41004400 	.word	0x41004400

00000468 <sender_task_4>:
	}
}

void sender_task_4(void *p) {
     468:	b510      	push	{r4, lr}
     46a:	b082      	sub	sp, #8
	uint32_t i = 0;
     46c:	2300      	movs	r3, #0
     46e:	9301      	str	r3, [sp, #4]
     470:	e00c      	b.n	48c <sender_task_4+0x24>
		
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA15 ) ) == _U_( 0x00000000 ) )
		{
			i = 4;
		} else
		 i= 0;
     472:	2300      	movs	r3, #0
     474:	9301      	str	r3, [sp, #4]
		xQueueSend(Global_Queue_Handle,&i,100);
     476:	4b09      	ldr	r3, [pc, #36]	; (49c <sender_task_4+0x34>)
     478:	6818      	ldr	r0, [r3, #0]
     47a:	2300      	movs	r3, #0
     47c:	2264      	movs	r2, #100	; 0x64
     47e:	a901      	add	r1, sp, #4
     480:	4c07      	ldr	r4, [pc, #28]	; (4a0 <sender_task_4+0x38>)
     482:	47a0      	blx	r4
		
		
		vTaskDelay(wait_send);
     484:	2096      	movs	r0, #150	; 0x96
     486:	0040      	lsls	r0, r0, #1
     488:	4b06      	ldr	r3, [pc, #24]	; (4a4 <sender_task_4+0x3c>)
     48a:	4798      	blx	r3
		if( ( PORT->Group[ 0 ].IN.reg & PORT_IN_IN( PORT_PA15 ) ) == _U_( 0x00000000 ) )
     48c:	4b06      	ldr	r3, [pc, #24]	; (4a8 <sender_task_4+0x40>)
     48e:	6a1b      	ldr	r3, [r3, #32]
     490:	041b      	lsls	r3, r3, #16
     492:	d4ee      	bmi.n	472 <sender_task_4+0xa>
			i = 4;
     494:	2304      	movs	r3, #4
     496:	9301      	str	r3, [sp, #4]
     498:	e7ed      	b.n	476 <sender_task_4+0xe>
     49a:	46c0      	nop			; (mov r8, r8)
     49c:	200042ec 	.word	0x200042ec
     4a0:	00000d11 	.word	0x00000d11
     4a4:	00001725 	.word	0x00001725
     4a8:	41004400 	.word	0x41004400

000004ac <receiver_task>:
	}
}


void receiver_task(void *p) {
     4ac:	b500      	push	{lr}
     4ae:	b083      	sub	sp, #12
	int rx_int=0;
     4b0:	2300      	movs	r3, #0
     4b2:	9301      	str	r3, [sp, #4]
     4b4:	e002      	b.n	4bc <receiver_task+0x10>
			if (rx_int>0)
			{
				myprintf("\nState on in port %d\n", rx_int);
			}
		}
		vTaskDelay(wait_recieve);
     4b6:	2064      	movs	r0, #100	; 0x64
     4b8:	4b08      	ldr	r3, [pc, #32]	; (4dc <receiver_task+0x30>)
     4ba:	4798      	blx	r3
		if(xQueueReceive(Global_Queue_Handle, &rx_int,100))
     4bc:	4b08      	ldr	r3, [pc, #32]	; (4e0 <receiver_task+0x34>)
     4be:	6818      	ldr	r0, [r3, #0]
     4c0:	2264      	movs	r2, #100	; 0x64
     4c2:	a901      	add	r1, sp, #4
     4c4:	4b07      	ldr	r3, [pc, #28]	; (4e4 <receiver_task+0x38>)
     4c6:	4798      	blx	r3
     4c8:	2800      	cmp	r0, #0
     4ca:	d0f4      	beq.n	4b6 <receiver_task+0xa>
			if (rx_int>0)
     4cc:	9901      	ldr	r1, [sp, #4]
     4ce:	2900      	cmp	r1, #0
     4d0:	ddf1      	ble.n	4b6 <receiver_task+0xa>
				myprintf("\nState on in port %d\n", rx_int);
     4d2:	4805      	ldr	r0, [pc, #20]	; (4e8 <receiver_task+0x3c>)
     4d4:	4b05      	ldr	r3, [pc, #20]	; (4ec <receiver_task+0x40>)
     4d6:	4798      	blx	r3
     4d8:	e7ed      	b.n	4b6 <receiver_task+0xa>
     4da:	46c0      	nop			; (mov r8, r8)
     4dc:	00001725 	.word	0x00001725
     4e0:	200042ec 	.word	0x200042ec
     4e4:	00000f8d 	.word	0x00000f8d
     4e8:	00002140 	.word	0x00002140
     4ec:	0000069d 	.word	0x0000069d

000004f0 <main>:
}



int main()
{
     4f0:	b5f0      	push	{r4, r5, r6, r7, lr}
     4f2:	b083      	sub	sp, #12
	SystemInit();
     4f4:	4b29      	ldr	r3, [pc, #164]	; (59c <main+0xac>)
     4f6:	4798      	blx	r3
	/* Switch to 8MHz clock (disable prescaler) */
	SYSCTRL->OSC8M.bit.PRESC = 0;
     4f8:	4a29      	ldr	r2, [pc, #164]	; (5a0 <main+0xb0>)
     4fa:	6a11      	ldr	r1, [r2, #32]
     4fc:	4b29      	ldr	r3, [pc, #164]	; (5a4 <main+0xb4>)
     4fe:	400b      	ands	r3, r1
     500:	6213      	str	r3, [r2, #32]
	initUART();
     502:	4b29      	ldr	r3, [pc, #164]	; (5a8 <main+0xb8>)
     504:	4798      	blx	r3

	Global_Queue_Handle = xQueueCreate(3,sizeof(int));
     506:	2200      	movs	r2, #0
     508:	2104      	movs	r1, #4
     50a:	2003      	movs	r0, #3
     50c:	4b27      	ldr	r3, [pc, #156]	; (5ac <main+0xbc>)
     50e:	4798      	blx	r3
     510:	4b27      	ldr	r3, [pc, #156]	; (5b0 <main+0xc0>)
     512:	6018      	str	r0, [r3, #0]
	
	PORT->Group[ 0 ].PINCFG[ PIN_PA16 ].reg = 0x2; //bit INEN must be set for input pins
     514:	4b27      	ldr	r3, [pc, #156]	; (5b4 <main+0xc4>)
     516:	2402      	movs	r4, #2
     518:	2250      	movs	r2, #80	; 0x50
     51a:	549c      	strb	r4, [r3, r2]
	PORT->Group[ 0 ].PINCFG[ PIN_PA27 ].reg = 0x0; //bit PMUXEN must be clear for GPIOs
     51c:	2600      	movs	r6, #0
     51e:	320b      	adds	r2, #11
     520:	549e      	strb	r6, [r3, r2]

	PORT->Group[ 0 ].DIRCLR.reg = PORT_PA16; //pin 16 declared as data input
     522:	2280      	movs	r2, #128	; 0x80
     524:	0252      	lsls	r2, r2, #9
     526:	605a      	str	r2, [r3, #4]
	PORT->Group[ 0 ].DIRSET.reg = PORT_PA27; //pin 27 TX LED declared as data output
     528:	2280      	movs	r2, #128	; 0x80
     52a:	0512      	lsls	r2, r2, #20
     52c:	609a      	str	r2, [r3, #8]
	
	PORT->Group[ 0 ].PINCFG[ PIN_PA09 ].reg = 0x2; //bit INEN must be set for input pins
     52e:	2249      	movs	r2, #73	; 0x49
     530:	549c      	strb	r4, [r3, r2]
	PORT->Group[ 0 ].DIRCLR.reg = PORT_PA09; //pin 16 declared as data input
     532:	2580      	movs	r5, #128	; 0x80
     534:	00ad      	lsls	r5, r5, #2
     536:	605d      	str	r5, [r3, #4]
	PORT->Group[ 0 ].PINCFG[ PIN_PA08 ].reg = 0x2; //bit INEN must be set for input pins
     538:	3a01      	subs	r2, #1
     53a:	549c      	strb	r4, [r3, r2]
	PORT->Group[ 0 ].DIRCLR.reg = PORT_PA08; //pin 16 declared as data input
     53c:	32b8      	adds	r2, #184	; 0xb8
     53e:	605a      	str	r2, [r3, #4]
	PORT->Group[ 0 ].PINCFG[ PIN_PA15 ].reg = 0x2; //bit INEN must be set for input pins
     540:	3ab1      	subs	r2, #177	; 0xb1
     542:	549c      	strb	r4, [r3, r2]
	PORT->Group[ 0 ].DIRCLR.reg = PORT_PA15; //pin 16 declared as data input
     544:	2280      	movs	r2, #128	; 0x80
     546:	0212      	lsls	r2, r2, #8
     548:	605a      	str	r2, [r3, #4]
	

	xTaskCreate(sender_task_1,(signed char* )"Button 1",512,NULL,2,NULL);
     54a:	9601      	str	r6, [sp, #4]
     54c:	9400      	str	r4, [sp, #0]
     54e:	2300      	movs	r3, #0
     550:	002a      	movs	r2, r5
     552:	4919      	ldr	r1, [pc, #100]	; (5b8 <main+0xc8>)
     554:	4819      	ldr	r0, [pc, #100]	; (5bc <main+0xcc>)
     556:	4f1a      	ldr	r7, [pc, #104]	; (5c0 <main+0xd0>)
     558:	47b8      	blx	r7
	xTaskCreate(sender_task_2,(signed char* )"Button 2",512,NULL,2,NULL);
     55a:	9601      	str	r6, [sp, #4]
     55c:	9400      	str	r4, [sp, #0]
     55e:	2300      	movs	r3, #0
     560:	002a      	movs	r2, r5
     562:	4918      	ldr	r1, [pc, #96]	; (5c4 <main+0xd4>)
     564:	4818      	ldr	r0, [pc, #96]	; (5c8 <main+0xd8>)
     566:	47b8      	blx	r7
	xTaskCreate(sender_task_3,(signed char* )"Button 3",512,NULL,2,NULL);
     568:	9601      	str	r6, [sp, #4]
     56a:	9400      	str	r4, [sp, #0]
     56c:	2300      	movs	r3, #0
     56e:	002a      	movs	r2, r5
     570:	4916      	ldr	r1, [pc, #88]	; (5cc <main+0xdc>)
     572:	4817      	ldr	r0, [pc, #92]	; (5d0 <main+0xe0>)
     574:	47b8      	blx	r7
	xTaskCreate(sender_task_4,(signed char* )"Button 4",512,NULL,2,NULL);
     576:	9601      	str	r6, [sp, #4]
     578:	9400      	str	r4, [sp, #0]
     57a:	2300      	movs	r3, #0
     57c:	002a      	movs	r2, r5
     57e:	4915      	ldr	r1, [pc, #84]	; (5d4 <main+0xe4>)
     580:	4815      	ldr	r0, [pc, #84]	; (5d8 <main+0xe8>)
     582:	47b8      	blx	r7
	"my_task",              /* The text name assigned to the task. 
	512,            	    /* The size of the stack to allocate to the task. 
	NULL,           	    /* The parameter passed to the task  
	myTASK_TASK_PRIORITY,   /* The priority assigned to the task. 
	NULL );         	    /* The task handle is not required, so NULL is passed.                  */
    xTaskCreate(receiver_task,(signed char* )"Ack",512,NULL,1,NULL);
     584:	9601      	str	r6, [sp, #4]
     586:	2301      	movs	r3, #1
     588:	9300      	str	r3, [sp, #0]
     58a:	2300      	movs	r3, #0
     58c:	002a      	movs	r2, r5
     58e:	4913      	ldr	r1, [pc, #76]	; (5dc <main+0xec>)
     590:	4813      	ldr	r0, [pc, #76]	; (5e0 <main+0xf0>)
     592:	47b8      	blx	r7
	// Start the tasks and timer running. */
	vTaskStartScheduler();
     594:	4b13      	ldr	r3, [pc, #76]	; (5e4 <main+0xf4>)
     596:	4798      	blx	r3
     598:	e7fe      	b.n	598 <main+0xa8>
     59a:	46c0      	nop			; (mov r8, r8)
     59c:	000001dd 	.word	0x000001dd
     5a0:	40000800 	.word	0x40000800
     5a4:	fffffcff 	.word	0xfffffcff
     5a8:	00001ded 	.word	0x00001ded
     5ac:	00000cc9 	.word	0x00000cc9
     5b0:	200042ec 	.word	0x200042ec
     5b4:	41004400 	.word	0x41004400
     5b8:	00002158 	.word	0x00002158
     5bc:	0000039d 	.word	0x0000039d
     5c0:	00001431 	.word	0x00001431
     5c4:	00002164 	.word	0x00002164
     5c8:	000003e1 	.word	0x000003e1
     5cc:	00002170 	.word	0x00002170
     5d0:	00000425 	.word	0x00000425
     5d4:	0000217c 	.word	0x0000217c
     5d8:	00000469 	.word	0x00000469
     5dc:	00002188 	.word	0x00002188
     5e0:	000004ad 	.word	0x000004ad
     5e4:	000014a1 	.word	0x000014a1

000005e8 <sendUART1char>:
static char uc;
static char zs;

static void sendUART1char(char s)
{
  while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     5e8:	4b03      	ldr	r3, [pc, #12]	; (5f8 <sendUART1char+0x10>)
     5ea:	7e1b      	ldrb	r3, [r3, #24]
     5ec:	07db      	lsls	r3, r3, #31
     5ee:	d5fb      	bpl.n	5e8 <sendUART1char>
  SERCOM0->USART.DATA.reg = s;
     5f0:	b280      	uxth	r0, r0
     5f2:	4b01      	ldr	r3, [pc, #4]	; (5f8 <sendUART1char+0x10>)
     5f4:	8518      	strh	r0, [r3, #40]	; 0x28
}
     5f6:	4770      	bx	lr
     5f8:	42000800 	.word	0x42000800

000005fc <myputchar>:

/* "print.h" uses this function for is's printf implementation */
static void myputchar(char c)
{
     5fc:	b510      	push	{r4, lr}
     5fe:	0004      	movs	r4, r0
  if(c=='\n')
     600:	280a      	cmp	r0, #10
     602:	d003      	beq.n	60c <myputchar+0x10>
    sendUART1char('\r');
  sendUART1char(c);
     604:	0020      	movs	r0, r4
     606:	4b03      	ldr	r3, [pc, #12]	; (614 <myputchar+0x18>)
     608:	4798      	blx	r3
}
     60a:	bd10      	pop	{r4, pc}
    sendUART1char('\r');
     60c:	200d      	movs	r0, #13
     60e:	4b01      	ldr	r3, [pc, #4]	; (614 <myputchar+0x18>)
     610:	4798      	blx	r3
     612:	e7f7      	b.n	604 <myputchar+0x8>
     614:	000005e9 	.word	0x000005e9

00000618 <out>:
    //return 0;
//}


static void out(char c) {
    *bf++ = c;
     618:	4a02      	ldr	r2, [pc, #8]	; (624 <out+0xc>)
     61a:	6813      	ldr	r3, [r2, #0]
     61c:	1c59      	adds	r1, r3, #1
     61e:	6011      	str	r1, [r2, #0]
     620:	7018      	strb	r0, [r3, #0]
    }
     622:	4770      	bx	lr
     624:	200042f4 	.word	0x200042f4

00000628 <outDgt>:

static void outDgt(char dgt) {
     628:	b510      	push	{r4, lr}
     62a:	0003      	movs	r3, r0
	out(dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10));
     62c:	2809      	cmp	r0, #9
     62e:	d907      	bls.n	640 <outDgt+0x18>
     630:	4a08      	ldr	r2, [pc, #32]	; (654 <outDgt+0x2c>)
     632:	7912      	ldrb	r2, [r2, #4]
     634:	2a00      	cmp	r2, #0
     636:	d101      	bne.n	63c <outDgt+0x14>
     638:	2057      	movs	r0, #87	; 0x57
     63a:	e002      	b.n	642 <outDgt+0x1a>
     63c:	2037      	movs	r0, #55	; 0x37
     63e:	e000      	b.n	642 <outDgt+0x1a>
     640:	2030      	movs	r0, #48	; 0x30
     642:	18c0      	adds	r0, r0, r3
     644:	b2c0      	uxtb	r0, r0
     646:	4b04      	ldr	r3, [pc, #16]	; (658 <outDgt+0x30>)
     648:	4798      	blx	r3
	zs=1;
     64a:	2201      	movs	r2, #1
     64c:	4b01      	ldr	r3, [pc, #4]	; (654 <outDgt+0x2c>)
     64e:	715a      	strb	r2, [r3, #5]
    }
     650:	bd10      	pop	{r4, pc}
     652:	46c0      	nop			; (mov r8, r8)
     654:	200042f4 	.word	0x200042f4
     658:	00000619 	.word	0x00000619

0000065c <divOut>:
	
static void divOut(unsigned int div) {
     65c:	b510      	push	{r4, lr}
    unsigned char dgt=0;
	num &= 0xffff; // just for testing the code  with 32 bit ints
     65e:	4a0d      	ldr	r2, [pc, #52]	; (694 <divOut+0x38>)
     660:	6893      	ldr	r3, [r2, #8]
     662:	041b      	lsls	r3, r3, #16
     664:	0c1b      	lsrs	r3, r3, #16
     666:	6093      	str	r3, [r2, #8]
    unsigned char dgt=0;
     668:	2200      	movs	r2, #0
	while (num>=div) {
     66a:	e004      	b.n	676 <divOut+0x1a>
		num -= div;
     66c:	1a1b      	subs	r3, r3, r0
     66e:	4909      	ldr	r1, [pc, #36]	; (694 <divOut+0x38>)
     670:	608b      	str	r3, [r1, #8]
		dgt++;
     672:	3201      	adds	r2, #1
     674:	b2d2      	uxtb	r2, r2
	while (num>=div) {
     676:	4b07      	ldr	r3, [pc, #28]	; (694 <divOut+0x38>)
     678:	689b      	ldr	r3, [r3, #8]
     67a:	4283      	cmp	r3, r0
     67c:	d2f6      	bcs.n	66c <divOut+0x10>
		}
	if (zs || dgt>0) 
     67e:	4b05      	ldr	r3, [pc, #20]	; (694 <divOut+0x38>)
     680:	795b      	ldrb	r3, [r3, #5]
     682:	2b00      	cmp	r3, #0
     684:	d101      	bne.n	68a <divOut+0x2e>
     686:	2a00      	cmp	r2, #0
     688:	d002      	beq.n	690 <divOut+0x34>
		outDgt(dgt);
     68a:	0010      	movs	r0, r2
     68c:	4b02      	ldr	r3, [pc, #8]	; (698 <divOut+0x3c>)
     68e:	4798      	blx	r3
    }	
     690:	bd10      	pop	{r4, pc}
     692:	46c0      	nop			; (mov r8, r8)
     694:	200042f4 	.word	0x200042f4
     698:	00000629 	.word	0x00000629

0000069c <tfp_printf>:

void tfp_printf(char *fmt, ...)
	{
     69c:	b40f      	push	{r0, r1, r2, r3}
     69e:	b5f0      	push	{r4, r5, r6, r7, lr}
     6a0:	46c6      	mov	lr, r8
     6a2:	b500      	push	{lr}
     6a4:	b082      	sub	sp, #8
     6a6:	ab08      	add	r3, sp, #32
     6a8:	cb10      	ldmia	r3!, {r4}
	va_list va;
	char ch;
	char* p;
	
	va_start(va,fmt);
     6aa:	9301      	str	r3, [sp, #4]
	
	while ((ch=*(fmt++))) {
     6ac:	e0b0      	b.n	810 <tfp_printf+0x174>
			myputchar(ch);
			}
		else {
			char lz=0;
			char w=0;
			ch=*(fmt++);
     6ae:	3402      	adds	r4, #2
     6b0:	7829      	ldrb	r1, [r5, #0]
			if (ch=='0') {
     6b2:	2930      	cmp	r1, #48	; 0x30
     6b4:	d019      	beq.n	6ea <tfp_printf+0x4e>
			char lz=0;
     6b6:	2500      	movs	r5, #0
				ch=*(fmt++);
				lz=1;
				}
			if (ch>='0' && ch<='9') {
     6b8:	000b      	movs	r3, r1
     6ba:	3b30      	subs	r3, #48	; 0x30
     6bc:	b2db      	uxtb	r3, r3
     6be:	2b09      	cmp	r3, #9
     6c0:	d929      	bls.n	716 <tfp_printf+0x7a>
			char w=0;
     6c2:	2600      	movs	r6, #0
				while (ch>='0' && ch<='9') {
					w=(((w<<2)+w)<<1)+ch-'0';
					ch=*fmt++;
					}
				}
			bf=buf;
     6c4:	4b5b      	ldr	r3, [pc, #364]	; (834 <tfp_printf+0x198>)
     6c6:	001a      	movs	r2, r3
     6c8:	320c      	adds	r2, #12
     6ca:	601a      	str	r2, [r3, #0]
			p=bf;
			zs=0;
     6cc:	2200      	movs	r2, #0
     6ce:	715a      	strb	r2, [r3, #5]
			switch (ch) {
     6d0:	2963      	cmp	r1, #99	; 0x63
     6d2:	d069      	beq.n	7a8 <tfp_printf+0x10c>
     6d4:	d821      	bhi.n	71a <tfp_printf+0x7e>
     6d6:	2925      	cmp	r1, #37	; 0x25
     6d8:	d074      	beq.n	7c4 <tfp_printf+0x128>
     6da:	2958      	cmp	r1, #88	; 0x58
     6dc:	d024      	beq.n	728 <tfp_printf+0x8c>
     6de:	2900      	cmp	r1, #0
     6e0:	d100      	bne.n	6e4 <tfp_printf+0x48>
     6e2:	e0a0      	b.n	826 <tfp_printf+0x18a>
			p=bf;
     6e4:	4f53      	ldr	r7, [pc, #332]	; (834 <tfp_printf+0x198>)
     6e6:	370c      	adds	r7, #12
     6e8:	e050      	b.n	78c <tfp_printf+0xf0>
				ch=*(fmt++);
     6ea:	1cac      	adds	r4, r5, #2
     6ec:	7869      	ldrb	r1, [r5, #1]
				lz=1;
     6ee:	2501      	movs	r5, #1
     6f0:	e7e2      	b.n	6b8 <tfp_printf+0x1c>
					w=(((w<<2)+w)<<1)+ch-'0';
     6f2:	00b2      	lsls	r2, r6, #2
     6f4:	b2d2      	uxtb	r2, r2
     6f6:	18b2      	adds	r2, r6, r2
     6f8:	b2d3      	uxtb	r3, r2
     6fa:	005b      	lsls	r3, r3, #1
     6fc:	b2db      	uxtb	r3, r3
     6fe:	18cb      	adds	r3, r1, r3
     700:	b2db      	uxtb	r3, r3
     702:	3b30      	subs	r3, #48	; 0x30
     704:	b2de      	uxtb	r6, r3
					ch=*fmt++;
     706:	7821      	ldrb	r1, [r4, #0]
     708:	3401      	adds	r4, #1
				while (ch>='0' && ch<='9') {
     70a:	000b      	movs	r3, r1
     70c:	3b30      	subs	r3, #48	; 0x30
     70e:	b2db      	uxtb	r3, r3
     710:	2b09      	cmp	r3, #9
     712:	d9ee      	bls.n	6f2 <tfp_printf+0x56>
     714:	e7d6      	b.n	6c4 <tfp_printf+0x28>
     716:	2600      	movs	r6, #0
     718:	e7f7      	b.n	70a <tfp_printf+0x6e>
			switch (ch) {
     71a:	2973      	cmp	r1, #115	; 0x73
     71c:	d04d      	beq.n	7ba <tfp_printf+0x11e>
     71e:	d91c      	bls.n	75a <tfp_printf+0xbe>
     720:	2975      	cmp	r1, #117	; 0x75
     722:	d01c      	beq.n	75e <tfp_printf+0xc2>
     724:	2978      	cmp	r1, #120	; 0x78
     726:	d1dd      	bne.n	6e4 <tfp_printf+0x48>
					divOut(10);
					outDgt(num);
					break;
				case 'x': 
				case 'X' : 
				    uc= ch=='X';
     728:	3958      	subs	r1, #88	; 0x58
     72a:	424b      	negs	r3, r1
     72c:	414b      	adcs	r3, r1
     72e:	4f41      	ldr	r7, [pc, #260]	; (834 <tfp_printf+0x198>)
     730:	713b      	strb	r3, [r7, #4]
					num=va_arg(va, unsigned int);
     732:	9b01      	ldr	r3, [sp, #4]
     734:	1d1a      	adds	r2, r3, #4
     736:	9201      	str	r2, [sp, #4]
     738:	681b      	ldr	r3, [r3, #0]
     73a:	60bb      	str	r3, [r7, #8]
					divOut(0x1000);
     73c:	2080      	movs	r0, #128	; 0x80
     73e:	0140      	lsls	r0, r0, #5
     740:	4b3d      	ldr	r3, [pc, #244]	; (838 <tfp_printf+0x19c>)
     742:	4698      	mov	r8, r3
     744:	4798      	blx	r3
					divOut(0x100);
     746:	2080      	movs	r0, #128	; 0x80
     748:	0040      	lsls	r0, r0, #1
     74a:	47c0      	blx	r8
					divOut(0x10);
     74c:	2010      	movs	r0, #16
     74e:	47c0      	blx	r8
					outDgt(num);
     750:	7a38      	ldrb	r0, [r7, #8]
     752:	4b3a      	ldr	r3, [pc, #232]	; (83c <tfp_printf+0x1a0>)
     754:	4798      	blx	r3
			p=bf;
     756:	370c      	adds	r7, #12
					break;
     758:	e018      	b.n	78c <tfp_printf+0xf0>
			switch (ch) {
     75a:	2964      	cmp	r1, #100	; 0x64
     75c:	d1c2      	bne.n	6e4 <tfp_printf+0x48>
					num=va_arg(va, unsigned int);
     75e:	9b01      	ldr	r3, [sp, #4]
     760:	1d1a      	adds	r2, r3, #4
     762:	9201      	str	r2, [sp, #4]
     764:	681b      	ldr	r3, [r3, #0]
     766:	4a33      	ldr	r2, [pc, #204]	; (834 <tfp_printf+0x198>)
     768:	6093      	str	r3, [r2, #8]
					if (ch=='d' && (int)num<0) {
     76a:	2964      	cmp	r1, #100	; 0x64
     76c:	d014      	beq.n	798 <tfp_printf+0xfc>
					divOut(10000);
     76e:	4834      	ldr	r0, [pc, #208]	; (840 <tfp_printf+0x1a4>)
     770:	4f31      	ldr	r7, [pc, #196]	; (838 <tfp_printf+0x19c>)
     772:	47b8      	blx	r7
					divOut(1000);
     774:	20fa      	movs	r0, #250	; 0xfa
     776:	0080      	lsls	r0, r0, #2
     778:	47b8      	blx	r7
					divOut(100);
     77a:	2064      	movs	r0, #100	; 0x64
     77c:	47b8      	blx	r7
					divOut(10);
     77e:	200a      	movs	r0, #10
     780:	47b8      	blx	r7
					outDgt(num);
     782:	4f2c      	ldr	r7, [pc, #176]	; (834 <tfp_printf+0x198>)
     784:	7a38      	ldrb	r0, [r7, #8]
     786:	4b2d      	ldr	r3, [pc, #180]	; (83c <tfp_printf+0x1a0>)
     788:	4798      	blx	r3
			p=bf;
     78a:	370c      	adds	r7, #12
				case '%' :
					out('%');
				default:
					break;
				}
			*bf=0;
     78c:	4b29      	ldr	r3, [pc, #164]	; (834 <tfp_printf+0x198>)
     78e:	2200      	movs	r2, #0
     790:	6819      	ldr	r1, [r3, #0]
     792:	700a      	strb	r2, [r1, #0]
			bf=p;
     794:	601f      	str	r7, [r3, #0]
			while (*bf++ && w > 0)
     796:	e01d      	b.n	7d4 <tfp_printf+0x138>
					if (ch=='d' && (int)num<0) {
     798:	2b00      	cmp	r3, #0
     79a:	dae8      	bge.n	76e <tfp_printf+0xd2>
						num = -(int)num;
     79c:	425b      	negs	r3, r3
     79e:	6093      	str	r3, [r2, #8]
						out('-');
     7a0:	202d      	movs	r0, #45	; 0x2d
     7a2:	4b28      	ldr	r3, [pc, #160]	; (844 <tfp_printf+0x1a8>)
     7a4:	4798      	blx	r3
     7a6:	e7e2      	b.n	76e <tfp_printf+0xd2>
					out((char)(va_arg(va, int)));
     7a8:	9b01      	ldr	r3, [sp, #4]
     7aa:	1d1a      	adds	r2, r3, #4
     7ac:	9201      	str	r2, [sp, #4]
     7ae:	7818      	ldrb	r0, [r3, #0]
     7b0:	4b24      	ldr	r3, [pc, #144]	; (844 <tfp_printf+0x1a8>)
     7b2:	4798      	blx	r3
			p=bf;
     7b4:	4f1f      	ldr	r7, [pc, #124]	; (834 <tfp_printf+0x198>)
     7b6:	370c      	adds	r7, #12
					break;
     7b8:	e7e8      	b.n	78c <tfp_printf+0xf0>
					p=va_arg(va, char*);
     7ba:	9b01      	ldr	r3, [sp, #4]
     7bc:	1d1a      	adds	r2, r3, #4
     7be:	9201      	str	r2, [sp, #4]
     7c0:	681f      	ldr	r7, [r3, #0]
					break;
     7c2:	e7e3      	b.n	78c <tfp_printf+0xf0>
					out('%');
     7c4:	2025      	movs	r0, #37	; 0x25
     7c6:	4b1f      	ldr	r3, [pc, #124]	; (844 <tfp_printf+0x1a8>)
     7c8:	4798      	blx	r3
			p=bf;
     7ca:	4f1a      	ldr	r7, [pc, #104]	; (834 <tfp_printf+0x198>)
     7cc:	370c      	adds	r7, #12
     7ce:	e7dd      	b.n	78c <tfp_printf+0xf0>
				w--;
     7d0:	3e01      	subs	r6, #1
     7d2:	b2f6      	uxtb	r6, r6
			while (*bf++ && w > 0)
     7d4:	4a17      	ldr	r2, [pc, #92]	; (834 <tfp_printf+0x198>)
     7d6:	6813      	ldr	r3, [r2, #0]
     7d8:	1c59      	adds	r1, r3, #1
     7da:	6011      	str	r1, [r2, #0]
     7dc:	781b      	ldrb	r3, [r3, #0]
     7de:	2b00      	cmp	r3, #0
     7e0:	d006      	beq.n	7f0 <tfp_printf+0x154>
     7e2:	2e00      	cmp	r6, #0
     7e4:	d1f4      	bne.n	7d0 <tfp_printf+0x134>
     7e6:	e003      	b.n	7f0 <tfp_printf+0x154>
			while (w-- > 0) 
				myputchar(lz ? '0' : ' ');
     7e8:	2020      	movs	r0, #32
     7ea:	4b17      	ldr	r3, [pc, #92]	; (848 <tfp_printf+0x1ac>)
     7ec:	4798      	blx	r3
			while (w-- > 0) 
     7ee:	4646      	mov	r6, r8
     7f0:	1e73      	subs	r3, r6, #1
     7f2:	b2db      	uxtb	r3, r3
     7f4:	4698      	mov	r8, r3
     7f6:	2e00      	cmp	r6, #0
     7f8:	d006      	beq.n	808 <tfp_printf+0x16c>
				myputchar(lz ? '0' : ' ');
     7fa:	2d00      	cmp	r5, #0
     7fc:	d0f4      	beq.n	7e8 <tfp_printf+0x14c>
     7fe:	2030      	movs	r0, #48	; 0x30
     800:	e7f3      	b.n	7ea <tfp_printf+0x14e>
			while ((ch= *p++))
				myputchar(ch);
     802:	4b11      	ldr	r3, [pc, #68]	; (848 <tfp_printf+0x1ac>)
     804:	4798      	blx	r3
			while ((ch= *p++))
     806:	002f      	movs	r7, r5
     808:	1c7d      	adds	r5, r7, #1
     80a:	7838      	ldrb	r0, [r7, #0]
     80c:	2800      	cmp	r0, #0
     80e:	d1f8      	bne.n	802 <tfp_printf+0x166>
	while ((ch=*(fmt++))) {
     810:	1c65      	adds	r5, r4, #1
     812:	7820      	ldrb	r0, [r4, #0]
     814:	2800      	cmp	r0, #0
     816:	d006      	beq.n	826 <tfp_printf+0x18a>
		if (ch!='%') {
     818:	2825      	cmp	r0, #37	; 0x25
     81a:	d100      	bne.n	81e <tfp_printf+0x182>
     81c:	e747      	b.n	6ae <tfp_printf+0x12>
			myputchar(ch);
     81e:	4b0a      	ldr	r3, [pc, #40]	; (848 <tfp_printf+0x1ac>)
     820:	4798      	blx	r3
	while ((ch=*(fmt++))) {
     822:	002c      	movs	r4, r5
     824:	e7f4      	b.n	810 <tfp_printf+0x174>
			}
		}
	abort:;
	va_end(va);
	}
     826:	b002      	add	sp, #8
     828:	bc04      	pop	{r2}
     82a:	4690      	mov	r8, r2
     82c:	bcf0      	pop	{r4, r5, r6, r7}
     82e:	bc08      	pop	{r3}
     830:	b004      	add	sp, #16
     832:	4718      	bx	r3
     834:	200042f4 	.word	0x200042f4
     838:	0000065d 	.word	0x0000065d
     83c:	00000629 	.word	0x00000629
     840:	00002710 	.word	0x00002710
     844:	00000619 	.word	0x00000619
     848:	000005fd 	.word	0x000005fd

0000084c <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
     84c:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
     84e:	2300      	movs	r3, #0
     850:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
     852:	4b06      	ldr	r3, [pc, #24]	; (86c <prvTaskExitError+0x20>)
     854:	681b      	ldr	r3, [r3, #0]
     856:	3301      	adds	r3, #1
     858:	d001      	beq.n	85e <prvTaskExitError+0x12>
     85a:	b672      	cpsid	i
     85c:	e7fe      	b.n	85c <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     85e:	b672      	cpsid	i
	while( ulDummy == 0 )
     860:	9b01      	ldr	r3, [sp, #4]
     862:	2b00      	cmp	r3, #0
     864:	d0fc      	beq.n	860 <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     866:	b002      	add	sp, #8
     868:	4770      	bx	lr
     86a:	46c0      	nop			; (mov r8, r8)
     86c:	20000008 	.word	0x20000008

00000870 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     870:	4a0b      	ldr	r2, [pc, #44]	; (8a0 <pxCurrentTCBConst2>)
     872:	6813      	ldr	r3, [r2, #0]
     874:	6818      	ldr	r0, [r3, #0]
     876:	3020      	adds	r0, #32
     878:	f380 8809 	msr	PSP, r0
     87c:	2002      	movs	r0, #2
     87e:	f380 8814 	msr	CONTROL, r0
     882:	f3bf 8f6f 	isb	sy
     886:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     888:	46ae      	mov	lr, r5
     88a:	bc08      	pop	{r3}
     88c:	bc04      	pop	{r2}
     88e:	b662      	cpsie	i
     890:	4718      	bx	r3
     892:	46c0      	nop			; (mov r8, r8)
     894:	46c0      	nop			; (mov r8, r8)
     896:	46c0      	nop			; (mov r8, r8)
     898:	46c0      	nop			; (mov r8, r8)
     89a:	46c0      	nop			; (mov r8, r8)
     89c:	46c0      	nop			; (mov r8, r8)
     89e:	46c0      	nop			; (mov r8, r8)

000008a0 <pxCurrentTCBConst2>:
     8a0:	200043e4 	.word	0x200043e4

000008a4 <prvSetupTimerInterrupt>:
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
     8a4:	4b05      	ldr	r3, [pc, #20]	; (8bc <prvSetupTimerInterrupt+0x18>)
     8a6:	2200      	movs	r2, #0
     8a8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     8aa:	4905      	ldr	r1, [pc, #20]	; (8c0 <prvSetupTimerInterrupt+0x1c>)
     8ac:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
     8ae:	4905      	ldr	r1, [pc, #20]	; (8c4 <prvSetupTimerInterrupt+0x20>)
     8b0:	4a05      	ldr	r2, [pc, #20]	; (8c8 <prvSetupTimerInterrupt+0x24>)
     8b2:	6011      	str	r1, [r2, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     8b4:	2207      	movs	r2, #7
     8b6:	601a      	str	r2, [r3, #0]
}
     8b8:	4770      	bx	lr
     8ba:	46c0      	nop			; (mov r8, r8)
     8bc:	e000e010 	.word	0xe000e010
     8c0:	e000e018 	.word	0xe000e018
     8c4:	000176ff 	.word	0x000176ff
     8c8:	e000e014 	.word	0xe000e014

000008cc <pxPortInitialiseStack>:
{
     8cc:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
     8ce:	1f03      	subs	r3, r0, #4
     8d0:	2480      	movs	r4, #128	; 0x80
     8d2:	0464      	lsls	r4, r4, #17
     8d4:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
     8d6:	3b04      	subs	r3, #4
     8d8:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
     8da:	3b04      	subs	r3, #4
     8dc:	4902      	ldr	r1, [pc, #8]	; (8e8 <pxPortInitialiseStack+0x1c>)
     8de:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
     8e0:	3b14      	subs	r3, #20
     8e2:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
     8e4:	3840      	subs	r0, #64	; 0x40
}
     8e6:	bd10      	pop	{r4, pc}
     8e8:	0000084d 	.word	0x0000084d

000008ec <xPortStartScheduler>:
{
     8ec:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     8ee:	4b0c      	ldr	r3, [pc, #48]	; (920 <xPortStartScheduler+0x34>)
     8f0:	6819      	ldr	r1, [r3, #0]
     8f2:	22ff      	movs	r2, #255	; 0xff
     8f4:	0412      	lsls	r2, r2, #16
     8f6:	430a      	orrs	r2, r1
     8f8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     8fa:	6819      	ldr	r1, [r3, #0]
     8fc:	22ff      	movs	r2, #255	; 0xff
     8fe:	0612      	lsls	r2, r2, #24
     900:	430a      	orrs	r2, r1
     902:	601a      	str	r2, [r3, #0]
	prvSetupTimerInterrupt();
     904:	4b07      	ldr	r3, [pc, #28]	; (924 <xPortStartScheduler+0x38>)
     906:	4798      	blx	r3
	uxCriticalNesting = 0;
     908:	2200      	movs	r2, #0
     90a:	4b07      	ldr	r3, [pc, #28]	; (928 <xPortStartScheduler+0x3c>)
     90c:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
     90e:	4b07      	ldr	r3, [pc, #28]	; (92c <xPortStartScheduler+0x40>)
     910:	4798      	blx	r3
	vTaskSwitchContext();
     912:	4b07      	ldr	r3, [pc, #28]	; (930 <xPortStartScheduler+0x44>)
     914:	4798      	blx	r3
	prvTaskExitError();
     916:	4b07      	ldr	r3, [pc, #28]	; (934 <xPortStartScheduler+0x48>)
     918:	4798      	blx	r3
}
     91a:	2000      	movs	r0, #0
     91c:	bd10      	pop	{r4, pc}
     91e:	46c0      	nop			; (mov r8, r8)
     920:	e000ed20 	.word	0xe000ed20
     924:	000008a5 	.word	0x000008a5
     928:	20000008 	.word	0x20000008
     92c:	00000871 	.word	0x00000871
     930:	00001769 	.word	0x00001769
     934:	0000084d 	.word	0x0000084d

00000938 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
     938:	2280      	movs	r2, #128	; 0x80
     93a:	0552      	lsls	r2, r2, #21
     93c:	4b03      	ldr	r3, [pc, #12]	; (94c <vPortYield+0x14>)
     93e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
     940:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     944:	f3bf 8f6f 	isb	sy
}
     948:	4770      	bx	lr
     94a:	46c0      	nop			; (mov r8, r8)
     94c:	e000ed04 	.word	0xe000ed04

00000950 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
     950:	b672      	cpsid	i
    uxCriticalNesting++;
     952:	4a04      	ldr	r2, [pc, #16]	; (964 <vPortEnterCritical+0x14>)
     954:	6813      	ldr	r3, [r2, #0]
     956:	3301      	adds	r3, #1
     958:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
     95a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     95e:	f3bf 8f6f 	isb	sy
}
     962:	4770      	bx	lr
     964:	20000008 	.word	0x20000008

00000968 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
     968:	4b06      	ldr	r3, [pc, #24]	; (984 <vPortExitCritical+0x1c>)
     96a:	681b      	ldr	r3, [r3, #0]
     96c:	2b00      	cmp	r3, #0
     96e:	d101      	bne.n	974 <vPortExitCritical+0xc>
     970:	b672      	cpsid	i
     972:	e7fe      	b.n	972 <vPortExitCritical+0xa>
    uxCriticalNesting--;
     974:	3b01      	subs	r3, #1
     976:	4a03      	ldr	r2, [pc, #12]	; (984 <vPortExitCritical+0x1c>)
     978:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
     97a:	2b00      	cmp	r3, #0
     97c:	d100      	bne.n	980 <vPortExitCritical+0x18>
        portENABLE_INTERRUPTS();
     97e:	b662      	cpsie	i
}
     980:	4770      	bx	lr
     982:	46c0      	nop			; (mov r8, r8)
     984:	20000008 	.word	0x20000008

00000988 <ulSetInterruptMaskFromISR>:
	__asm volatile(
     988:	f3ef 8010 	mrs	r0, PRIMASK
     98c:	b672      	cpsid	i
     98e:	4770      	bx	lr

00000990 <vClearInterruptMaskFromISR>:
	__asm volatile(
     990:	f380 8810 	msr	PRIMASK, r0
     994:	4770      	bx	lr
	...

000009a0 <PendSV_Handler>:
	__asm volatile
     9a0:	f3ef 8009 	mrs	r0, PSP
     9a4:	4b0e      	ldr	r3, [pc, #56]	; (9e0 <pxCurrentTCBConst>)
     9a6:	681a      	ldr	r2, [r3, #0]
     9a8:	3820      	subs	r0, #32
     9aa:	6010      	str	r0, [r2, #0]
     9ac:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     9ae:	4644      	mov	r4, r8
     9b0:	464d      	mov	r5, r9
     9b2:	4656      	mov	r6, sl
     9b4:	465f      	mov	r7, fp
     9b6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     9b8:	b508      	push	{r3, lr}
     9ba:	b672      	cpsid	i
     9bc:	f000 fed4 	bl	1768 <vTaskSwitchContext>
     9c0:	b662      	cpsie	i
     9c2:	bc0c      	pop	{r2, r3}
     9c4:	6811      	ldr	r1, [r2, #0]
     9c6:	6808      	ldr	r0, [r1, #0]
     9c8:	3010      	adds	r0, #16
     9ca:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     9cc:	46a0      	mov	r8, r4
     9ce:	46a9      	mov	r9, r5
     9d0:	46b2      	mov	sl, r6
     9d2:	46bb      	mov	fp, r7
     9d4:	f380 8809 	msr	PSP, r0
     9d8:	3820      	subs	r0, #32
     9da:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     9dc:	4718      	bx	r3
     9de:	46c0      	nop			; (mov r8, r8)

000009e0 <pxCurrentTCBConst>:
     9e0:	200043e4 	.word	0x200043e4

000009e4 <SysTick_Handler>:
{
     9e4:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     9e6:	4b07      	ldr	r3, [pc, #28]	; (a04 <SysTick_Handler+0x20>)
     9e8:	4798      	blx	r3
     9ea:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
     9ec:	4b06      	ldr	r3, [pc, #24]	; (a08 <SysTick_Handler+0x24>)
     9ee:	4798      	blx	r3
     9f0:	2800      	cmp	r0, #0
     9f2:	d003      	beq.n	9fc <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     9f4:	2280      	movs	r2, #128	; 0x80
     9f6:	0552      	lsls	r2, r2, #21
     9f8:	4b04      	ldr	r3, [pc, #16]	; (a0c <SysTick_Handler+0x28>)
     9fa:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     9fc:	0020      	movs	r0, r4
     9fe:	4b04      	ldr	r3, [pc, #16]	; (a10 <SysTick_Handler+0x2c>)
     a00:	4798      	blx	r3
}
     a02:	bd10      	pop	{r4, pc}
     a04:	00000989 	.word	0x00000989
     a08:	00001525 	.word	0x00001525
     a0c:	e000ed04 	.word	0xe000ed04
     a10:	00000991 	.word	0x00000991

00000a14 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
     a14:	b510      	push	{r4, lr}
     a16:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
     a18:	4b06      	ldr	r3, [pc, #24]	; (a34 <prvIsQueueFull+0x20>)
     a1a:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     a1c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     a1e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     a20:	429a      	cmp	r2, r3
     a22:	d004      	beq.n	a2e <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
     a24:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
     a26:	4b04      	ldr	r3, [pc, #16]	; (a38 <prvIsQueueFull+0x24>)
     a28:	4798      	blx	r3

	return xReturn;
}
     a2a:	0020      	movs	r0, r4
     a2c:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     a2e:	2401      	movs	r4, #1
     a30:	e7f9      	b.n	a26 <prvIsQueueFull+0x12>
     a32:	46c0      	nop			; (mov r8, r8)
     a34:	00000951 	.word	0x00000951
     a38:	00000969 	.word	0x00000969

00000a3c <prvIsQueueEmpty>:
{
     a3c:	b510      	push	{r4, lr}
     a3e:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
     a40:	4b05      	ldr	r3, [pc, #20]	; (a58 <prvIsQueueEmpty+0x1c>)
     a42:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     a44:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a46:	2b00      	cmp	r3, #0
     a48:	d004      	beq.n	a54 <prvIsQueueEmpty+0x18>
			xReturn = pdFALSE;
     a4a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
     a4c:	4b03      	ldr	r3, [pc, #12]	; (a5c <prvIsQueueEmpty+0x20>)
     a4e:	4798      	blx	r3
}
     a50:	0020      	movs	r0, r4
     a52:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     a54:	2401      	movs	r4, #1
     a56:	e7f9      	b.n	a4c <prvIsQueueEmpty+0x10>
     a58:	00000951 	.word	0x00000951
     a5c:	00000969 	.word	0x00000969

00000a60 <prvCopyDataToQueue>:
{
     a60:	b570      	push	{r4, r5, r6, lr}
     a62:	0004      	movs	r4, r0
     a64:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     a66:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     a68:	6c02      	ldr	r2, [r0, #64]	; 0x40
     a6a:	2a00      	cmp	r2, #0
     a6c:	d10a      	bne.n	a84 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     a6e:	6803      	ldr	r3, [r0, #0]
     a70:	2b00      	cmp	r3, #0
     a72:	d12e      	bne.n	ad2 <prvCopyDataToQueue+0x72>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     a74:	6840      	ldr	r0, [r0, #4]
     a76:	4b1b      	ldr	r3, [pc, #108]	; (ae4 <prvCopyDataToQueue+0x84>)
     a78:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     a7a:	2300      	movs	r3, #0
     a7c:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     a7e:	3501      	adds	r5, #1
     a80:	63a5      	str	r5, [r4, #56]	; 0x38
}
     a82:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
     a84:	2e00      	cmp	r6, #0
     a86:	d10e      	bne.n	aa6 <prvCopyDataToQueue+0x46>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     a88:	6880      	ldr	r0, [r0, #8]
     a8a:	4b17      	ldr	r3, [pc, #92]	; (ae8 <prvCopyDataToQueue+0x88>)
     a8c:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     a8e:	68a3      	ldr	r3, [r4, #8]
     a90:	6c22      	ldr	r2, [r4, #64]	; 0x40
     a92:	4694      	mov	ip, r2
     a94:	4463      	add	r3, ip
     a96:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     a98:	6862      	ldr	r2, [r4, #4]
     a9a:	4293      	cmp	r3, r2
     a9c:	d31b      	bcc.n	ad6 <prvCopyDataToQueue+0x76>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     a9e:	6823      	ldr	r3, [r4, #0]
     aa0:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
     aa2:	2000      	movs	r0, #0
     aa4:	e7eb      	b.n	a7e <prvCopyDataToQueue+0x1e>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     aa6:	68c0      	ldr	r0, [r0, #12]
     aa8:	4b0f      	ldr	r3, [pc, #60]	; (ae8 <prvCopyDataToQueue+0x88>)
     aaa:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     aac:	6c23      	ldr	r3, [r4, #64]	; 0x40
     aae:	425b      	negs	r3, r3
     ab0:	68e2      	ldr	r2, [r4, #12]
     ab2:	18d2      	adds	r2, r2, r3
     ab4:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ab6:	6821      	ldr	r1, [r4, #0]
     ab8:	428a      	cmp	r2, r1
     aba:	d203      	bcs.n	ac4 <prvCopyDataToQueue+0x64>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     abc:	6862      	ldr	r2, [r4, #4]
     abe:	4694      	mov	ip, r2
     ac0:	4463      	add	r3, ip
     ac2:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
     ac4:	2e02      	cmp	r6, #2
     ac6:	d108      	bne.n	ada <prvCopyDataToQueue+0x7a>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ac8:	2d00      	cmp	r5, #0
     aca:	d008      	beq.n	ade <prvCopyDataToQueue+0x7e>
				--uxMessagesWaiting;
     acc:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
     ace:	2000      	movs	r0, #0
     ad0:	e7d5      	b.n	a7e <prvCopyDataToQueue+0x1e>
     ad2:	2000      	movs	r0, #0
     ad4:	e7d3      	b.n	a7e <prvCopyDataToQueue+0x1e>
     ad6:	2000      	movs	r0, #0
     ad8:	e7d1      	b.n	a7e <prvCopyDataToQueue+0x1e>
     ada:	2000      	movs	r0, #0
     adc:	e7cf      	b.n	a7e <prvCopyDataToQueue+0x1e>
     ade:	2000      	movs	r0, #0
     ae0:	e7cd      	b.n	a7e <prvCopyDataToQueue+0x1e>
     ae2:	46c0      	nop			; (mov r8, r8)
     ae4:	00001981 	.word	0x00001981
     ae8:	00001ed1 	.word	0x00001ed1

00000aec <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
     aec:	b570      	push	{r4, r5, r6, lr}
     aee:	b082      	sub	sp, #8
     af0:	9001      	str	r0, [sp, #4]
     af2:	000a      	movs	r2, r1
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     af4:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
     af6:	2c00      	cmp	r4, #0
     af8:	d005      	beq.n	b06 <prvNotifyQueueSetContainer+0x1a>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     afa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     afc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     afe:	4299      	cmp	r1, r3
     b00:	d303      	bcc.n	b0a <prvNotifyQueueSetContainer+0x1e>
     b02:	b672      	cpsid	i
     b04:	e7fe      	b.n	b04 <prvNotifyQueueSetContainer+0x18>
		configASSERT( pxQueueSetContainer );
     b06:	b672      	cpsid	i
     b08:	e7fe      	b.n	b08 <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     b0a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     b0c:	428b      	cmp	r3, r1
     b0e:	d803      	bhi.n	b18 <prvNotifyQueueSetContainer+0x2c>
	BaseType_t xReturn = pdFALSE;
     b10:	2600      	movs	r6, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     b12:	0030      	movs	r0, r6
     b14:	b002      	add	sp, #8
     b16:	bd70      	pop	{r4, r5, r6, pc}
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     b18:	2345      	movs	r3, #69	; 0x45
     b1a:	5ce5      	ldrb	r5, [r4, r3]
     b1c:	b26d      	sxtb	r5, r5
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     b1e:	a901      	add	r1, sp, #4
     b20:	0020      	movs	r0, r4
     b22:	4b0a      	ldr	r3, [pc, #40]	; (b4c <prvNotifyQueueSetContainer+0x60>)
     b24:	4798      	blx	r3
     b26:	0006      	movs	r6, r0
			if( cTxLock == queueUNLOCKED )
     b28:	1c6b      	adds	r3, r5, #1
     b2a:	d10a      	bne.n	b42 <prvNotifyQueueSetContainer+0x56>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     b2c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     b2e:	2b00      	cmp	r3, #0
     b30:	d0ef      	beq.n	b12 <prvNotifyQueueSetContainer+0x26>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     b32:	0020      	movs	r0, r4
     b34:	3024      	adds	r0, #36	; 0x24
     b36:	4b06      	ldr	r3, [pc, #24]	; (b50 <prvNotifyQueueSetContainer+0x64>)
     b38:	4798      	blx	r3
     b3a:	2800      	cmp	r0, #0
     b3c:	d0e9      	beq.n	b12 <prvNotifyQueueSetContainer+0x26>
						xReturn = pdTRUE;
     b3e:	2601      	movs	r6, #1
		return xReturn;
     b40:	e7e7      	b.n	b12 <prvNotifyQueueSetContainer+0x26>
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
     b42:	3501      	adds	r5, #1
     b44:	b26d      	sxtb	r5, r5
     b46:	2345      	movs	r3, #69	; 0x45
     b48:	54e5      	strb	r5, [r4, r3]
     b4a:	e7e2      	b.n	b12 <prvNotifyQueueSetContainer+0x26>
     b4c:	00000a61 	.word	0x00000a61
     b50:	00001851 	.word	0x00001851

00000b54 <prvCopyDataFromQueue>:
{
     b54:	b510      	push	{r4, lr}
     b56:	000c      	movs	r4, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     b58:	6c02      	ldr	r2, [r0, #64]	; 0x40
     b5a:	2a00      	cmp	r2, #0
     b5c:	d00b      	beq.n	b76 <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     b5e:	68c3      	ldr	r3, [r0, #12]
     b60:	189b      	adds	r3, r3, r2
     b62:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     b64:	6841      	ldr	r1, [r0, #4]
     b66:	428b      	cmp	r3, r1
     b68:	d301      	bcc.n	b6e <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     b6a:	6803      	ldr	r3, [r0, #0]
     b6c:	60c3      	str	r3, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     b6e:	68c1      	ldr	r1, [r0, #12]
     b70:	0020      	movs	r0, r4
     b72:	4b01      	ldr	r3, [pc, #4]	; (b78 <prvCopyDataFromQueue+0x24>)
     b74:	4798      	blx	r3
}
     b76:	bd10      	pop	{r4, pc}
     b78:	00001ed1 	.word	0x00001ed1

00000b7c <prvUnlockQueue>:
{
     b7c:	b570      	push	{r4, r5, r6, lr}
     b7e:	0005      	movs	r5, r0
	taskENTER_CRITICAL();
     b80:	4b21      	ldr	r3, [pc, #132]	; (c08 <prvUnlockQueue+0x8c>)
     b82:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
     b84:	2345      	movs	r3, #69	; 0x45
     b86:	5cec      	ldrb	r4, [r5, r3]
     b88:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     b8a:	e00a      	b.n	ba2 <prvUnlockQueue+0x26>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b8c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     b8e:	2b00      	cmp	r3, #0
     b90:	d018      	beq.n	bc4 <prvUnlockQueue+0x48>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b92:	0028      	movs	r0, r5
     b94:	3024      	adds	r0, #36	; 0x24
     b96:	4b1d      	ldr	r3, [pc, #116]	; (c0c <prvUnlockQueue+0x90>)
     b98:	4798      	blx	r3
     b9a:	2800      	cmp	r0, #0
     b9c:	d10f      	bne.n	bbe <prvUnlockQueue+0x42>
			--cTxLock;
     b9e:	3c01      	subs	r4, #1
     ba0:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     ba2:	2c00      	cmp	r4, #0
     ba4:	dd0e      	ble.n	bc4 <prvUnlockQueue+0x48>
				if( pxQueue->pxQueueSetContainer != NULL )
     ba6:	6cab      	ldr	r3, [r5, #72]	; 0x48
     ba8:	2b00      	cmp	r3, #0
     baa:	d0ef      	beq.n	b8c <prvUnlockQueue+0x10>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     bac:	2100      	movs	r1, #0
     bae:	0028      	movs	r0, r5
     bb0:	4b17      	ldr	r3, [pc, #92]	; (c10 <prvUnlockQueue+0x94>)
     bb2:	4798      	blx	r3
     bb4:	2800      	cmp	r0, #0
     bb6:	d0f2      	beq.n	b9e <prvUnlockQueue+0x22>
						vTaskMissedYield();
     bb8:	4b16      	ldr	r3, [pc, #88]	; (c14 <prvUnlockQueue+0x98>)
     bba:	4798      	blx	r3
     bbc:	e7ef      	b.n	b9e <prvUnlockQueue+0x22>
							vTaskMissedYield();
     bbe:	4b15      	ldr	r3, [pc, #84]	; (c14 <prvUnlockQueue+0x98>)
     bc0:	4798      	blx	r3
     bc2:	e7ec      	b.n	b9e <prvUnlockQueue+0x22>
		pxQueue->cTxLock = queueUNLOCKED;
     bc4:	22ff      	movs	r2, #255	; 0xff
     bc6:	2345      	movs	r3, #69	; 0x45
     bc8:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     bca:	4b13      	ldr	r3, [pc, #76]	; (c18 <prvUnlockQueue+0x9c>)
     bcc:	4798      	blx	r3
	taskENTER_CRITICAL();
     bce:	4b0e      	ldr	r3, [pc, #56]	; (c08 <prvUnlockQueue+0x8c>)
     bd0:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
     bd2:	2344      	movs	r3, #68	; 0x44
     bd4:	5cec      	ldrb	r4, [r5, r3]
     bd6:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     bd8:	e001      	b.n	bde <prvUnlockQueue+0x62>
				--cRxLock;
     bda:	3c01      	subs	r4, #1
     bdc:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     bde:	2c00      	cmp	r4, #0
     be0:	dd0b      	ble.n	bfa <prvUnlockQueue+0x7e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     be2:	692b      	ldr	r3, [r5, #16]
     be4:	2b00      	cmp	r3, #0
     be6:	d008      	beq.n	bfa <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     be8:	0028      	movs	r0, r5
     bea:	3010      	adds	r0, #16
     bec:	4b07      	ldr	r3, [pc, #28]	; (c0c <prvUnlockQueue+0x90>)
     bee:	4798      	blx	r3
     bf0:	2800      	cmp	r0, #0
     bf2:	d0f2      	beq.n	bda <prvUnlockQueue+0x5e>
					vTaskMissedYield();
     bf4:	4b07      	ldr	r3, [pc, #28]	; (c14 <prvUnlockQueue+0x98>)
     bf6:	4798      	blx	r3
     bf8:	e7ef      	b.n	bda <prvUnlockQueue+0x5e>
		pxQueue->cRxLock = queueUNLOCKED;
     bfa:	22ff      	movs	r2, #255	; 0xff
     bfc:	2344      	movs	r3, #68	; 0x44
     bfe:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     c00:	4b05      	ldr	r3, [pc, #20]	; (c18 <prvUnlockQueue+0x9c>)
     c02:	4798      	blx	r3
}
     c04:	bd70      	pop	{r4, r5, r6, pc}
     c06:	46c0      	nop			; (mov r8, r8)
     c08:	00000951 	.word	0x00000951
     c0c:	00001851 	.word	0x00001851
     c10:	00000aed 	.word	0x00000aed
     c14:	00001955 	.word	0x00001955
     c18:	00000969 	.word	0x00000969

00000c1c <xQueueGenericReset>:
{
     c1c:	b570      	push	{r4, r5, r6, lr}
     c1e:	0004      	movs	r4, r0
     c20:	000d      	movs	r5, r1
	configASSERT( pxQueue );
     c22:	2800      	cmp	r0, #0
     c24:	d023      	beq.n	c6e <xQueueGenericReset+0x52>
	taskENTER_CRITICAL();
     c26:	4b18      	ldr	r3, [pc, #96]	; (c88 <xQueueGenericReset+0x6c>)
     c28:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     c2a:	6822      	ldr	r2, [r4, #0]
     c2c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     c2e:	6c20      	ldr	r0, [r4, #64]	; 0x40
     c30:	0001      	movs	r1, r0
     c32:	4359      	muls	r1, r3
     c34:	1851      	adds	r1, r2, r1
     c36:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     c38:	2100      	movs	r1, #0
     c3a:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
     c3c:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     c3e:	3b01      	subs	r3, #1
     c40:	4343      	muls	r3, r0
     c42:	18d3      	adds	r3, r2, r3
     c44:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
     c46:	23ff      	movs	r3, #255	; 0xff
     c48:	2244      	movs	r2, #68	; 0x44
     c4a:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock = queueUNLOCKED;
     c4c:	3201      	adds	r2, #1
     c4e:	54a3      	strb	r3, [r4, r2]
		if( xNewQueue == pdFALSE )
     c50:	2d00      	cmp	r5, #0
     c52:	d111      	bne.n	c78 <xQueueGenericReset+0x5c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c54:	6923      	ldr	r3, [r4, #16]
     c56:	2b00      	cmp	r3, #0
     c58:	d005      	beq.n	c66 <xQueueGenericReset+0x4a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c5a:	0020      	movs	r0, r4
     c5c:	3010      	adds	r0, #16
     c5e:	4b0b      	ldr	r3, [pc, #44]	; (c8c <xQueueGenericReset+0x70>)
     c60:	4798      	blx	r3
     c62:	2800      	cmp	r0, #0
     c64:	d105      	bne.n	c72 <xQueueGenericReset+0x56>
	taskEXIT_CRITICAL();
     c66:	4b0a      	ldr	r3, [pc, #40]	; (c90 <xQueueGenericReset+0x74>)
     c68:	4798      	blx	r3
}
     c6a:	2001      	movs	r0, #1
     c6c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
     c6e:	b672      	cpsid	i
     c70:	e7fe      	b.n	c70 <xQueueGenericReset+0x54>
					queueYIELD_IF_USING_PREEMPTION();
     c72:	4b08      	ldr	r3, [pc, #32]	; (c94 <xQueueGenericReset+0x78>)
     c74:	4798      	blx	r3
     c76:	e7f6      	b.n	c66 <xQueueGenericReset+0x4a>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     c78:	0020      	movs	r0, r4
     c7a:	3010      	adds	r0, #16
     c7c:	4d06      	ldr	r5, [pc, #24]	; (c98 <xQueueGenericReset+0x7c>)
     c7e:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     c80:	0020      	movs	r0, r4
     c82:	3024      	adds	r0, #36	; 0x24
     c84:	47a8      	blx	r5
     c86:	e7ee      	b.n	c66 <xQueueGenericReset+0x4a>
     c88:	00000951 	.word	0x00000951
     c8c:	00001851 	.word	0x00001851
     c90:	00000969 	.word	0x00000969
     c94:	00000939 	.word	0x00000939
     c98:	00000311 	.word	0x00000311

00000c9c <prvInitialiseNewQueue>:
{
     c9c:	b570      	push	{r4, r5, r6, lr}
     c9e:	001d      	movs	r5, r3
     ca0:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
     ca2:	2900      	cmp	r1, #0
     ca4:	d00b      	beq.n	cbe <prvInitialiseNewQueue+0x22>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     ca6:	6022      	str	r2, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
     ca8:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
     caa:	6421      	str	r1, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     cac:	2101      	movs	r1, #1
     cae:	0020      	movs	r0, r4
     cb0:	4b04      	ldr	r3, [pc, #16]	; (cc4 <prvInitialiseNewQueue+0x28>)
     cb2:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
     cb4:	2350      	movs	r3, #80	; 0x50
     cb6:	54e5      	strb	r5, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
     cb8:	2300      	movs	r3, #0
     cba:	64a3      	str	r3, [r4, #72]	; 0x48
}
     cbc:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     cbe:	6024      	str	r4, [r4, #0]
     cc0:	e7f2      	b.n	ca8 <prvInitialiseNewQueue+0xc>
     cc2:	46c0      	nop			; (mov r8, r8)
     cc4:	00000c1d 	.word	0x00000c1d

00000cc8 <xQueueGenericCreate>:
	{
     cc8:	b5f0      	push	{r4, r5, r6, r7, lr}
     cca:	b083      	sub	sp, #12
     ccc:	0006      	movs	r6, r0
     cce:	000f      	movs	r7, r1
     cd0:	0015      	movs	r5, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
     cd2:	2800      	cmp	r0, #0
     cd4:	d101      	bne.n	cda <xQueueGenericCreate+0x12>
     cd6:	b672      	cpsid	i
     cd8:	e7fe      	b.n	cd8 <xQueueGenericCreate+0x10>
		if( uxItemSize == ( UBaseType_t ) 0 )
     cda:	2900      	cmp	r1, #0
     cdc:	d002      	beq.n	ce4 <xQueueGenericCreate+0x1c>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cde:	0008      	movs	r0, r1
     ce0:	4370      	muls	r0, r6
     ce2:	e000      	b.n	ce6 <xQueueGenericCreate+0x1e>
			xQueueSizeInBytes = ( size_t ) 0;
     ce4:	2000      	movs	r0, #0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     ce6:	3054      	adds	r0, #84	; 0x54
     ce8:	4b07      	ldr	r3, [pc, #28]	; (d08 <xQueueGenericCreate+0x40>)
     cea:	4798      	blx	r3
     cec:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
     cee:	d007      	beq.n	d00 <xQueueGenericCreate+0x38>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
     cf0:	0002      	movs	r2, r0
     cf2:	3254      	adds	r2, #84	; 0x54
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     cf4:	9000      	str	r0, [sp, #0]
     cf6:	002b      	movs	r3, r5
     cf8:	0039      	movs	r1, r7
     cfa:	0030      	movs	r0, r6
     cfc:	4d03      	ldr	r5, [pc, #12]	; (d0c <xQueueGenericCreate+0x44>)
     cfe:	47a8      	blx	r5
	}
     d00:	0020      	movs	r0, r4
     d02:	b003      	add	sp, #12
     d04:	bdf0      	pop	{r4, r5, r6, r7, pc}
     d06:	46c0      	nop			; (mov r8, r8)
     d08:	00000219 	.word	0x00000219
     d0c:	00000c9d 	.word	0x00000c9d

00000d10 <xQueueGenericSend>:
{
     d10:	b5f0      	push	{r4, r5, r6, r7, lr}
     d12:	b085      	sub	sp, #20
     d14:	0004      	movs	r4, r0
     d16:	000f      	movs	r7, r1
     d18:	9201      	str	r2, [sp, #4]
     d1a:	001e      	movs	r6, r3
	configASSERT( pxQueue );
     d1c:	2800      	cmp	r0, #0
     d1e:	d006      	beq.n	d2e <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d20:	2900      	cmp	r1, #0
     d22:	d006      	beq.n	d32 <xQueueGenericSend+0x22>
     d24:	2501      	movs	r5, #1
     d26:	2d00      	cmp	r5, #0
     d28:	d10a      	bne.n	d40 <xQueueGenericSend+0x30>
     d2a:	b672      	cpsid	i
     d2c:	e7fe      	b.n	d2c <xQueueGenericSend+0x1c>
	configASSERT( pxQueue );
     d2e:	b672      	cpsid	i
     d30:	e7fe      	b.n	d30 <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d32:	6c03      	ldr	r3, [r0, #64]	; 0x40
     d34:	2b00      	cmp	r3, #0
     d36:	d101      	bne.n	d3c <xQueueGenericSend+0x2c>
     d38:	2501      	movs	r5, #1
     d3a:	e7f4      	b.n	d26 <xQueueGenericSend+0x16>
     d3c:	2500      	movs	r5, #0
     d3e:	e7f2      	b.n	d26 <xQueueGenericSend+0x16>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     d40:	2e02      	cmp	r6, #2
     d42:	d003      	beq.n	d4c <xQueueGenericSend+0x3c>
     d44:	2d00      	cmp	r5, #0
     d46:	d106      	bne.n	d56 <xQueueGenericSend+0x46>
     d48:	b672      	cpsid	i
     d4a:	e7fe      	b.n	d4a <xQueueGenericSend+0x3a>
     d4c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     d4e:	2b01      	cmp	r3, #1
     d50:	d0f8      	beq.n	d44 <xQueueGenericSend+0x34>
     d52:	2500      	movs	r5, #0
     d54:	e7f6      	b.n	d44 <xQueueGenericSend+0x34>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     d56:	4b44      	ldr	r3, [pc, #272]	; (e68 <xQueueGenericSend+0x158>)
     d58:	4798      	blx	r3
     d5a:	2800      	cmp	r0, #0
     d5c:	d103      	bne.n	d66 <xQueueGenericSend+0x56>
     d5e:	9b01      	ldr	r3, [sp, #4]
     d60:	2b00      	cmp	r3, #0
     d62:	d000      	beq.n	d66 <xQueueGenericSend+0x56>
     d64:	2500      	movs	r5, #0
     d66:	2d00      	cmp	r5, #0
     d68:	d101      	bne.n	d6e <xQueueGenericSend+0x5e>
     d6a:	b672      	cpsid	i
     d6c:	e7fe      	b.n	d6c <xQueueGenericSend+0x5c>
     d6e:	2500      	movs	r5, #0
     d70:	e042      	b.n	df8 <xQueueGenericSend+0xe8>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d72:	0032      	movs	r2, r6
     d74:	0039      	movs	r1, r7
     d76:	0020      	movs	r0, r4
     d78:	4b3c      	ldr	r3, [pc, #240]	; (e6c <xQueueGenericSend+0x15c>)
     d7a:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
     d7c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     d7e:	2b00      	cmp	r3, #0
     d80:	d00c      	beq.n	d9c <xQueueGenericSend+0x8c>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     d82:	0031      	movs	r1, r6
     d84:	0020      	movs	r0, r4
     d86:	4b3a      	ldr	r3, [pc, #232]	; (e70 <xQueueGenericSend+0x160>)
     d88:	4798      	blx	r3
     d8a:	2800      	cmp	r0, #0
     d8c:	d001      	beq.n	d92 <xQueueGenericSend+0x82>
							queueYIELD_IF_USING_PREEMPTION();
     d8e:	4b39      	ldr	r3, [pc, #228]	; (e74 <xQueueGenericSend+0x164>)
     d90:	4798      	blx	r3
				taskEXIT_CRITICAL();
     d92:	4b39      	ldr	r3, [pc, #228]	; (e78 <xQueueGenericSend+0x168>)
     d94:	4798      	blx	r3
				return pdPASS;
     d96:	2001      	movs	r0, #1
}
     d98:	b005      	add	sp, #20
     d9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     d9e:	2b00      	cmp	r3, #0
     da0:	d008      	beq.n	db4 <xQueueGenericSend+0xa4>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     da2:	0020      	movs	r0, r4
     da4:	3024      	adds	r0, #36	; 0x24
     da6:	4b35      	ldr	r3, [pc, #212]	; (e7c <xQueueGenericSend+0x16c>)
     da8:	4798      	blx	r3
     daa:	2800      	cmp	r0, #0
     dac:	d0f1      	beq.n	d92 <xQueueGenericSend+0x82>
								queueYIELD_IF_USING_PREEMPTION();
     dae:	4b31      	ldr	r3, [pc, #196]	; (e74 <xQueueGenericSend+0x164>)
     db0:	4798      	blx	r3
     db2:	e7ee      	b.n	d92 <xQueueGenericSend+0x82>
						else if( xYieldRequired != pdFALSE )
     db4:	2800      	cmp	r0, #0
     db6:	d0ec      	beq.n	d92 <xQueueGenericSend+0x82>
							queueYIELD_IF_USING_PREEMPTION();
     db8:	4b2e      	ldr	r3, [pc, #184]	; (e74 <xQueueGenericSend+0x164>)
     dba:	4798      	blx	r3
     dbc:	e7e9      	b.n	d92 <xQueueGenericSend+0x82>
					taskEXIT_CRITICAL();
     dbe:	4b2e      	ldr	r3, [pc, #184]	; (e78 <xQueueGenericSend+0x168>)
     dc0:	4798      	blx	r3
					return errQUEUE_FULL;
     dc2:	2000      	movs	r0, #0
     dc4:	e7e8      	b.n	d98 <xQueueGenericSend+0x88>
		prvLockQueue( pxQueue );
     dc6:	4b2c      	ldr	r3, [pc, #176]	; (e78 <xQueueGenericSend+0x168>)
     dc8:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     dca:	a901      	add	r1, sp, #4
     dcc:	a802      	add	r0, sp, #8
     dce:	4b2c      	ldr	r3, [pc, #176]	; (e80 <xQueueGenericSend+0x170>)
     dd0:	4798      	blx	r3
     dd2:	2800      	cmp	r0, #0
     dd4:	d141      	bne.n	e5a <xQueueGenericSend+0x14a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     dd6:	0020      	movs	r0, r4
     dd8:	4b2a      	ldr	r3, [pc, #168]	; (e84 <xQueueGenericSend+0x174>)
     dda:	4798      	blx	r3
     ddc:	2800      	cmp	r0, #0
     dde:	d036      	beq.n	e4e <xQueueGenericSend+0x13e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     de0:	0020      	movs	r0, r4
     de2:	3010      	adds	r0, #16
     de4:	9901      	ldr	r1, [sp, #4]
     de6:	4b28      	ldr	r3, [pc, #160]	; (e88 <xQueueGenericSend+0x178>)
     de8:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     dea:	0020      	movs	r0, r4
     dec:	4b27      	ldr	r3, [pc, #156]	; (e8c <xQueueGenericSend+0x17c>)
     dee:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     df0:	4b27      	ldr	r3, [pc, #156]	; (e90 <xQueueGenericSend+0x180>)
     df2:	4798      	blx	r3
     df4:	2800      	cmp	r0, #0
     df6:	d027      	beq.n	e48 <xQueueGenericSend+0x138>
		taskENTER_CRITICAL();
     df8:	4b26      	ldr	r3, [pc, #152]	; (e94 <xQueueGenericSend+0x184>)
     dfa:	4798      	blx	r3
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     dfc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     dfe:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     e00:	4293      	cmp	r3, r2
     e02:	d3b6      	bcc.n	d72 <xQueueGenericSend+0x62>
     e04:	2e02      	cmp	r6, #2
     e06:	d0b4      	beq.n	d72 <xQueueGenericSend+0x62>
				if( xTicksToWait == ( TickType_t ) 0 )
     e08:	9b01      	ldr	r3, [sp, #4]
     e0a:	2b00      	cmp	r3, #0
     e0c:	d0d7      	beq.n	dbe <xQueueGenericSend+0xae>
				else if( xEntryTimeSet == pdFALSE )
     e0e:	2d00      	cmp	r5, #0
     e10:	d103      	bne.n	e1a <xQueueGenericSend+0x10a>
					vTaskInternalSetTimeOutState( &xTimeOut );
     e12:	a802      	add	r0, sp, #8
     e14:	4b20      	ldr	r3, [pc, #128]	; (e98 <xQueueGenericSend+0x188>)
     e16:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
     e18:	3501      	adds	r5, #1
		taskEXIT_CRITICAL();
     e1a:	4b17      	ldr	r3, [pc, #92]	; (e78 <xQueueGenericSend+0x168>)
     e1c:	4798      	blx	r3
		vTaskSuspendAll();
     e1e:	4b1f      	ldr	r3, [pc, #124]	; (e9c <xQueueGenericSend+0x18c>)
     e20:	4798      	blx	r3
		prvLockQueue( pxQueue );
     e22:	4b1c      	ldr	r3, [pc, #112]	; (e94 <xQueueGenericSend+0x184>)
     e24:	4798      	blx	r3
     e26:	2344      	movs	r3, #68	; 0x44
     e28:	5ce3      	ldrb	r3, [r4, r3]
     e2a:	b25b      	sxtb	r3, r3
     e2c:	3301      	adds	r3, #1
     e2e:	d102      	bne.n	e36 <xQueueGenericSend+0x126>
     e30:	2200      	movs	r2, #0
     e32:	2344      	movs	r3, #68	; 0x44
     e34:	54e2      	strb	r2, [r4, r3]
     e36:	2345      	movs	r3, #69	; 0x45
     e38:	5ce3      	ldrb	r3, [r4, r3]
     e3a:	b25b      	sxtb	r3, r3
     e3c:	3301      	adds	r3, #1
     e3e:	d1c2      	bne.n	dc6 <xQueueGenericSend+0xb6>
     e40:	2200      	movs	r2, #0
     e42:	2345      	movs	r3, #69	; 0x45
     e44:	54e2      	strb	r2, [r4, r3]
     e46:	e7be      	b.n	dc6 <xQueueGenericSend+0xb6>
					portYIELD_WITHIN_API();
     e48:	4b0a      	ldr	r3, [pc, #40]	; (e74 <xQueueGenericSend+0x164>)
     e4a:	4798      	blx	r3
     e4c:	e7d4      	b.n	df8 <xQueueGenericSend+0xe8>
				prvUnlockQueue( pxQueue );
     e4e:	0020      	movs	r0, r4
     e50:	4b0e      	ldr	r3, [pc, #56]	; (e8c <xQueueGenericSend+0x17c>)
     e52:	4798      	blx	r3
				( void ) xTaskResumeAll();
     e54:	4b0e      	ldr	r3, [pc, #56]	; (e90 <xQueueGenericSend+0x180>)
     e56:	4798      	blx	r3
     e58:	e7ce      	b.n	df8 <xQueueGenericSend+0xe8>
			prvUnlockQueue( pxQueue );
     e5a:	0020      	movs	r0, r4
     e5c:	4b0b      	ldr	r3, [pc, #44]	; (e8c <xQueueGenericSend+0x17c>)
     e5e:	4798      	blx	r3
			( void ) xTaskResumeAll();
     e60:	4b0b      	ldr	r3, [pc, #44]	; (e90 <xQueueGenericSend+0x180>)
     e62:	4798      	blx	r3
			return errQUEUE_FULL;
     e64:	2000      	movs	r0, #0
     e66:	e797      	b.n	d98 <xQueueGenericSend+0x88>
     e68:	00001961 	.word	0x00001961
     e6c:	00000a61 	.word	0x00000a61
     e70:	00000aed 	.word	0x00000aed
     e74:	00000939 	.word	0x00000939
     e78:	00000969 	.word	0x00000969
     e7c:	00001851 	.word	0x00001851
     e80:	000018e5 	.word	0x000018e5
     e84:	00000a15 	.word	0x00000a15
     e88:	000017ed 	.word	0x000017ed
     e8c:	00000b7d 	.word	0x00000b7d
     e90:	00001631 	.word	0x00001631
     e94:	00000951 	.word	0x00000951
     e98:	000018d5 	.word	0x000018d5
     e9c:	00001509 	.word	0x00001509

00000ea0 <xQueueGenericSendFromISR>:
{
     ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
     ea2:	b083      	sub	sp, #12
     ea4:	0004      	movs	r4, r0
     ea6:	9100      	str	r1, [sp, #0]
     ea8:	0017      	movs	r7, r2
     eaa:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     eac:	2800      	cmp	r0, #0
     eae:	d007      	beq.n	ec0 <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     eb0:	9b00      	ldr	r3, [sp, #0]
     eb2:	2b00      	cmp	r3, #0
     eb4:	d006      	beq.n	ec4 <xQueueGenericSendFromISR+0x24>
     eb6:	2301      	movs	r3, #1
     eb8:	2b00      	cmp	r3, #0
     eba:	d10a      	bne.n	ed2 <xQueueGenericSendFromISR+0x32>
     ebc:	b672      	cpsid	i
     ebe:	e7fe      	b.n	ebe <xQueueGenericSendFromISR+0x1e>
	configASSERT( pxQueue );
     ec0:	b672      	cpsid	i
     ec2:	e7fe      	b.n	ec2 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     ec4:	6c03      	ldr	r3, [r0, #64]	; 0x40
     ec6:	2b00      	cmp	r3, #0
     ec8:	d101      	bne.n	ece <xQueueGenericSendFromISR+0x2e>
     eca:	3301      	adds	r3, #1
     ecc:	e7f4      	b.n	eb8 <xQueueGenericSendFromISR+0x18>
     ece:	2300      	movs	r3, #0
     ed0:	e7f2      	b.n	eb8 <xQueueGenericSendFromISR+0x18>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     ed2:	2d02      	cmp	r5, #2
     ed4:	d003      	beq.n	ede <xQueueGenericSendFromISR+0x3e>
     ed6:	2b00      	cmp	r3, #0
     ed8:	d106      	bne.n	ee8 <xQueueGenericSendFromISR+0x48>
     eda:	b672      	cpsid	i
     edc:	e7fe      	b.n	edc <xQueueGenericSendFromISR+0x3c>
     ede:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     ee0:	2a01      	cmp	r2, #1
     ee2:	d0f8      	beq.n	ed6 <xQueueGenericSendFromISR+0x36>
     ee4:	2300      	movs	r3, #0
     ee6:	e7f6      	b.n	ed6 <xQueueGenericSendFromISR+0x36>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     ee8:	4b23      	ldr	r3, [pc, #140]	; (f78 <xQueueGenericSendFromISR+0xd8>)
     eea:	4798      	blx	r3
     eec:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     eee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     ef0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     ef2:	4293      	cmp	r3, r2
     ef4:	d301      	bcc.n	efa <xQueueGenericSendFromISR+0x5a>
     ef6:	2d02      	cmp	r5, #2
     ef8:	d132      	bne.n	f60 <xQueueGenericSendFromISR+0xc0>
			const int8_t cTxLock = pxQueue->cTxLock;
     efa:	2345      	movs	r3, #69	; 0x45
     efc:	5ce6      	ldrb	r6, [r4, r3]
     efe:	b276      	sxtb	r6, r6
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f00:	002a      	movs	r2, r5
     f02:	9900      	ldr	r1, [sp, #0]
     f04:	0020      	movs	r0, r4
     f06:	4b1d      	ldr	r3, [pc, #116]	; (f7c <xQueueGenericSendFromISR+0xdc>)
     f08:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
     f0a:	1c73      	adds	r3, r6, #1
     f0c:	d122      	bne.n	f54 <xQueueGenericSendFromISR+0xb4>
					if( pxQueue->pxQueueSetContainer != NULL )
     f0e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     f10:	2b00      	cmp	r3, #0
     f12:	d010      	beq.n	f36 <xQueueGenericSendFromISR+0x96>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     f14:	0029      	movs	r1, r5
     f16:	0020      	movs	r0, r4
     f18:	4b19      	ldr	r3, [pc, #100]	; (f80 <xQueueGenericSendFromISR+0xe0>)
     f1a:	4798      	blx	r3
     f1c:	2800      	cmp	r0, #0
     f1e:	d021      	beq.n	f64 <xQueueGenericSendFromISR+0xc4>
							if( pxHigherPriorityTaskWoken != NULL )
     f20:	2f00      	cmp	r7, #0
     f22:	d021      	beq.n	f68 <xQueueGenericSendFromISR+0xc8>
								*pxHigherPriorityTaskWoken = pdTRUE;
     f24:	2301      	movs	r3, #1
     f26:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
     f28:	2401      	movs	r4, #1
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
     f2a:	9801      	ldr	r0, [sp, #4]
     f2c:	4b15      	ldr	r3, [pc, #84]	; (f84 <xQueueGenericSendFromISR+0xe4>)
     f2e:	4798      	blx	r3
}
     f30:	0020      	movs	r0, r4
     f32:	b003      	add	sp, #12
     f34:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f36:	6a63      	ldr	r3, [r4, #36]	; 0x24
     f38:	2b00      	cmp	r3, #0
     f3a:	d017      	beq.n	f6c <xQueueGenericSendFromISR+0xcc>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f3c:	0020      	movs	r0, r4
     f3e:	3024      	adds	r0, #36	; 0x24
     f40:	4b11      	ldr	r3, [pc, #68]	; (f88 <xQueueGenericSendFromISR+0xe8>)
     f42:	4798      	blx	r3
     f44:	2800      	cmp	r0, #0
     f46:	d013      	beq.n	f70 <xQueueGenericSendFromISR+0xd0>
								if( pxHigherPriorityTaskWoken != NULL )
     f48:	2f00      	cmp	r7, #0
     f4a:	d013      	beq.n	f74 <xQueueGenericSendFromISR+0xd4>
									*pxHigherPriorityTaskWoken = pdTRUE;
     f4c:	2301      	movs	r3, #1
     f4e:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
     f50:	2401      	movs	r4, #1
     f52:	e7ea      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     f54:	1c73      	adds	r3, r6, #1
     f56:	b25b      	sxtb	r3, r3
     f58:	2245      	movs	r2, #69	; 0x45
     f5a:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
     f5c:	2401      	movs	r4, #1
     f5e:	e7e4      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
			xReturn = errQUEUE_FULL;
     f60:	2400      	movs	r4, #0
     f62:	e7e2      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
			xReturn = pdPASS;
     f64:	2401      	movs	r4, #1
     f66:	e7e0      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
     f68:	2401      	movs	r4, #1
     f6a:	e7de      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
     f6c:	2401      	movs	r4, #1
     f6e:	e7dc      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
     f70:	2401      	movs	r4, #1
     f72:	e7da      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
     f74:	2401      	movs	r4, #1
     f76:	e7d8      	b.n	f2a <xQueueGenericSendFromISR+0x8a>
     f78:	00000989 	.word	0x00000989
     f7c:	00000a61 	.word	0x00000a61
     f80:	00000aed 	.word	0x00000aed
     f84:	00000991 	.word	0x00000991
     f88:	00001851 	.word	0x00001851

00000f8c <xQueueReceive>:
{
     f8c:	b5f0      	push	{r4, r5, r6, r7, lr}
     f8e:	b085      	sub	sp, #20
     f90:	0004      	movs	r4, r0
     f92:	000e      	movs	r6, r1
     f94:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
     f96:	2800      	cmp	r0, #0
     f98:	d006      	beq.n	fa8 <xQueueReceive+0x1c>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     f9a:	2900      	cmp	r1, #0
     f9c:	d006      	beq.n	fac <xQueueReceive+0x20>
     f9e:	2501      	movs	r5, #1
     fa0:	2d00      	cmp	r5, #0
     fa2:	d10a      	bne.n	fba <xQueueReceive+0x2e>
     fa4:	b672      	cpsid	i
     fa6:	e7fe      	b.n	fa6 <xQueueReceive+0x1a>
	configASSERT( ( pxQueue ) );
     fa8:	b672      	cpsid	i
     faa:	e7fe      	b.n	faa <xQueueReceive+0x1e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     fac:	6c03      	ldr	r3, [r0, #64]	; 0x40
     fae:	2b00      	cmp	r3, #0
     fb0:	d101      	bne.n	fb6 <xQueueReceive+0x2a>
     fb2:	2501      	movs	r5, #1
     fb4:	e7f4      	b.n	fa0 <xQueueReceive+0x14>
     fb6:	2500      	movs	r5, #0
     fb8:	e7f2      	b.n	fa0 <xQueueReceive+0x14>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     fba:	4b3e      	ldr	r3, [pc, #248]	; (10b4 <xQueueReceive+0x128>)
     fbc:	4798      	blx	r3
     fbe:	2800      	cmp	r0, #0
     fc0:	d103      	bne.n	fca <xQueueReceive+0x3e>
     fc2:	9b01      	ldr	r3, [sp, #4]
     fc4:	2b00      	cmp	r3, #0
     fc6:	d000      	beq.n	fca <xQueueReceive+0x3e>
     fc8:	2500      	movs	r5, #0
     fca:	2d00      	cmp	r5, #0
     fcc:	d101      	bne.n	fd2 <xQueueReceive+0x46>
     fce:	b672      	cpsid	i
     fd0:	e7fe      	b.n	fd0 <xQueueReceive+0x44>
     fd2:	2700      	movs	r7, #0
     fd4:	e02b      	b.n	102e <xQueueReceive+0xa2>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
     fd6:	0031      	movs	r1, r6
     fd8:	0020      	movs	r0, r4
     fda:	4b37      	ldr	r3, [pc, #220]	; (10b8 <xQueueReceive+0x12c>)
     fdc:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     fde:	3d01      	subs	r5, #1
     fe0:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fe2:	6923      	ldr	r3, [r4, #16]
     fe4:	2b00      	cmp	r3, #0
     fe6:	d007      	beq.n	ff8 <xQueueReceive+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fe8:	0020      	movs	r0, r4
     fea:	3010      	adds	r0, #16
     fec:	4b33      	ldr	r3, [pc, #204]	; (10bc <xQueueReceive+0x130>)
     fee:	4798      	blx	r3
     ff0:	2800      	cmp	r0, #0
     ff2:	d001      	beq.n	ff8 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
     ff4:	4b32      	ldr	r3, [pc, #200]	; (10c0 <xQueueReceive+0x134>)
     ff6:	4798      	blx	r3
				taskEXIT_CRITICAL();
     ff8:	4b32      	ldr	r3, [pc, #200]	; (10c4 <xQueueReceive+0x138>)
     ffa:	4798      	blx	r3
				return pdPASS;
     ffc:	2001      	movs	r0, #1
}
     ffe:	b005      	add	sp, #20
    1000:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
    1002:	4b30      	ldr	r3, [pc, #192]	; (10c4 <xQueueReceive+0x138>)
    1004:	4798      	blx	r3
					return errQUEUE_EMPTY;
    1006:	2000      	movs	r0, #0
    1008:	e7f9      	b.n	ffe <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
    100a:	a802      	add	r0, sp, #8
    100c:	4b2e      	ldr	r3, [pc, #184]	; (10c8 <xQueueReceive+0x13c>)
    100e:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    1010:	3701      	adds	r7, #1
    1012:	e016      	b.n	1042 <xQueueReceive+0xb6>
		prvLockQueue( pxQueue );
    1014:	2200      	movs	r2, #0
    1016:	2344      	movs	r3, #68	; 0x44
    1018:	54e2      	strb	r2, [r4, r3]
    101a:	e01d      	b.n	1058 <xQueueReceive+0xcc>
    101c:	2200      	movs	r2, #0
    101e:	2345      	movs	r3, #69	; 0x45
    1020:	54e2      	strb	r2, [r4, r3]
    1022:	e01e      	b.n	1062 <xQueueReceive+0xd6>
				prvUnlockQueue( pxQueue );
    1024:	0020      	movs	r0, r4
    1026:	4b29      	ldr	r3, [pc, #164]	; (10cc <xQueueReceive+0x140>)
    1028:	4798      	blx	r3
				( void ) xTaskResumeAll();
    102a:	4b29      	ldr	r3, [pc, #164]	; (10d0 <xQueueReceive+0x144>)
    102c:	4798      	blx	r3
		taskENTER_CRITICAL();
    102e:	4b29      	ldr	r3, [pc, #164]	; (10d4 <xQueueReceive+0x148>)
    1030:	4798      	blx	r3
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1032:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1034:	2d00      	cmp	r5, #0
    1036:	d1ce      	bne.n	fd6 <xQueueReceive+0x4a>
				if( xTicksToWait == ( TickType_t ) 0 )
    1038:	9b01      	ldr	r3, [sp, #4]
    103a:	2b00      	cmp	r3, #0
    103c:	d0e1      	beq.n	1002 <xQueueReceive+0x76>
				else if( xEntryTimeSet == pdFALSE )
    103e:	2f00      	cmp	r7, #0
    1040:	d0e3      	beq.n	100a <xQueueReceive+0x7e>
		taskEXIT_CRITICAL();
    1042:	4b20      	ldr	r3, [pc, #128]	; (10c4 <xQueueReceive+0x138>)
    1044:	4798      	blx	r3
		vTaskSuspendAll();
    1046:	4b24      	ldr	r3, [pc, #144]	; (10d8 <xQueueReceive+0x14c>)
    1048:	4798      	blx	r3
		prvLockQueue( pxQueue );
    104a:	4b22      	ldr	r3, [pc, #136]	; (10d4 <xQueueReceive+0x148>)
    104c:	4798      	blx	r3
    104e:	2344      	movs	r3, #68	; 0x44
    1050:	5ce3      	ldrb	r3, [r4, r3]
    1052:	b25b      	sxtb	r3, r3
    1054:	3301      	adds	r3, #1
    1056:	d0dd      	beq.n	1014 <xQueueReceive+0x88>
    1058:	2345      	movs	r3, #69	; 0x45
    105a:	5ce3      	ldrb	r3, [r4, r3]
    105c:	b25b      	sxtb	r3, r3
    105e:	3301      	adds	r3, #1
    1060:	d0dc      	beq.n	101c <xQueueReceive+0x90>
    1062:	4b18      	ldr	r3, [pc, #96]	; (10c4 <xQueueReceive+0x138>)
    1064:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1066:	a901      	add	r1, sp, #4
    1068:	a802      	add	r0, sp, #8
    106a:	4b1c      	ldr	r3, [pc, #112]	; (10dc <xQueueReceive+0x150>)
    106c:	4798      	blx	r3
    106e:	2800      	cmp	r0, #0
    1070:	d113      	bne.n	109a <xQueueReceive+0x10e>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1072:	0020      	movs	r0, r4
    1074:	4b1a      	ldr	r3, [pc, #104]	; (10e0 <xQueueReceive+0x154>)
    1076:	4798      	blx	r3
    1078:	2800      	cmp	r0, #0
    107a:	d0d3      	beq.n	1024 <xQueueReceive+0x98>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    107c:	0020      	movs	r0, r4
    107e:	3024      	adds	r0, #36	; 0x24
    1080:	9901      	ldr	r1, [sp, #4]
    1082:	4b18      	ldr	r3, [pc, #96]	; (10e4 <xQueueReceive+0x158>)
    1084:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    1086:	0020      	movs	r0, r4
    1088:	4b10      	ldr	r3, [pc, #64]	; (10cc <xQueueReceive+0x140>)
    108a:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    108c:	4b10      	ldr	r3, [pc, #64]	; (10d0 <xQueueReceive+0x144>)
    108e:	4798      	blx	r3
    1090:	2800      	cmp	r0, #0
    1092:	d1cc      	bne.n	102e <xQueueReceive+0xa2>
					portYIELD_WITHIN_API();
    1094:	4b0a      	ldr	r3, [pc, #40]	; (10c0 <xQueueReceive+0x134>)
    1096:	4798      	blx	r3
    1098:	e7c9      	b.n	102e <xQueueReceive+0xa2>
			prvUnlockQueue( pxQueue );
    109a:	0020      	movs	r0, r4
    109c:	4b0b      	ldr	r3, [pc, #44]	; (10cc <xQueueReceive+0x140>)
    109e:	4798      	blx	r3
			( void ) xTaskResumeAll();
    10a0:	4b0b      	ldr	r3, [pc, #44]	; (10d0 <xQueueReceive+0x144>)
    10a2:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    10a4:	0020      	movs	r0, r4
    10a6:	4b0e      	ldr	r3, [pc, #56]	; (10e0 <xQueueReceive+0x154>)
    10a8:	4798      	blx	r3
    10aa:	2800      	cmp	r0, #0
    10ac:	d0bf      	beq.n	102e <xQueueReceive+0xa2>
				return errQUEUE_EMPTY;
    10ae:	2000      	movs	r0, #0
    10b0:	e7a5      	b.n	ffe <xQueueReceive+0x72>
    10b2:	46c0      	nop			; (mov r8, r8)
    10b4:	00001961 	.word	0x00001961
    10b8:	00000b55 	.word	0x00000b55
    10bc:	00001851 	.word	0x00001851
    10c0:	00000939 	.word	0x00000939
    10c4:	00000969 	.word	0x00000969
    10c8:	000018d5 	.word	0x000018d5
    10cc:	00000b7d 	.word	0x00000b7d
    10d0:	00001631 	.word	0x00001631
    10d4:	00000951 	.word	0x00000951
    10d8:	00001509 	.word	0x00001509
    10dc:	000018e5 	.word	0x000018e5
    10e0:	00000a3d 	.word	0x00000a3d
    10e4:	000017ed 	.word	0x000017ed

000010e8 <vQueueAddToRegistry>:
	{
    10e8:	b510      	push	{r4, lr}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    10ea:	2300      	movs	r3, #0
    10ec:	2b07      	cmp	r3, #7
    10ee:	d80a      	bhi.n	1106 <vQueueAddToRegistry+0x1e>
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    10f0:	00da      	lsls	r2, r3, #3
    10f2:	4c05      	ldr	r4, [pc, #20]	; (1108 <vQueueAddToRegistry+0x20>)
    10f4:	5912      	ldr	r2, [r2, r4]
    10f6:	2a00      	cmp	r2, #0
    10f8:	d001      	beq.n	10fe <vQueueAddToRegistry+0x16>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    10fa:	3301      	adds	r3, #1
    10fc:	e7f6      	b.n	10ec <vQueueAddToRegistry+0x4>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    10fe:	00db      	lsls	r3, r3, #3
    1100:	5119      	str	r1, [r3, r4]
				xQueueRegistry[ ux ].xHandle = xQueue;
    1102:	18e3      	adds	r3, r4, r3
    1104:	6058      	str	r0, [r3, #4]
	}
    1106:	bd10      	pop	{r4, pc}
    1108:	2000444c 	.word	0x2000444c

0000110c <vQueueWaitForMessageRestricted>:
	{
    110c:	b570      	push	{r4, r5, r6, lr}
    110e:	0004      	movs	r4, r0
    1110:	000d      	movs	r5, r1
    1112:	0016      	movs	r6, r2
		prvLockQueue( pxQueue );
    1114:	4b11      	ldr	r3, [pc, #68]	; (115c <vQueueWaitForMessageRestricted+0x50>)
    1116:	4798      	blx	r3
    1118:	2344      	movs	r3, #68	; 0x44
    111a:	5ce3      	ldrb	r3, [r4, r3]
    111c:	b25b      	sxtb	r3, r3
    111e:	3301      	adds	r3, #1
    1120:	d00d      	beq.n	113e <vQueueWaitForMessageRestricted+0x32>
    1122:	2345      	movs	r3, #69	; 0x45
    1124:	5ce3      	ldrb	r3, [r4, r3]
    1126:	b25b      	sxtb	r3, r3
    1128:	3301      	adds	r3, #1
    112a:	d00c      	beq.n	1146 <vQueueWaitForMessageRestricted+0x3a>
    112c:	4b0c      	ldr	r3, [pc, #48]	; (1160 <vQueueWaitForMessageRestricted+0x54>)
    112e:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1130:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1132:	2b00      	cmp	r3, #0
    1134:	d00b      	beq.n	114e <vQueueWaitForMessageRestricted+0x42>
		prvUnlockQueue( pxQueue );
    1136:	0020      	movs	r0, r4
    1138:	4b0a      	ldr	r3, [pc, #40]	; (1164 <vQueueWaitForMessageRestricted+0x58>)
    113a:	4798      	blx	r3
	}
    113c:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
    113e:	2200      	movs	r2, #0
    1140:	2344      	movs	r3, #68	; 0x44
    1142:	54e2      	strb	r2, [r4, r3]
    1144:	e7ed      	b.n	1122 <vQueueWaitForMessageRestricted+0x16>
    1146:	2200      	movs	r2, #0
    1148:	2345      	movs	r3, #69	; 0x45
    114a:	54e2      	strb	r2, [r4, r3]
    114c:	e7ee      	b.n	112c <vQueueWaitForMessageRestricted+0x20>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    114e:	0020      	movs	r0, r4
    1150:	3024      	adds	r0, #36	; 0x24
    1152:	0032      	movs	r2, r6
    1154:	0029      	movs	r1, r5
    1156:	4b04      	ldr	r3, [pc, #16]	; (1168 <vQueueWaitForMessageRestricted+0x5c>)
    1158:	4798      	blx	r3
    115a:	e7ec      	b.n	1136 <vQueueWaitForMessageRestricted+0x2a>
    115c:	00000951 	.word	0x00000951
    1160:	00000969 	.word	0x00000969
    1164:	00000b7d 	.word	0x00000b7d
    1168:	00001819 	.word	0x00001819

0000116c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    116c:	4b0a      	ldr	r3, [pc, #40]	; (1198 <prvResetNextTaskUnblockTime+0x2c>)
    116e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1170:	681b      	ldr	r3, [r3, #0]
    1172:	2b00      	cmp	r3, #0
    1174:	d109      	bne.n	118a <prvResetNextTaskUnblockTime+0x1e>
    1176:	3301      	adds	r3, #1
    1178:	2b00      	cmp	r3, #0
    117a:	d108      	bne.n	118e <prvResetNextTaskUnblockTime+0x22>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    117c:	4b06      	ldr	r3, [pc, #24]	; (1198 <prvResetNextTaskUnblockTime+0x2c>)
    117e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1180:	68d2      	ldr	r2, [r2, #12]
    1182:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1184:	6852      	ldr	r2, [r2, #4]
    1186:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    1188:	4770      	bx	lr
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    118a:	2300      	movs	r3, #0
    118c:	e7f4      	b.n	1178 <prvResetNextTaskUnblockTime+0xc>
		xNextTaskUnblockTime = portMAX_DELAY;
    118e:	2201      	movs	r2, #1
    1190:	4252      	negs	r2, r2
    1192:	4b01      	ldr	r3, [pc, #4]	; (1198 <prvResetNextTaskUnblockTime+0x2c>)
    1194:	62da      	str	r2, [r3, #44]	; 0x2c
    1196:	e7f7      	b.n	1188 <prvResetNextTaskUnblockTime+0x1c>
    1198:	2000430c 	.word	0x2000430c

0000119c <prvDeleteTCB>:
	{
    119c:	b570      	push	{r4, r5, r6, lr}
    119e:	0005      	movs	r5, r0
			vPortFree( pxTCB->pxStack );
    11a0:	6b00      	ldr	r0, [r0, #48]	; 0x30
    11a2:	4c02      	ldr	r4, [pc, #8]	; (11ac <prvDeleteTCB+0x10>)
    11a4:	47a0      	blx	r4
			vPortFree( pxTCB );
    11a6:	0028      	movs	r0, r5
    11a8:	47a0      	blx	r4
	}
    11aa:	bd70      	pop	{r4, r5, r6, pc}
    11ac:	000002c9 	.word	0x000002c9

000011b0 <prvInitialiseNewTask>:
{
    11b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    11b2:	46c6      	mov	lr, r8
    11b4:	b500      	push	{lr}
    11b6:	b082      	sub	sp, #8
    11b8:	9000      	str	r0, [sp, #0]
    11ba:	000f      	movs	r7, r1
    11bc:	0015      	movs	r5, r2
    11be:	9301      	str	r3, [sp, #4]
    11c0:	9c08      	ldr	r4, [sp, #32]
    11c2:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    11c4:	0092      	lsls	r2, r2, #2
    11c6:	21a5      	movs	r1, #165	; 0xa5
    11c8:	6b30      	ldr	r0, [r6, #48]	; 0x30
    11ca:	4b1f      	ldr	r3, [pc, #124]	; (1248 <prvInitialiseNewTask+0x98>)
    11cc:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    11ce:	4b1f      	ldr	r3, [pc, #124]	; (124c <prvInitialiseNewTask+0x9c>)
    11d0:	18eb      	adds	r3, r5, r3
    11d2:	009b      	lsls	r3, r3, #2
    11d4:	6b32      	ldr	r2, [r6, #48]	; 0x30
    11d6:	4694      	mov	ip, r2
    11d8:	4463      	add	r3, ip
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    11da:	2207      	movs	r2, #7
    11dc:	4393      	bics	r3, r2
    11de:	4698      	mov	r8, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    11e0:	2300      	movs	r3, #0
    11e2:	2b04      	cmp	r3, #4
    11e4:	d809      	bhi.n	11fa <prvInitialiseNewTask+0x4a>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    11e6:	18f9      	adds	r1, r7, r3
    11e8:	7808      	ldrb	r0, [r1, #0]
    11ea:	18f2      	adds	r2, r6, r3
    11ec:	3234      	adds	r2, #52	; 0x34
    11ee:	7010      	strb	r0, [r2, #0]
		if( pcName[ x ] == 0x00 )
    11f0:	780a      	ldrb	r2, [r1, #0]
    11f2:	2a00      	cmp	r2, #0
    11f4:	d001      	beq.n	11fa <prvInitialiseNewTask+0x4a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    11f6:	3301      	adds	r3, #1
    11f8:	e7f3      	b.n	11e2 <prvInitialiseNewTask+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    11fa:	2200      	movs	r2, #0
    11fc:	2338      	movs	r3, #56	; 0x38
    11fe:	54f2      	strb	r2, [r6, r3]
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1200:	2c04      	cmp	r4, #4
    1202:	d900      	bls.n	1206 <prvInitialiseNewTask+0x56>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1204:	2404      	movs	r4, #4
	pxNewTCB->uxPriority = uxPriority;
    1206:	62f4      	str	r4, [r6, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    1208:	6474      	str	r4, [r6, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    120a:	2500      	movs	r5, #0
    120c:	64b5      	str	r5, [r6, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    120e:	1d30      	adds	r0, r6, #4
    1210:	4f0f      	ldr	r7, [pc, #60]	; (1250 <prvInitialiseNewTask+0xa0>)
    1212:	47b8      	blx	r7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1214:	0030      	movs	r0, r6
    1216:	3018      	adds	r0, #24
    1218:	47b8      	blx	r7
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    121a:	6136      	str	r6, [r6, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    121c:	2305      	movs	r3, #5
    121e:	1b1c      	subs	r4, r3, r4
    1220:	61b4      	str	r4, [r6, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1222:	6276      	str	r6, [r6, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    1224:	64f5      	str	r5, [r6, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1226:	334b      	adds	r3, #75	; 0x4b
    1228:	54f5      	strb	r5, [r6, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    122a:	9a01      	ldr	r2, [sp, #4]
    122c:	9900      	ldr	r1, [sp, #0]
    122e:	4640      	mov	r0, r8
    1230:	4b08      	ldr	r3, [pc, #32]	; (1254 <prvInitialiseNewTask+0xa4>)
    1232:	4798      	blx	r3
    1234:	6030      	str	r0, [r6, #0]
	if( ( void * ) pxCreatedTask != NULL )
    1236:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1238:	2b00      	cmp	r3, #0
    123a:	d000      	beq.n	123e <prvInitialiseNewTask+0x8e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    123c:	601e      	str	r6, [r3, #0]
}
    123e:	b002      	add	sp, #8
    1240:	bc04      	pop	{r2}
    1242:	4690      	mov	r8, r2
    1244:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1246:	46c0      	nop			; (mov r8, r8)
    1248:	00001f55 	.word	0x00001f55
    124c:	3fffffff 	.word	0x3fffffff
    1250:	00000327 	.word	0x00000327
    1254:	000008cd 	.word	0x000008cd

00001258 <prvInitialiseTaskLists>:
{
    1258:	b5f0      	push	{r4, r5, r6, r7, lr}
    125a:	46c6      	mov	lr, r8
    125c:	b500      	push	{lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    125e:	2400      	movs	r4, #0
    1260:	e008      	b.n	1274 <prvInitialiseTaskLists+0x1c>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1262:	00a3      	lsls	r3, r4, #2
    1264:	191b      	adds	r3, r3, r4
    1266:	009a      	lsls	r2, r3, #2
    1268:	4810      	ldr	r0, [pc, #64]	; (12ac <prvInitialiseTaskLists+0x54>)
    126a:	3030      	adds	r0, #48	; 0x30
    126c:	1880      	adds	r0, r0, r2
    126e:	4b10      	ldr	r3, [pc, #64]	; (12b0 <prvInitialiseTaskLists+0x58>)
    1270:	4798      	blx	r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1272:	3401      	adds	r4, #1
    1274:	2c04      	cmp	r4, #4
    1276:	d9f4      	bls.n	1262 <prvInitialiseTaskLists+0xa>
	vListInitialise( &xDelayedTaskList1 );
    1278:	4d0e      	ldr	r5, [pc, #56]	; (12b4 <prvInitialiseTaskLists+0x5c>)
    127a:	2314      	movs	r3, #20
    127c:	4698      	mov	r8, r3
    127e:	44a8      	add	r8, r5
    1280:	4640      	mov	r0, r8
    1282:	4c0b      	ldr	r4, [pc, #44]	; (12b0 <prvInitialiseTaskLists+0x58>)
    1284:	47a0      	blx	r4
	vListInitialise( &xDelayedTaskList2 );
    1286:	002f      	movs	r7, r5
    1288:	3728      	adds	r7, #40	; 0x28
    128a:	0038      	movs	r0, r7
    128c:	47a0      	blx	r4
	vListInitialise( &xPendingReadyList );
    128e:	4e07      	ldr	r6, [pc, #28]	; (12ac <prvInitialiseTaskLists+0x54>)
    1290:	0030      	movs	r0, r6
    1292:	3014      	adds	r0, #20
    1294:	47a0      	blx	r4
		vListInitialise( &xTasksWaitingTermination );
    1296:	0028      	movs	r0, r5
    1298:	303c      	adds	r0, #60	; 0x3c
    129a:	47a0      	blx	r4
		vListInitialise( &xSuspendedTaskList );
    129c:	0030      	movs	r0, r6
    129e:	47a0      	blx	r4
	pxDelayedTaskList = &xDelayedTaskList1;
    12a0:	4643      	mov	r3, r8
    12a2:	62b3      	str	r3, [r6, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    12a4:	652f      	str	r7, [r5, #80]	; 0x50
}
    12a6:	bc04      	pop	{r2}
    12a8:	4690      	mov	r8, r2
    12aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    12ac:	2000430c 	.word	0x2000430c
    12b0:	00000311 	.word	0x00000311
    12b4:	2000438c 	.word	0x2000438c

000012b8 <prvAddNewTaskToReadyList>:
{
    12b8:	b510      	push	{r4, lr}
    12ba:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
    12bc:	4b1f      	ldr	r3, [pc, #124]	; (133c <prvAddNewTaskToReadyList+0x84>)
    12be:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    12c0:	4b1f      	ldr	r3, [pc, #124]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    12c2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    12c4:	3201      	adds	r2, #1
    12c6:	655a      	str	r2, [r3, #84]	; 0x54
		if( pxCurrentTCB == NULL )
    12c8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    12ca:	2b00      	cmp	r3, #0
    12cc:	d02b      	beq.n	1326 <prvAddNewTaskToReadyList+0x6e>
			if( xSchedulerRunning == pdFALSE )
    12ce:	4b1c      	ldr	r3, [pc, #112]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    12d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    12d2:	2b00      	cmp	r3, #0
    12d4:	d107      	bne.n	12e6 <prvAddNewTaskToReadyList+0x2e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    12d6:	4b1a      	ldr	r3, [pc, #104]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    12d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    12da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    12dc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    12de:	4293      	cmp	r3, r2
    12e0:	d801      	bhi.n	12e6 <prvAddNewTaskToReadyList+0x2e>
					pxCurrentTCB = pxNewTCB;
    12e2:	4b17      	ldr	r3, [pc, #92]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    12e4:	659c      	str	r4, [r3, #88]	; 0x58
		uxTaskNumber++;
    12e6:	4916      	ldr	r1, [pc, #88]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    12e8:	6e0b      	ldr	r3, [r1, #96]	; 0x60
    12ea:	3301      	adds	r3, #1
    12ec:	660b      	str	r3, [r1, #96]	; 0x60
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    12ee:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList( pxNewTCB );
    12f0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    12f2:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    12f4:	429a      	cmp	r2, r3
    12f6:	d900      	bls.n	12fa <prvAddNewTaskToReadyList+0x42>
    12f8:	664a      	str	r2, [r1, #100]	; 0x64
    12fa:	1d21      	adds	r1, r4, #4
    12fc:	0093      	lsls	r3, r2, #2
    12fe:	189b      	adds	r3, r3, r2
    1300:	009a      	lsls	r2, r3, #2
    1302:	4810      	ldr	r0, [pc, #64]	; (1344 <prvAddNewTaskToReadyList+0x8c>)
    1304:	3030      	adds	r0, #48	; 0x30
    1306:	1880      	adds	r0, r0, r2
    1308:	4b0f      	ldr	r3, [pc, #60]	; (1348 <prvAddNewTaskToReadyList+0x90>)
    130a:	4798      	blx	r3
	taskEXIT_CRITICAL();
    130c:	4b0f      	ldr	r3, [pc, #60]	; (134c <prvAddNewTaskToReadyList+0x94>)
    130e:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    1310:	4b0b      	ldr	r3, [pc, #44]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    1312:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1314:	2b00      	cmp	r3, #0
    1316:	d005      	beq.n	1324 <prvAddNewTaskToReadyList+0x6c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1318:	4b09      	ldr	r3, [pc, #36]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    131a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    131c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    131e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1320:	429a      	cmp	r2, r3
    1322:	d308      	bcc.n	1336 <prvAddNewTaskToReadyList+0x7e>
}
    1324:	bd10      	pop	{r4, pc}
			pxCurrentTCB = pxNewTCB;
    1326:	4b06      	ldr	r3, [pc, #24]	; (1340 <prvAddNewTaskToReadyList+0x88>)
    1328:	659c      	str	r4, [r3, #88]	; 0x58
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    132a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    132c:	2b01      	cmp	r3, #1
    132e:	d1da      	bne.n	12e6 <prvAddNewTaskToReadyList+0x2e>
				prvInitialiseTaskLists();
    1330:	4b07      	ldr	r3, [pc, #28]	; (1350 <prvAddNewTaskToReadyList+0x98>)
    1332:	4798      	blx	r3
    1334:	e7d7      	b.n	12e6 <prvAddNewTaskToReadyList+0x2e>
			taskYIELD_IF_USING_PREEMPTION();
    1336:	4b07      	ldr	r3, [pc, #28]	; (1354 <prvAddNewTaskToReadyList+0x9c>)
    1338:	4798      	blx	r3
}
    133a:	e7f3      	b.n	1324 <prvAddNewTaskToReadyList+0x6c>
    133c:	00000951 	.word	0x00000951
    1340:	2000438c 	.word	0x2000438c
    1344:	2000430c 	.word	0x2000430c
    1348:	0000032d 	.word	0x0000032d
    134c:	00000969 	.word	0x00000969
    1350:	00001259 	.word	0x00001259
    1354:	00000939 	.word	0x00000939

00001358 <prvCheckTasksWaitingTermination>:
{
    1358:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    135a:	e012      	b.n	1382 <prvCheckTasksWaitingTermination+0x2a>
			taskENTER_CRITICAL();
    135c:	4b0b      	ldr	r3, [pc, #44]	; (138c <prvCheckTasksWaitingTermination+0x34>)
    135e:	4798      	blx	r3
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1360:	4c0b      	ldr	r4, [pc, #44]	; (1390 <prvCheckTasksWaitingTermination+0x38>)
    1362:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1364:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1366:	1d28      	adds	r0, r5, #4
    1368:	4b0a      	ldr	r3, [pc, #40]	; (1394 <prvCheckTasksWaitingTermination+0x3c>)
    136a:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    136c:	6d63      	ldr	r3, [r4, #84]	; 0x54
    136e:	3b01      	subs	r3, #1
    1370:	6563      	str	r3, [r4, #84]	; 0x54
				--uxDeletedTasksWaitingCleanUp;
    1372:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    1374:	3b01      	subs	r3, #1
    1376:	66a3      	str	r3, [r4, #104]	; 0x68
			taskEXIT_CRITICAL();
    1378:	4b07      	ldr	r3, [pc, #28]	; (1398 <prvCheckTasksWaitingTermination+0x40>)
    137a:	4798      	blx	r3
			prvDeleteTCB( pxTCB );
    137c:	0028      	movs	r0, r5
    137e:	4b07      	ldr	r3, [pc, #28]	; (139c <prvCheckTasksWaitingTermination+0x44>)
    1380:	4798      	blx	r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1382:	4b03      	ldr	r3, [pc, #12]	; (1390 <prvCheckTasksWaitingTermination+0x38>)
    1384:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    1386:	2b00      	cmp	r3, #0
    1388:	d1e8      	bne.n	135c <prvCheckTasksWaitingTermination+0x4>
}
    138a:	bd70      	pop	{r4, r5, r6, pc}
    138c:	00000951 	.word	0x00000951
    1390:	2000438c 	.word	0x2000438c
    1394:	00000375 	.word	0x00000375
    1398:	00000969 	.word	0x00000969
    139c:	0000119d 	.word	0x0000119d

000013a0 <prvIdleTask>:
{
    13a0:	b510      	push	{r4, lr}
		prvCheckTasksWaitingTermination();
    13a2:	4b04      	ldr	r3, [pc, #16]	; (13b4 <prvIdleTask+0x14>)
    13a4:	4798      	blx	r3
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    13a6:	4b04      	ldr	r3, [pc, #16]	; (13b8 <prvIdleTask+0x18>)
    13a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    13aa:	2b01      	cmp	r3, #1
    13ac:	d9f9      	bls.n	13a2 <prvIdleTask+0x2>
				taskYIELD();
    13ae:	4b03      	ldr	r3, [pc, #12]	; (13bc <prvIdleTask+0x1c>)
    13b0:	4798      	blx	r3
    13b2:	e7f6      	b.n	13a2 <prvIdleTask+0x2>
    13b4:	00001359 	.word	0x00001359
    13b8:	2000430c 	.word	0x2000430c
    13bc:	00000939 	.word	0x00000939

000013c0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    13c0:	b570      	push	{r4, r5, r6, lr}
    13c2:	0004      	movs	r4, r0
    13c4:	000d      	movs	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    13c6:	4b15      	ldr	r3, [pc, #84]	; (141c <prvAddCurrentTaskToDelayedList+0x5c>)
    13c8:	6ede      	ldr	r6, [r3, #108]	; 0x6c
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    13ca:	6d98      	ldr	r0, [r3, #88]	; 0x58
    13cc:	3004      	adds	r0, #4
    13ce:	4b14      	ldr	r3, [pc, #80]	; (1420 <prvAddCurrentTaskToDelayedList+0x60>)
    13d0:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    13d2:	1c63      	adds	r3, r4, #1
    13d4:	d012      	beq.n	13fc <prvAddCurrentTaskToDelayedList+0x3c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    13d6:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    13d8:	4b10      	ldr	r3, [pc, #64]	; (141c <prvAddCurrentTaskToDelayedList+0x5c>)
    13da:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    13dc:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
    13de:	42a6      	cmp	r6, r4
    13e0:	d815      	bhi.n	140e <prvAddCurrentTaskToDelayedList+0x4e>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    13e2:	4d10      	ldr	r5, [pc, #64]	; (1424 <prvAddCurrentTaskToDelayedList+0x64>)
    13e4:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    13e6:	4b0d      	ldr	r3, [pc, #52]	; (141c <prvAddCurrentTaskToDelayedList+0x5c>)
    13e8:	6d99      	ldr	r1, [r3, #88]	; 0x58
    13ea:	3104      	adds	r1, #4
    13ec:	4b0e      	ldr	r3, [pc, #56]	; (1428 <prvAddCurrentTaskToDelayedList+0x68>)
    13ee:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    13f0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    13f2:	429c      	cmp	r4, r3
    13f4:	d211      	bcs.n	141a <prvAddCurrentTaskToDelayedList+0x5a>
				{
					xNextTaskUnblockTime = xTimeToWake;
    13f6:	4b0b      	ldr	r3, [pc, #44]	; (1424 <prvAddCurrentTaskToDelayedList+0x64>)
    13f8:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    13fa:	e00e      	b.n	141a <prvAddCurrentTaskToDelayedList+0x5a>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    13fc:	2d00      	cmp	r5, #0
    13fe:	d0ea      	beq.n	13d6 <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1400:	4b06      	ldr	r3, [pc, #24]	; (141c <prvAddCurrentTaskToDelayedList+0x5c>)
    1402:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1404:	3104      	adds	r1, #4
    1406:	4807      	ldr	r0, [pc, #28]	; (1424 <prvAddCurrentTaskToDelayedList+0x64>)
    1408:	4b08      	ldr	r3, [pc, #32]	; (142c <prvAddCurrentTaskToDelayedList+0x6c>)
    140a:	4798      	blx	r3
    140c:	e005      	b.n	141a <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    140e:	4b03      	ldr	r3, [pc, #12]	; (141c <prvAddCurrentTaskToDelayedList+0x5c>)
    1410:	6d18      	ldr	r0, [r3, #80]	; 0x50
    1412:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1414:	3104      	adds	r1, #4
    1416:	4b04      	ldr	r3, [pc, #16]	; (1428 <prvAddCurrentTaskToDelayedList+0x68>)
    1418:	4798      	blx	r3
}
    141a:	bd70      	pop	{r4, r5, r6, pc}
    141c:	2000438c 	.word	0x2000438c
    1420:	00000375 	.word	0x00000375
    1424:	2000430c 	.word	0x2000430c
    1428:	00000345 	.word	0x00000345
    142c:	0000032d 	.word	0x0000032d

00001430 <xTaskCreate>:
	{
    1430:	b5f0      	push	{r4, r5, r6, r7, lr}
    1432:	b087      	sub	sp, #28
    1434:	9004      	str	r0, [sp, #16]
    1436:	9105      	str	r1, [sp, #20]
    1438:	0014      	movs	r4, r2
    143a:	001f      	movs	r7, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    143c:	0090      	lsls	r0, r2, #2
    143e:	4b14      	ldr	r3, [pc, #80]	; (1490 <xTaskCreate+0x60>)
    1440:	4798      	blx	r3
    1442:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
    1444:	d01e      	beq.n	1484 <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1446:	2054      	movs	r0, #84	; 0x54
    1448:	4b11      	ldr	r3, [pc, #68]	; (1490 <xTaskCreate+0x60>)
    144a:	4798      	blx	r3
    144c:	1e05      	subs	r5, r0, #0
				if( pxNewTCB != NULL )
    144e:	d015      	beq.n	147c <xTaskCreate+0x4c>
					pxNewTCB->pxStack = pxStack;
    1450:	6306      	str	r6, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
    1452:	2d00      	cmp	r5, #0
    1454:	d018      	beq.n	1488 <xTaskCreate+0x58>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    1456:	2300      	movs	r3, #0
    1458:	9303      	str	r3, [sp, #12]
    145a:	9502      	str	r5, [sp, #8]
    145c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    145e:	9301      	str	r3, [sp, #4]
    1460:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1462:	9300      	str	r3, [sp, #0]
    1464:	003b      	movs	r3, r7
    1466:	0022      	movs	r2, r4
    1468:	9905      	ldr	r1, [sp, #20]
    146a:	9804      	ldr	r0, [sp, #16]
    146c:	4c09      	ldr	r4, [pc, #36]	; (1494 <xTaskCreate+0x64>)
    146e:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
    1470:	0028      	movs	r0, r5
    1472:	4b09      	ldr	r3, [pc, #36]	; (1498 <xTaskCreate+0x68>)
    1474:	4798      	blx	r3
			xReturn = pdPASS;
    1476:	2001      	movs	r0, #1
	}
    1478:	b007      	add	sp, #28
    147a:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
    147c:	0030      	movs	r0, r6
    147e:	4b07      	ldr	r3, [pc, #28]	; (149c <xTaskCreate+0x6c>)
    1480:	4798      	blx	r3
    1482:	e7e6      	b.n	1452 <xTaskCreate+0x22>
				pxNewTCB = NULL;
    1484:	2500      	movs	r5, #0
    1486:	e7e4      	b.n	1452 <xTaskCreate+0x22>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1488:	2001      	movs	r0, #1
    148a:	4240      	negs	r0, r0
		return xReturn;
    148c:	e7f4      	b.n	1478 <xTaskCreate+0x48>
    148e:	46c0      	nop			; (mov r8, r8)
    1490:	00000219 	.word	0x00000219
    1494:	000011b1 	.word	0x000011b1
    1498:	000012b9 	.word	0x000012b9
    149c:	000002c9 	.word	0x000002c9

000014a0 <vTaskStartScheduler>:
{
    14a0:	b510      	push	{r4, lr}
    14a2:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
    14a4:	4b11      	ldr	r3, [pc, #68]	; (14ec <vTaskStartScheduler+0x4c>)
    14a6:	3374      	adds	r3, #116	; 0x74
    14a8:	9301      	str	r3, [sp, #4]
    14aa:	2300      	movs	r3, #0
    14ac:	9300      	str	r3, [sp, #0]
    14ae:	2246      	movs	r2, #70	; 0x46
    14b0:	490f      	ldr	r1, [pc, #60]	; (14f0 <vTaskStartScheduler+0x50>)
    14b2:	4810      	ldr	r0, [pc, #64]	; (14f4 <vTaskStartScheduler+0x54>)
    14b4:	4c10      	ldr	r4, [pc, #64]	; (14f8 <vTaskStartScheduler+0x58>)
    14b6:	47a0      	blx	r4
		if( xReturn == pdPASS )
    14b8:	2801      	cmp	r0, #1
    14ba:	d005      	beq.n	14c8 <vTaskStartScheduler+0x28>
	if( xReturn == pdPASS )
    14bc:	2801      	cmp	r0, #1
    14be:	d006      	beq.n	14ce <vTaskStartScheduler+0x2e>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    14c0:	1c43      	adds	r3, r0, #1
    14c2:	d011      	beq.n	14e8 <vTaskStartScheduler+0x48>
}
    14c4:	b002      	add	sp, #8
    14c6:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    14c8:	4b0c      	ldr	r3, [pc, #48]	; (14fc <vTaskStartScheduler+0x5c>)
    14ca:	4798      	blx	r3
    14cc:	e7f6      	b.n	14bc <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    14ce:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    14d0:	2201      	movs	r2, #1
    14d2:	4252      	negs	r2, r2
    14d4:	4b0a      	ldr	r3, [pc, #40]	; (1500 <vTaskStartScheduler+0x60>)
    14d6:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
    14d8:	4b04      	ldr	r3, [pc, #16]	; (14ec <vTaskStartScheduler+0x4c>)
    14da:	3202      	adds	r2, #2
    14dc:	65da      	str	r2, [r3, #92]	; 0x5c
		xTickCount = ( TickType_t ) 0U;
    14de:	2200      	movs	r2, #0
    14e0:	66da      	str	r2, [r3, #108]	; 0x6c
		if( xPortStartScheduler() != pdFALSE )
    14e2:	4b08      	ldr	r3, [pc, #32]	; (1504 <vTaskStartScheduler+0x64>)
    14e4:	4798      	blx	r3
    14e6:	e7ed      	b.n	14c4 <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    14e8:	b672      	cpsid	i
    14ea:	e7fe      	b.n	14ea <vTaskStartScheduler+0x4a>
    14ec:	2000438c 	.word	0x2000438c
    14f0:	0000218c 	.word	0x0000218c
    14f4:	000013a1 	.word	0x000013a1
    14f8:	00001431 	.word	0x00001431
    14fc:	00001ac5 	.word	0x00001ac5
    1500:	2000430c 	.word	0x2000430c
    1504:	000008ed 	.word	0x000008ed

00001508 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    1508:	4a02      	ldr	r2, [pc, #8]	; (1514 <vTaskSuspendAll+0xc>)
    150a:	6f13      	ldr	r3, [r2, #112]	; 0x70
    150c:	3301      	adds	r3, #1
    150e:	6713      	str	r3, [r2, #112]	; 0x70
}
    1510:	4770      	bx	lr
    1512:	46c0      	nop			; (mov r8, r8)
    1514:	2000438c 	.word	0x2000438c

00001518 <xTaskGetTickCount>:
		xTicks = xTickCount;
    1518:	4b01      	ldr	r3, [pc, #4]	; (1520 <xTaskGetTickCount+0x8>)
    151a:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
}
    151c:	4770      	bx	lr
    151e:	46c0      	nop			; (mov r8, r8)
    1520:	2000438c 	.word	0x2000438c

00001524 <xTaskIncrementTick>:
{
    1524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1526:	4b3c      	ldr	r3, [pc, #240]	; (1618 <xTaskIncrementTick+0xf4>)
    1528:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    152a:	2b00      	cmp	r3, #0
    152c:	d167      	bne.n	15fe <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    152e:	4b3a      	ldr	r3, [pc, #232]	; (1618 <xTaskIncrementTick+0xf4>)
    1530:	6edd      	ldr	r5, [r3, #108]	; 0x6c
    1532:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
    1534:	66dd      	str	r5, [r3, #108]	; 0x6c
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1536:	2d00      	cmp	r5, #0
    1538:	d111      	bne.n	155e <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
    153a:	4b38      	ldr	r3, [pc, #224]	; (161c <xTaskIncrementTick+0xf8>)
    153c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    153e:	681b      	ldr	r3, [r3, #0]
    1540:	2b00      	cmp	r3, #0
    1542:	d001      	beq.n	1548 <xTaskIncrementTick+0x24>
    1544:	b672      	cpsid	i
    1546:	e7fe      	b.n	1546 <xTaskIncrementTick+0x22>
    1548:	4a34      	ldr	r2, [pc, #208]	; (161c <xTaskIncrementTick+0xf8>)
    154a:	6a91      	ldr	r1, [r2, #40]	; 0x28
    154c:	4b32      	ldr	r3, [pc, #200]	; (1618 <xTaskIncrementTick+0xf4>)
    154e:	6d18      	ldr	r0, [r3, #80]	; 0x50
    1550:	6290      	str	r0, [r2, #40]	; 0x28
    1552:	6519      	str	r1, [r3, #80]	; 0x50
    1554:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1556:	3201      	adds	r2, #1
    1558:	679a      	str	r2, [r3, #120]	; 0x78
    155a:	4b31      	ldr	r3, [pc, #196]	; (1620 <xTaskIncrementTick+0xfc>)
    155c:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    155e:	4b2f      	ldr	r3, [pc, #188]	; (161c <xTaskIncrementTick+0xf8>)
    1560:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1562:	429d      	cmp	r5, r3
    1564:	d23f      	bcs.n	15e6 <xTaskIncrementTick+0xc2>
BaseType_t xSwitchRequired = pdFALSE;
    1566:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1568:	4b2b      	ldr	r3, [pc, #172]	; (1618 <xTaskIncrementTick+0xf4>)
    156a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    156c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    156e:	0093      	lsls	r3, r2, #2
    1570:	189b      	adds	r3, r3, r2
    1572:	009a      	lsls	r2, r3, #2
    1574:	4b29      	ldr	r3, [pc, #164]	; (161c <xTaskIncrementTick+0xf8>)
    1576:	189b      	adds	r3, r3, r2
    1578:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    157a:	2b01      	cmp	r3, #1
    157c:	d944      	bls.n	1608 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    157e:	2401      	movs	r4, #1
    1580:	e042      	b.n	1608 <xTaskIncrementTick+0xe4>
							xSwitchRequired = pdTRUE;
    1582:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1584:	4b25      	ldr	r3, [pc, #148]	; (161c <xTaskIncrementTick+0xf8>)
    1586:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1588:	681b      	ldr	r3, [r3, #0]
    158a:	2b00      	cmp	r3, #0
    158c:	d02d      	beq.n	15ea <xTaskIncrementTick+0xc6>
    158e:	2300      	movs	r3, #0
    1590:	2b00      	cmp	r3, #0
    1592:	d12c      	bne.n	15ee <xTaskIncrementTick+0xca>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1594:	4b21      	ldr	r3, [pc, #132]	; (161c <xTaskIncrementTick+0xf8>)
    1596:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1598:	68db      	ldr	r3, [r3, #12]
    159a:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    159c:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
    159e:	429d      	cmp	r5, r3
    15a0:	d32a      	bcc.n	15f8 <xTaskIncrementTick+0xd4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    15a2:	1d37      	adds	r7, r6, #4
    15a4:	0038      	movs	r0, r7
    15a6:	4b1f      	ldr	r3, [pc, #124]	; (1624 <xTaskIncrementTick+0x100>)
    15a8:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    15aa:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    15ac:	2b00      	cmp	r3, #0
    15ae:	d003      	beq.n	15b8 <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    15b0:	0030      	movs	r0, r6
    15b2:	3018      	adds	r0, #24
    15b4:	4b1b      	ldr	r3, [pc, #108]	; (1624 <xTaskIncrementTick+0x100>)
    15b6:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    15b8:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    15ba:	4b17      	ldr	r3, [pc, #92]	; (1618 <xTaskIncrementTick+0xf4>)
    15bc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    15be:	429a      	cmp	r2, r3
    15c0:	d901      	bls.n	15c6 <xTaskIncrementTick+0xa2>
    15c2:	4b15      	ldr	r3, [pc, #84]	; (1618 <xTaskIncrementTick+0xf4>)
    15c4:	665a      	str	r2, [r3, #100]	; 0x64
    15c6:	0093      	lsls	r3, r2, #2
    15c8:	189b      	adds	r3, r3, r2
    15ca:	009a      	lsls	r2, r3, #2
    15cc:	4813      	ldr	r0, [pc, #76]	; (161c <xTaskIncrementTick+0xf8>)
    15ce:	3030      	adds	r0, #48	; 0x30
    15d0:	1880      	adds	r0, r0, r2
    15d2:	0039      	movs	r1, r7
    15d4:	4b14      	ldr	r3, [pc, #80]	; (1628 <xTaskIncrementTick+0x104>)
    15d6:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    15d8:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    15da:	4b0f      	ldr	r3, [pc, #60]	; (1618 <xTaskIncrementTick+0xf4>)
    15dc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    15de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    15e0:	429a      	cmp	r2, r3
    15e2:	d2ce      	bcs.n	1582 <xTaskIncrementTick+0x5e>
    15e4:	e7ce      	b.n	1584 <xTaskIncrementTick+0x60>
    15e6:	2400      	movs	r4, #0
    15e8:	e7cc      	b.n	1584 <xTaskIncrementTick+0x60>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    15ea:	3301      	adds	r3, #1
    15ec:	e7d0      	b.n	1590 <xTaskIncrementTick+0x6c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    15ee:	2201      	movs	r2, #1
    15f0:	4252      	negs	r2, r2
    15f2:	4b0a      	ldr	r3, [pc, #40]	; (161c <xTaskIncrementTick+0xf8>)
    15f4:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
    15f6:	e7b7      	b.n	1568 <xTaskIncrementTick+0x44>
						xNextTaskUnblockTime = xItemValue;
    15f8:	4a08      	ldr	r2, [pc, #32]	; (161c <xTaskIncrementTick+0xf8>)
    15fa:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    15fc:	e7b4      	b.n	1568 <xTaskIncrementTick+0x44>
		++uxPendedTicks;
    15fe:	4a06      	ldr	r2, [pc, #24]	; (1618 <xTaskIncrementTick+0xf4>)
    1600:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    1602:	3301      	adds	r3, #1
    1604:	67d3      	str	r3, [r2, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    1606:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    1608:	4b08      	ldr	r3, [pc, #32]	; (162c <xTaskIncrementTick+0x108>)
    160a:	681b      	ldr	r3, [r3, #0]
    160c:	2b00      	cmp	r3, #0
    160e:	d000      	beq.n	1612 <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    1610:	2401      	movs	r4, #1
}
    1612:	0020      	movs	r0, r4
    1614:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1616:	46c0      	nop			; (mov r8, r8)
    1618:	2000438c 	.word	0x2000438c
    161c:	2000430c 	.word	0x2000430c
    1620:	0000116d 	.word	0x0000116d
    1624:	00000375 	.word	0x00000375
    1628:	0000032d 	.word	0x0000032d
    162c:	2000440c 	.word	0x2000440c

00001630 <xTaskResumeAll>:
{
    1630:	b570      	push	{r4, r5, r6, lr}
	configASSERT( uxSchedulerSuspended );
    1632:	4b32      	ldr	r3, [pc, #200]	; (16fc <xTaskResumeAll+0xcc>)
    1634:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1636:	2b00      	cmp	r3, #0
    1638:	d101      	bne.n	163e <xTaskResumeAll+0xe>
    163a:	b672      	cpsid	i
    163c:	e7fe      	b.n	163c <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
    163e:	4b30      	ldr	r3, [pc, #192]	; (1700 <xTaskResumeAll+0xd0>)
    1640:	4798      	blx	r3
		--uxSchedulerSuspended;
    1642:	4b2e      	ldr	r3, [pc, #184]	; (16fc <xTaskResumeAll+0xcc>)
    1644:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    1646:	3a01      	subs	r2, #1
    1648:	671a      	str	r2, [r3, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    164a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    164c:	2b00      	cmp	r3, #0
    164e:	d150      	bne.n	16f2 <xTaskResumeAll+0xc2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1650:	4b2a      	ldr	r3, [pc, #168]	; (16fc <xTaskResumeAll+0xcc>)
    1652:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    1654:	2b00      	cmp	r3, #0
    1656:	d104      	bne.n	1662 <xTaskResumeAll+0x32>
BaseType_t xAlreadyYielded = pdFALSE;
    1658:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    165a:	4b2a      	ldr	r3, [pc, #168]	; (1704 <xTaskResumeAll+0xd4>)
    165c:	4798      	blx	r3
}
    165e:	0020      	movs	r0, r4
    1660:	bd70      	pop	{r4, r5, r6, pc}
    1662:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1664:	4b28      	ldr	r3, [pc, #160]	; (1708 <xTaskResumeAll+0xd8>)
    1666:	695b      	ldr	r3, [r3, #20]
    1668:	2b00      	cmp	r3, #0
    166a:	d023      	beq.n	16b4 <xTaskResumeAll+0x84>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    166c:	4b26      	ldr	r3, [pc, #152]	; (1708 <xTaskResumeAll+0xd8>)
    166e:	6a1b      	ldr	r3, [r3, #32]
    1670:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1672:	0020      	movs	r0, r4
    1674:	3018      	adds	r0, #24
    1676:	4e25      	ldr	r6, [pc, #148]	; (170c <xTaskResumeAll+0xdc>)
    1678:	47b0      	blx	r6
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    167a:	1d25      	adds	r5, r4, #4
    167c:	0028      	movs	r0, r5
    167e:	47b0      	blx	r6
					prvAddTaskToReadyList( pxTCB );
    1680:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1682:	4b1e      	ldr	r3, [pc, #120]	; (16fc <xTaskResumeAll+0xcc>)
    1684:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    1686:	429a      	cmp	r2, r3
    1688:	d901      	bls.n	168e <xTaskResumeAll+0x5e>
    168a:	4b1c      	ldr	r3, [pc, #112]	; (16fc <xTaskResumeAll+0xcc>)
    168c:	665a      	str	r2, [r3, #100]	; 0x64
    168e:	0093      	lsls	r3, r2, #2
    1690:	189b      	adds	r3, r3, r2
    1692:	009a      	lsls	r2, r3, #2
    1694:	481c      	ldr	r0, [pc, #112]	; (1708 <xTaskResumeAll+0xd8>)
    1696:	3030      	adds	r0, #48	; 0x30
    1698:	1880      	adds	r0, r0, r2
    169a:	0029      	movs	r1, r5
    169c:	4b1c      	ldr	r3, [pc, #112]	; (1710 <xTaskResumeAll+0xe0>)
    169e:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    16a0:	4b16      	ldr	r3, [pc, #88]	; (16fc <xTaskResumeAll+0xcc>)
    16a2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    16a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16a6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    16a8:	429a      	cmp	r2, r3
    16aa:	d3db      	bcc.n	1664 <xTaskResumeAll+0x34>
						xYieldPending = pdTRUE;
    16ac:	2201      	movs	r2, #1
    16ae:	4b19      	ldr	r3, [pc, #100]	; (1714 <xTaskResumeAll+0xe4>)
    16b0:	601a      	str	r2, [r3, #0]
    16b2:	e7d7      	b.n	1664 <xTaskResumeAll+0x34>
				if( pxTCB != NULL )
    16b4:	2c00      	cmp	r4, #0
    16b6:	d001      	beq.n	16bc <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
    16b8:	4b17      	ldr	r3, [pc, #92]	; (1718 <xTaskResumeAll+0xe8>)
    16ba:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    16bc:	4b0f      	ldr	r3, [pc, #60]	; (16fc <xTaskResumeAll+0xcc>)
    16be:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    16c0:	2c00      	cmp	r4, #0
    16c2:	d10a      	bne.n	16da <xTaskResumeAll+0xaa>
				if( xYieldPending != pdFALSE )
    16c4:	4b13      	ldr	r3, [pc, #76]	; (1714 <xTaskResumeAll+0xe4>)
    16c6:	681b      	ldr	r3, [r3, #0]
    16c8:	2b00      	cmp	r3, #0
    16ca:	d014      	beq.n	16f6 <xTaskResumeAll+0xc6>
					taskYIELD_IF_USING_PREEMPTION();
    16cc:	4b13      	ldr	r3, [pc, #76]	; (171c <xTaskResumeAll+0xec>)
    16ce:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    16d0:	2401      	movs	r4, #1
    16d2:	e7c2      	b.n	165a <xTaskResumeAll+0x2a>
							--uxPendedCounts;
    16d4:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    16d6:	2c00      	cmp	r4, #0
    16d8:	d007      	beq.n	16ea <xTaskResumeAll+0xba>
							if( xTaskIncrementTick() != pdFALSE )
    16da:	4b11      	ldr	r3, [pc, #68]	; (1720 <xTaskResumeAll+0xf0>)
    16dc:	4798      	blx	r3
    16de:	2800      	cmp	r0, #0
    16e0:	d0f8      	beq.n	16d4 <xTaskResumeAll+0xa4>
								xYieldPending = pdTRUE;
    16e2:	2201      	movs	r2, #1
    16e4:	4b0b      	ldr	r3, [pc, #44]	; (1714 <xTaskResumeAll+0xe4>)
    16e6:	601a      	str	r2, [r3, #0]
    16e8:	e7f4      	b.n	16d4 <xTaskResumeAll+0xa4>
						uxPendedTicks = 0;
    16ea:	2200      	movs	r2, #0
    16ec:	4b03      	ldr	r3, [pc, #12]	; (16fc <xTaskResumeAll+0xcc>)
    16ee:	67da      	str	r2, [r3, #124]	; 0x7c
    16f0:	e7e8      	b.n	16c4 <xTaskResumeAll+0x94>
BaseType_t xAlreadyYielded = pdFALSE;
    16f2:	2400      	movs	r4, #0
    16f4:	e7b1      	b.n	165a <xTaskResumeAll+0x2a>
    16f6:	2400      	movs	r4, #0
    16f8:	e7af      	b.n	165a <xTaskResumeAll+0x2a>
    16fa:	46c0      	nop			; (mov r8, r8)
    16fc:	2000438c 	.word	0x2000438c
    1700:	00000951 	.word	0x00000951
    1704:	00000969 	.word	0x00000969
    1708:	2000430c 	.word	0x2000430c
    170c:	00000375 	.word	0x00000375
    1710:	0000032d 	.word	0x0000032d
    1714:	2000440c 	.word	0x2000440c
    1718:	0000116d 	.word	0x0000116d
    171c:	00000939 	.word	0x00000939
    1720:	00001525 	.word	0x00001525

00001724 <vTaskDelay>:
	{
    1724:	b510      	push	{r4, lr}
    1726:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
    1728:	d00e      	beq.n	1748 <vTaskDelay+0x24>
			configASSERT( uxSchedulerSuspended == 0 );
    172a:	4b0a      	ldr	r3, [pc, #40]	; (1754 <vTaskDelay+0x30>)
    172c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    172e:	2b00      	cmp	r3, #0
    1730:	d001      	beq.n	1736 <vTaskDelay+0x12>
    1732:	b672      	cpsid	i
    1734:	e7fe      	b.n	1734 <vTaskDelay+0x10>
			vTaskSuspendAll();
    1736:	4b08      	ldr	r3, [pc, #32]	; (1758 <vTaskDelay+0x34>)
    1738:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    173a:	2100      	movs	r1, #0
    173c:	0020      	movs	r0, r4
    173e:	4b07      	ldr	r3, [pc, #28]	; (175c <vTaskDelay+0x38>)
    1740:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
    1742:	4b07      	ldr	r3, [pc, #28]	; (1760 <vTaskDelay+0x3c>)
    1744:	4798      	blx	r3
    1746:	e000      	b.n	174a <vTaskDelay+0x26>
	BaseType_t xAlreadyYielded = pdFALSE;
    1748:	2000      	movs	r0, #0
		if( xAlreadyYielded == pdFALSE )
    174a:	2800      	cmp	r0, #0
    174c:	d101      	bne.n	1752 <vTaskDelay+0x2e>
			portYIELD_WITHIN_API();
    174e:	4b05      	ldr	r3, [pc, #20]	; (1764 <vTaskDelay+0x40>)
    1750:	4798      	blx	r3
	}
    1752:	bd10      	pop	{r4, pc}
    1754:	2000438c 	.word	0x2000438c
    1758:	00001509 	.word	0x00001509
    175c:	000013c1 	.word	0x000013c1
    1760:	00001631 	.word	0x00001631
    1764:	00000939 	.word	0x00000939

00001768 <vTaskSwitchContext>:
{
    1768:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    176a:	4b1d      	ldr	r3, [pc, #116]	; (17e0 <vTaskSwitchContext+0x78>)
    176c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    176e:	2b00      	cmp	r3, #0
    1770:	d110      	bne.n	1794 <vTaskSwitchContext+0x2c>
		xYieldPending = pdFALSE;
    1772:	2200      	movs	r2, #0
    1774:	4b1b      	ldr	r3, [pc, #108]	; (17e4 <vTaskSwitchContext+0x7c>)
    1776:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1778:	4b19      	ldr	r3, [pc, #100]	; (17e0 <vTaskSwitchContext+0x78>)
    177a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    177c:	009a      	lsls	r2, r3, #2
    177e:	18d2      	adds	r2, r2, r3
    1780:	0091      	lsls	r1, r2, #2
    1782:	4a19      	ldr	r2, [pc, #100]	; (17e8 <vTaskSwitchContext+0x80>)
    1784:	1852      	adds	r2, r2, r1
    1786:	6b12      	ldr	r2, [r2, #48]	; 0x30
    1788:	2a00      	cmp	r2, #0
    178a:	d109      	bne.n	17a0 <vTaskSwitchContext+0x38>
    178c:	2b00      	cmp	r3, #0
    178e:	d005      	beq.n	179c <vTaskSwitchContext+0x34>
    1790:	3b01      	subs	r3, #1
    1792:	e7f3      	b.n	177c <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
    1794:	2201      	movs	r2, #1
    1796:	4b13      	ldr	r3, [pc, #76]	; (17e4 <vTaskSwitchContext+0x7c>)
    1798:	601a      	str	r2, [r3, #0]
}
    179a:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    179c:	b672      	cpsid	i
    179e:	e7fe      	b.n	179e <vTaskSwitchContext+0x36>
    17a0:	4a11      	ldr	r2, [pc, #68]	; (17e8 <vTaskSwitchContext+0x80>)
    17a2:	0099      	lsls	r1, r3, #2
    17a4:	18cc      	adds	r4, r1, r3
    17a6:	00a0      	lsls	r0, r4, #2
    17a8:	1810      	adds	r0, r2, r0
    17aa:	6b44      	ldr	r4, [r0, #52]	; 0x34
    17ac:	6864      	ldr	r4, [r4, #4]
    17ae:	6344      	str	r4, [r0, #52]	; 0x34
    17b0:	3230      	adds	r2, #48	; 0x30
    17b2:	18c9      	adds	r1, r1, r3
    17b4:	0088      	lsls	r0, r1, #2
    17b6:	3008      	adds	r0, #8
    17b8:	1812      	adds	r2, r2, r0
    17ba:	4294      	cmp	r4, r2
    17bc:	d00a      	beq.n	17d4 <vTaskSwitchContext+0x6c>
    17be:	009a      	lsls	r2, r3, #2
    17c0:	18d2      	adds	r2, r2, r3
    17c2:	0091      	lsls	r1, r2, #2
    17c4:	4a08      	ldr	r2, [pc, #32]	; (17e8 <vTaskSwitchContext+0x80>)
    17c6:	1852      	adds	r2, r2, r1
    17c8:	6b52      	ldr	r2, [r2, #52]	; 0x34
    17ca:	68d1      	ldr	r1, [r2, #12]
    17cc:	4a04      	ldr	r2, [pc, #16]	; (17e0 <vTaskSwitchContext+0x78>)
    17ce:	6591      	str	r1, [r2, #88]	; 0x58
    17d0:	6653      	str	r3, [r2, #100]	; 0x64
}
    17d2:	e7e2      	b.n	179a <vTaskSwitchContext+0x32>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    17d4:	6860      	ldr	r0, [r4, #4]
    17d6:	0089      	lsls	r1, r1, #2
    17d8:	4a03      	ldr	r2, [pc, #12]	; (17e8 <vTaskSwitchContext+0x80>)
    17da:	1852      	adds	r2, r2, r1
    17dc:	6350      	str	r0, [r2, #52]	; 0x34
    17de:	e7ee      	b.n	17be <vTaskSwitchContext+0x56>
    17e0:	2000438c 	.word	0x2000438c
    17e4:	2000440c 	.word	0x2000440c
    17e8:	2000430c 	.word	0x2000430c

000017ec <vTaskPlaceOnEventList>:
{
    17ec:	b510      	push	{r4, lr}
    17ee:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    17f0:	2800      	cmp	r0, #0
    17f2:	d101      	bne.n	17f8 <vTaskPlaceOnEventList+0xc>
    17f4:	b672      	cpsid	i
    17f6:	e7fe      	b.n	17f6 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    17f8:	4b04      	ldr	r3, [pc, #16]	; (180c <vTaskPlaceOnEventList+0x20>)
    17fa:	6d99      	ldr	r1, [r3, #88]	; 0x58
    17fc:	3118      	adds	r1, #24
    17fe:	4b04      	ldr	r3, [pc, #16]	; (1810 <vTaskPlaceOnEventList+0x24>)
    1800:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1802:	2101      	movs	r1, #1
    1804:	0020      	movs	r0, r4
    1806:	4b03      	ldr	r3, [pc, #12]	; (1814 <vTaskPlaceOnEventList+0x28>)
    1808:	4798      	blx	r3
}
    180a:	bd10      	pop	{r4, pc}
    180c:	2000438c 	.word	0x2000438c
    1810:	00000345 	.word	0x00000345
    1814:	000013c1 	.word	0x000013c1

00001818 <vTaskPlaceOnEventListRestricted>:
	{
    1818:	b570      	push	{r4, r5, r6, lr}
    181a:	000c      	movs	r4, r1
    181c:	0015      	movs	r5, r2
		configASSERT( pxEventList );
    181e:	2800      	cmp	r0, #0
    1820:	d00d      	beq.n	183e <vTaskPlaceOnEventListRestricted+0x26>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1822:	4b08      	ldr	r3, [pc, #32]	; (1844 <vTaskPlaceOnEventListRestricted+0x2c>)
    1824:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1826:	3118      	adds	r1, #24
    1828:	4b07      	ldr	r3, [pc, #28]	; (1848 <vTaskPlaceOnEventListRestricted+0x30>)
    182a:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
    182c:	2d00      	cmp	r5, #0
    182e:	d001      	beq.n	1834 <vTaskPlaceOnEventListRestricted+0x1c>
			xTicksToWait = portMAX_DELAY;
    1830:	2401      	movs	r4, #1
    1832:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    1834:	0029      	movs	r1, r5
    1836:	0020      	movs	r0, r4
    1838:	4b04      	ldr	r3, [pc, #16]	; (184c <vTaskPlaceOnEventListRestricted+0x34>)
    183a:	4798      	blx	r3
	}
    183c:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxEventList );
    183e:	b672      	cpsid	i
    1840:	e7fe      	b.n	1840 <vTaskPlaceOnEventListRestricted+0x28>
    1842:	46c0      	nop			; (mov r8, r8)
    1844:	2000438c 	.word	0x2000438c
    1848:	0000032d 	.word	0x0000032d
    184c:	000013c1 	.word	0x000013c1

00001850 <xTaskRemoveFromEventList>:
{
    1850:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1852:	68c3      	ldr	r3, [r0, #12]
    1854:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    1856:	2c00      	cmp	r4, #0
    1858:	d027      	beq.n	18aa <xTaskRemoveFromEventList+0x5a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    185a:	0025      	movs	r5, r4
    185c:	3518      	adds	r5, #24
    185e:	0028      	movs	r0, r5
    1860:	4b17      	ldr	r3, [pc, #92]	; (18c0 <xTaskRemoveFromEventList+0x70>)
    1862:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1864:	4b17      	ldr	r3, [pc, #92]	; (18c4 <xTaskRemoveFromEventList+0x74>)
    1866:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1868:	2b00      	cmp	r3, #0
    186a:	d120      	bne.n	18ae <xTaskRemoveFromEventList+0x5e>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    186c:	1d25      	adds	r5, r4, #4
    186e:	0028      	movs	r0, r5
    1870:	4b13      	ldr	r3, [pc, #76]	; (18c0 <xTaskRemoveFromEventList+0x70>)
    1872:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    1874:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1876:	4b13      	ldr	r3, [pc, #76]	; (18c4 <xTaskRemoveFromEventList+0x74>)
    1878:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    187a:	429a      	cmp	r2, r3
    187c:	d901      	bls.n	1882 <xTaskRemoveFromEventList+0x32>
    187e:	4b11      	ldr	r3, [pc, #68]	; (18c4 <xTaskRemoveFromEventList+0x74>)
    1880:	665a      	str	r2, [r3, #100]	; 0x64
    1882:	0093      	lsls	r3, r2, #2
    1884:	189b      	adds	r3, r3, r2
    1886:	009a      	lsls	r2, r3, #2
    1888:	480f      	ldr	r0, [pc, #60]	; (18c8 <xTaskRemoveFromEventList+0x78>)
    188a:	3030      	adds	r0, #48	; 0x30
    188c:	1880      	adds	r0, r0, r2
    188e:	0029      	movs	r1, r5
    1890:	4b0e      	ldr	r3, [pc, #56]	; (18cc <xTaskRemoveFromEventList+0x7c>)
    1892:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1894:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1896:	4b0b      	ldr	r3, [pc, #44]	; (18c4 <xTaskRemoveFromEventList+0x74>)
    1898:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    189a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    189c:	429a      	cmp	r2, r3
    189e:	d90c      	bls.n	18ba <xTaskRemoveFromEventList+0x6a>
		xYieldPending = pdTRUE;
    18a0:	2201      	movs	r2, #1
    18a2:	4b0b      	ldr	r3, [pc, #44]	; (18d0 <xTaskRemoveFromEventList+0x80>)
    18a4:	601a      	str	r2, [r3, #0]
		xReturn = pdTRUE;
    18a6:	2001      	movs	r0, #1
}
    18a8:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxUnblockedTCB );
    18aa:	b672      	cpsid	i
    18ac:	e7fe      	b.n	18ac <xTaskRemoveFromEventList+0x5c>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    18ae:	0029      	movs	r1, r5
    18b0:	4805      	ldr	r0, [pc, #20]	; (18c8 <xTaskRemoveFromEventList+0x78>)
    18b2:	3014      	adds	r0, #20
    18b4:	4b05      	ldr	r3, [pc, #20]	; (18cc <xTaskRemoveFromEventList+0x7c>)
    18b6:	4798      	blx	r3
    18b8:	e7ec      	b.n	1894 <xTaskRemoveFromEventList+0x44>
		xReturn = pdFALSE;
    18ba:	2000      	movs	r0, #0
	return xReturn;
    18bc:	e7f4      	b.n	18a8 <xTaskRemoveFromEventList+0x58>
    18be:	46c0      	nop			; (mov r8, r8)
    18c0:	00000375 	.word	0x00000375
    18c4:	2000438c 	.word	0x2000438c
    18c8:	2000430c 	.word	0x2000430c
    18cc:	0000032d 	.word	0x0000032d
    18d0:	2000440c 	.word	0x2000440c

000018d4 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    18d4:	4b02      	ldr	r3, [pc, #8]	; (18e0 <vTaskInternalSetTimeOutState+0xc>)
    18d6:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    18d8:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    18da:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    18dc:	6043      	str	r3, [r0, #4]
}
    18de:	4770      	bx	lr
    18e0:	2000438c 	.word	0x2000438c

000018e4 <xTaskCheckForTimeOut>:
{
    18e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    18e6:	0005      	movs	r5, r0
    18e8:	000c      	movs	r4, r1
	configASSERT( pxTimeOut );
    18ea:	2800      	cmp	r0, #0
    18ec:	d01a      	beq.n	1924 <xTaskCheckForTimeOut+0x40>
	configASSERT( pxTicksToWait );
    18ee:	2900      	cmp	r1, #0
    18f0:	d01a      	beq.n	1928 <xTaskCheckForTimeOut+0x44>
	taskENTER_CRITICAL();
    18f2:	4b14      	ldr	r3, [pc, #80]	; (1944 <xTaskCheckForTimeOut+0x60>)
    18f4:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    18f6:	4b14      	ldr	r3, [pc, #80]	; (1948 <xTaskCheckForTimeOut+0x64>)
    18f8:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    18fa:	6869      	ldr	r1, [r5, #4]
    18fc:	1a42      	subs	r2, r0, r1
			if( *pxTicksToWait == portMAX_DELAY )
    18fe:	6823      	ldr	r3, [r4, #0]
    1900:	1c5e      	adds	r6, r3, #1
    1902:	d01a      	beq.n	193a <xTaskCheckForTimeOut+0x56>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1904:	4e10      	ldr	r6, [pc, #64]	; (1948 <xTaskCheckForTimeOut+0x64>)
    1906:	6fb6      	ldr	r6, [r6, #120]	; 0x78
    1908:	682f      	ldr	r7, [r5, #0]
    190a:	42b7      	cmp	r7, r6
    190c:	d001      	beq.n	1912 <xTaskCheckForTimeOut+0x2e>
    190e:	4288      	cmp	r0, r1
    1910:	d215      	bcs.n	193e <xTaskCheckForTimeOut+0x5a>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1912:	429a      	cmp	r2, r3
    1914:	d30a      	bcc.n	192c <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait = 0;
    1916:	2300      	movs	r3, #0
    1918:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
    191a:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    191c:	4b0b      	ldr	r3, [pc, #44]	; (194c <xTaskCheckForTimeOut+0x68>)
    191e:	4798      	blx	r3
}
    1920:	0020      	movs	r0, r4
    1922:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	configASSERT( pxTimeOut );
    1924:	b672      	cpsid	i
    1926:	e7fe      	b.n	1926 <xTaskCheckForTimeOut+0x42>
	configASSERT( pxTicksToWait );
    1928:	b672      	cpsid	i
    192a:	e7fe      	b.n	192a <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= xElapsedTime;
    192c:	1a9b      	subs	r3, r3, r2
    192e:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    1930:	0028      	movs	r0, r5
    1932:	4b07      	ldr	r3, [pc, #28]	; (1950 <xTaskCheckForTimeOut+0x6c>)
    1934:	4798      	blx	r3
			xReturn = pdFALSE;
    1936:	2400      	movs	r4, #0
    1938:	e7f0      	b.n	191c <xTaskCheckForTimeOut+0x38>
				xReturn = pdFALSE;
    193a:	2400      	movs	r4, #0
    193c:	e7ee      	b.n	191c <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
    193e:	2401      	movs	r4, #1
    1940:	e7ec      	b.n	191c <xTaskCheckForTimeOut+0x38>
    1942:	46c0      	nop			; (mov r8, r8)
    1944:	00000951 	.word	0x00000951
    1948:	2000438c 	.word	0x2000438c
    194c:	00000969 	.word	0x00000969
    1950:	000018d5 	.word	0x000018d5

00001954 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    1954:	2201      	movs	r2, #1
    1956:	4b01      	ldr	r3, [pc, #4]	; (195c <vTaskMissedYield+0x8>)
    1958:	601a      	str	r2, [r3, #0]
}
    195a:	4770      	bx	lr
    195c:	2000440c 	.word	0x2000440c

00001960 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    1960:	4b06      	ldr	r3, [pc, #24]	; (197c <xTaskGetSchedulerState+0x1c>)
    1962:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1964:	2b00      	cmp	r3, #0
    1966:	d005      	beq.n	1974 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1968:	4b04      	ldr	r3, [pc, #16]	; (197c <xTaskGetSchedulerState+0x1c>)
    196a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    196c:	2b00      	cmp	r3, #0
    196e:	d103      	bne.n	1978 <xTaskGetSchedulerState+0x18>
				xReturn = taskSCHEDULER_RUNNING;
    1970:	2002      	movs	r0, #2
	}
    1972:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
    1974:	2001      	movs	r0, #1
    1976:	e7fc      	b.n	1972 <xTaskGetSchedulerState+0x12>
				xReturn = taskSCHEDULER_SUSPENDED;
    1978:	2000      	movs	r0, #0
		return xReturn;
    197a:	e7fa      	b.n	1972 <xTaskGetSchedulerState+0x12>
    197c:	2000438c 	.word	0x2000438c

00001980 <xTaskPriorityDisinherit>:
	{
    1980:	b570      	push	{r4, r5, r6, lr}
    1982:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    1984:	d02c      	beq.n	19e0 <xTaskPriorityDisinherit+0x60>
			configASSERT( pxTCB == pxCurrentTCB );
    1986:	4b19      	ldr	r3, [pc, #100]	; (19ec <xTaskPriorityDisinherit+0x6c>)
    1988:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    198a:	4298      	cmp	r0, r3
    198c:	d001      	beq.n	1992 <xTaskPriorityDisinherit+0x12>
    198e:	b672      	cpsid	i
    1990:	e7fe      	b.n	1990 <xTaskPriorityDisinherit+0x10>
			configASSERT( pxTCB->uxMutexesHeld );
    1992:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1994:	2b00      	cmp	r3, #0
    1996:	d101      	bne.n	199c <xTaskPriorityDisinherit+0x1c>
    1998:	b672      	cpsid	i
    199a:	e7fe      	b.n	199a <xTaskPriorityDisinherit+0x1a>
			( pxTCB->uxMutexesHeld )--;
    199c:	3b01      	subs	r3, #1
    199e:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    19a0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    19a2:	6c41      	ldr	r1, [r0, #68]	; 0x44
    19a4:	428a      	cmp	r2, r1
    19a6:	d01d      	beq.n	19e4 <xTaskPriorityDisinherit+0x64>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    19a8:	2b00      	cmp	r3, #0
    19aa:	d11d      	bne.n	19e8 <xTaskPriorityDisinherit+0x68>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    19ac:	1d05      	adds	r5, r0, #4
    19ae:	0028      	movs	r0, r5
    19b0:	4b0f      	ldr	r3, [pc, #60]	; (19f0 <xTaskPriorityDisinherit+0x70>)
    19b2:	4798      	blx	r3
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    19b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
    19b6:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    19b8:	2205      	movs	r2, #5
    19ba:	1ad2      	subs	r2, r2, r3
    19bc:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
    19be:	4a0b      	ldr	r2, [pc, #44]	; (19ec <xTaskPriorityDisinherit+0x6c>)
    19c0:	6e52      	ldr	r2, [r2, #100]	; 0x64
    19c2:	4293      	cmp	r3, r2
    19c4:	d901      	bls.n	19ca <xTaskPriorityDisinherit+0x4a>
    19c6:	4a09      	ldr	r2, [pc, #36]	; (19ec <xTaskPriorityDisinherit+0x6c>)
    19c8:	6653      	str	r3, [r2, #100]	; 0x64
    19ca:	009a      	lsls	r2, r3, #2
    19cc:	18d3      	adds	r3, r2, r3
    19ce:	009a      	lsls	r2, r3, #2
    19d0:	4808      	ldr	r0, [pc, #32]	; (19f4 <xTaskPriorityDisinherit+0x74>)
    19d2:	3030      	adds	r0, #48	; 0x30
    19d4:	1880      	adds	r0, r0, r2
    19d6:	0029      	movs	r1, r5
    19d8:	4b07      	ldr	r3, [pc, #28]	; (19f8 <xTaskPriorityDisinherit+0x78>)
    19da:	4798      	blx	r3
					xReturn = pdTRUE;
    19dc:	2001      	movs	r0, #1
	}
    19de:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xReturn = pdFALSE;
    19e0:	2000      	movs	r0, #0
    19e2:	e7fc      	b.n	19de <xTaskPriorityDisinherit+0x5e>
    19e4:	2000      	movs	r0, #0
    19e6:	e7fa      	b.n	19de <xTaskPriorityDisinherit+0x5e>
    19e8:	2000      	movs	r0, #0
		return xReturn;
    19ea:	e7f8      	b.n	19de <xTaskPriorityDisinherit+0x5e>
    19ec:	2000438c 	.word	0x2000438c
    19f0:	00000375 	.word	0x00000375
    19f4:	2000430c 	.word	0x2000430c
    19f8:	0000032d 	.word	0x0000032d

000019fc <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    19fc:	4b06      	ldr	r3, [pc, #24]	; (1a18 <prvGetNextExpireTime+0x1c>)
    19fe:	681a      	ldr	r2, [r3, #0]
    1a00:	6813      	ldr	r3, [r2, #0]
    1a02:	4259      	negs	r1, r3
    1a04:	414b      	adcs	r3, r1
    1a06:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
    1a08:	2b00      	cmp	r3, #0
    1a0a:	d102      	bne.n	1a12 <prvGetNextExpireTime+0x16>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a0c:	68d3      	ldr	r3, [r2, #12]
    1a0e:	6818      	ldr	r0, [r3, #0]
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
	}

	return xNextExpireTime;
}
    1a10:	4770      	bx	lr
		xNextExpireTime = ( TickType_t ) 0U;
    1a12:	2000      	movs	r0, #0
	return xNextExpireTime;
    1a14:	e7fc      	b.n	1a10 <prvGetNextExpireTime+0x14>
    1a16:	46c0      	nop			; (mov r8, r8)
    1a18:	20004410 	.word	0x20004410

00001a1c <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    1a1c:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    1a1e:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1a20:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    1a22:	4291      	cmp	r1, r2
    1a24:	d80c      	bhi.n	1a40 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a26:	1ad2      	subs	r2, r2, r3
    1a28:	6983      	ldr	r3, [r0, #24]
    1a2a:	429a      	cmp	r2, r3
    1a2c:	d301      	bcc.n	1a32 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1a2e:	2001      	movs	r0, #1
    1a30:	e010      	b.n	1a54 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1a32:	1d01      	adds	r1, r0, #4
    1a34:	4b09      	ldr	r3, [pc, #36]	; (1a5c <prvInsertTimerInActiveList+0x40>)
    1a36:	6858      	ldr	r0, [r3, #4]
    1a38:	4b09      	ldr	r3, [pc, #36]	; (1a60 <prvInsertTimerInActiveList+0x44>)
    1a3a:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1a3c:	2000      	movs	r0, #0
    1a3e:	e009      	b.n	1a54 <prvInsertTimerInActiveList+0x38>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1a40:	429a      	cmp	r2, r3
    1a42:	d201      	bcs.n	1a48 <prvInsertTimerInActiveList+0x2c>
    1a44:	4299      	cmp	r1, r3
    1a46:	d206      	bcs.n	1a56 <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1a48:	1d01      	adds	r1, r0, #4
    1a4a:	4b04      	ldr	r3, [pc, #16]	; (1a5c <prvInsertTimerInActiveList+0x40>)
    1a4c:	6818      	ldr	r0, [r3, #0]
    1a4e:	4b04      	ldr	r3, [pc, #16]	; (1a60 <prvInsertTimerInActiveList+0x44>)
    1a50:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1a52:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    1a54:	bd10      	pop	{r4, pc}
			xProcessTimerNow = pdTRUE;
    1a56:	2001      	movs	r0, #1
	return xProcessTimerNow;
    1a58:	e7fc      	b.n	1a54 <prvInsertTimerInActiveList+0x38>
    1a5a:	46c0      	nop			; (mov r8, r8)
    1a5c:	20004410 	.word	0x20004410
    1a60:	00000345 	.word	0x00000345

00001a64 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    1a64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    1a66:	4b10      	ldr	r3, [pc, #64]	; (1aa8 <prvCheckForValidListAndQueue+0x44>)
    1a68:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    1a6a:	4b10      	ldr	r3, [pc, #64]	; (1aac <prvCheckForValidListAndQueue+0x48>)
    1a6c:	689b      	ldr	r3, [r3, #8]
    1a6e:	2b00      	cmp	r3, #0
    1a70:	d002      	beq.n	1a78 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1a72:	4b0f      	ldr	r3, [pc, #60]	; (1ab0 <prvCheckForValidListAndQueue+0x4c>)
    1a74:	4798      	blx	r3
}
    1a76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    1a78:	4c0c      	ldr	r4, [pc, #48]	; (1aac <prvCheckForValidListAndQueue+0x48>)
    1a7a:	0026      	movs	r6, r4
    1a7c:	360c      	adds	r6, #12
    1a7e:	0030      	movs	r0, r6
    1a80:	4f0c      	ldr	r7, [pc, #48]	; (1ab4 <prvCheckForValidListAndQueue+0x50>)
    1a82:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    1a84:	0025      	movs	r5, r4
    1a86:	3520      	adds	r5, #32
    1a88:	0028      	movs	r0, r5
    1a8a:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
    1a8c:	6026      	str	r6, [r4, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    1a8e:	6065      	str	r5, [r4, #4]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1a90:	2200      	movs	r2, #0
    1a92:	210c      	movs	r1, #12
    1a94:	2005      	movs	r0, #5
    1a96:	4b08      	ldr	r3, [pc, #32]	; (1ab8 <prvCheckForValidListAndQueue+0x54>)
    1a98:	4798      	blx	r3
    1a9a:	60a0      	str	r0, [r4, #8]
				if( xTimerQueue != NULL )
    1a9c:	2800      	cmp	r0, #0
    1a9e:	d0e8      	beq.n	1a72 <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    1aa0:	4906      	ldr	r1, [pc, #24]	; (1abc <prvCheckForValidListAndQueue+0x58>)
    1aa2:	4b07      	ldr	r3, [pc, #28]	; (1ac0 <prvCheckForValidListAndQueue+0x5c>)
    1aa4:	4798      	blx	r3
    1aa6:	e7e4      	b.n	1a72 <prvCheckForValidListAndQueue+0xe>
    1aa8:	00000951 	.word	0x00000951
    1aac:	20004410 	.word	0x20004410
    1ab0:	00000969 	.word	0x00000969
    1ab4:	00000311 	.word	0x00000311
    1ab8:	00000cc9 	.word	0x00000cc9
    1abc:	000021cc 	.word	0x000021cc
    1ac0:	000010e9 	.word	0x000010e9

00001ac4 <xTimerCreateTimerTask>:
{
    1ac4:	b510      	push	{r4, lr}
    1ac6:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    1ac8:	4b0c      	ldr	r3, [pc, #48]	; (1afc <xTimerCreateTimerTask+0x38>)
    1aca:	4798      	blx	r3
	if( xTimerQueue != NULL )
    1acc:	4b0c      	ldr	r3, [pc, #48]	; (1b00 <xTimerCreateTimerTask+0x3c>)
    1ace:	689b      	ldr	r3, [r3, #8]
    1ad0:	2b00      	cmp	r3, #0
    1ad2:	d00e      	beq.n	1af2 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    1ad4:	4b0a      	ldr	r3, [pc, #40]	; (1b00 <xTimerCreateTimerTask+0x3c>)
    1ad6:	3334      	adds	r3, #52	; 0x34
    1ad8:	9301      	str	r3, [sp, #4]
    1ada:	2302      	movs	r3, #2
    1adc:	9300      	str	r3, [sp, #0]
    1ade:	2300      	movs	r3, #0
    1ae0:	2250      	movs	r2, #80	; 0x50
    1ae2:	4908      	ldr	r1, [pc, #32]	; (1b04 <xTimerCreateTimerTask+0x40>)
    1ae4:	4808      	ldr	r0, [pc, #32]	; (1b08 <xTimerCreateTimerTask+0x44>)
    1ae6:	4c09      	ldr	r4, [pc, #36]	; (1b0c <xTimerCreateTimerTask+0x48>)
    1ae8:	47a0      	blx	r4
	configASSERT( xReturn );
    1aea:	2800      	cmp	r0, #0
    1aec:	d103      	bne.n	1af6 <xTimerCreateTimerTask+0x32>
    1aee:	b672      	cpsid	i
    1af0:	e7fe      	b.n	1af0 <xTimerCreateTimerTask+0x2c>
BaseType_t xReturn = pdFAIL;
    1af2:	2000      	movs	r0, #0
    1af4:	e7f9      	b.n	1aea <xTimerCreateTimerTask+0x26>
}
    1af6:	b002      	add	sp, #8
    1af8:	bd10      	pop	{r4, pc}
    1afa:	46c0      	nop			; (mov r8, r8)
    1afc:	00001a65 	.word	0x00001a65
    1b00:	20004410 	.word	0x20004410
    1b04:	000021d4 	.word	0x000021d4
    1b08:	00001dc9 	.word	0x00001dc9
    1b0c:	00001431 	.word	0x00001431

00001b10 <xTimerGenericCommand>:
{
    1b10:	b530      	push	{r4, r5, lr}
    1b12:	b085      	sub	sp, #20
    1b14:	0004      	movs	r4, r0
    1b16:	001d      	movs	r5, r3
	configASSERT( xTimer );
    1b18:	2800      	cmp	r0, #0
    1b1a:	d014      	beq.n	1b46 <xTimerGenericCommand+0x36>
	if( xTimerQueue != NULL )
    1b1c:	4b13      	ldr	r3, [pc, #76]	; (1b6c <xTimerGenericCommand+0x5c>)
    1b1e:	6898      	ldr	r0, [r3, #8]
    1b20:	2800      	cmp	r0, #0
    1b22:	d021      	beq.n	1b68 <xTimerGenericCommand+0x58>
		xMessage.xMessageID = xCommandID;
    1b24:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1b26:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1b28:	9403      	str	r4, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1b2a:	2905      	cmp	r1, #5
    1b2c:	dc15      	bgt.n	1b5a <xTimerGenericCommand+0x4a>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1b2e:	4b10      	ldr	r3, [pc, #64]	; (1b70 <xTimerGenericCommand+0x60>)
    1b30:	4798      	blx	r3
    1b32:	2802      	cmp	r0, #2
    1b34:	d009      	beq.n	1b4a <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1b36:	4b0d      	ldr	r3, [pc, #52]	; (1b6c <xTimerGenericCommand+0x5c>)
    1b38:	6898      	ldr	r0, [r3, #8]
    1b3a:	2300      	movs	r3, #0
    1b3c:	2200      	movs	r2, #0
    1b3e:	a901      	add	r1, sp, #4
    1b40:	4c0c      	ldr	r4, [pc, #48]	; (1b74 <xTimerGenericCommand+0x64>)
    1b42:	47a0      	blx	r4
    1b44:	e00e      	b.n	1b64 <xTimerGenericCommand+0x54>
	configASSERT( xTimer );
    1b46:	b672      	cpsid	i
    1b48:	e7fe      	b.n	1b48 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1b4a:	4b08      	ldr	r3, [pc, #32]	; (1b6c <xTimerGenericCommand+0x5c>)
    1b4c:	6898      	ldr	r0, [r3, #8]
    1b4e:	2300      	movs	r3, #0
    1b50:	9a08      	ldr	r2, [sp, #32]
    1b52:	a901      	add	r1, sp, #4
    1b54:	4c07      	ldr	r4, [pc, #28]	; (1b74 <xTimerGenericCommand+0x64>)
    1b56:	47a0      	blx	r4
    1b58:	e004      	b.n	1b64 <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1b5a:	2300      	movs	r3, #0
    1b5c:	002a      	movs	r2, r5
    1b5e:	a901      	add	r1, sp, #4
    1b60:	4c05      	ldr	r4, [pc, #20]	; (1b78 <xTimerGenericCommand+0x68>)
    1b62:	47a0      	blx	r4
}
    1b64:	b005      	add	sp, #20
    1b66:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
    1b68:	2000      	movs	r0, #0
	return xReturn;
    1b6a:	e7fb      	b.n	1b64 <xTimerGenericCommand+0x54>
    1b6c:	20004410 	.word	0x20004410
    1b70:	00001961 	.word	0x00001961
    1b74:	00000d11 	.word	0x00000d11
    1b78:	00000ea1 	.word	0x00000ea1

00001b7c <prvSwitchTimerLists>:
{
    1b7c:	b570      	push	{r4, r5, r6, lr}
    1b7e:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1b80:	4b17      	ldr	r3, [pc, #92]	; (1be0 <prvSwitchTimerLists+0x64>)
    1b82:	681b      	ldr	r3, [r3, #0]
    1b84:	681a      	ldr	r2, [r3, #0]
    1b86:	2a00      	cmp	r2, #0
    1b88:	d023      	beq.n	1bd2 <prvSwitchTimerLists+0x56>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1b8a:	68db      	ldr	r3, [r3, #12]
    1b8c:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1b8e:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1b90:	1d25      	adds	r5, r4, #4
    1b92:	0028      	movs	r0, r5
    1b94:	4b13      	ldr	r3, [pc, #76]	; (1be4 <prvSwitchTimerLists+0x68>)
    1b96:	4798      	blx	r3
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1b98:	0020      	movs	r0, r4
    1b9a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1b9c:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1b9e:	69e3      	ldr	r3, [r4, #28]
    1ba0:	2b01      	cmp	r3, #1
    1ba2:	d1ed      	bne.n	1b80 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1ba4:	69a3      	ldr	r3, [r4, #24]
    1ba6:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
    1ba8:	429e      	cmp	r6, r3
    1baa:	d207      	bcs.n	1bbc <prvSwitchTimerLists+0x40>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1bac:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1bae:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1bb0:	4b0b      	ldr	r3, [pc, #44]	; (1be0 <prvSwitchTimerLists+0x64>)
    1bb2:	6818      	ldr	r0, [r3, #0]
    1bb4:	0029      	movs	r1, r5
    1bb6:	4b0c      	ldr	r3, [pc, #48]	; (1be8 <prvSwitchTimerLists+0x6c>)
    1bb8:	4798      	blx	r3
    1bba:	e7e1      	b.n	1b80 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1bbc:	2300      	movs	r3, #0
    1bbe:	9300      	str	r3, [sp, #0]
    1bc0:	0032      	movs	r2, r6
    1bc2:	2100      	movs	r1, #0
    1bc4:	0020      	movs	r0, r4
    1bc6:	4c09      	ldr	r4, [pc, #36]	; (1bec <prvSwitchTimerLists+0x70>)
    1bc8:	47a0      	blx	r4
				configASSERT( xResult );
    1bca:	2800      	cmp	r0, #0
    1bcc:	d1d8      	bne.n	1b80 <prvSwitchTimerLists+0x4>
    1bce:	b672      	cpsid	i
    1bd0:	e7fe      	b.n	1bd0 <prvSwitchTimerLists+0x54>
	pxCurrentTimerList = pxOverflowTimerList;
    1bd2:	4a03      	ldr	r2, [pc, #12]	; (1be0 <prvSwitchTimerLists+0x64>)
    1bd4:	6851      	ldr	r1, [r2, #4]
    1bd6:	6011      	str	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
    1bd8:	6053      	str	r3, [r2, #4]
}
    1bda:	b002      	add	sp, #8
    1bdc:	bd70      	pop	{r4, r5, r6, pc}
    1bde:	46c0      	nop			; (mov r8, r8)
    1be0:	20004410 	.word	0x20004410
    1be4:	00000375 	.word	0x00000375
    1be8:	00000345 	.word	0x00000345
    1bec:	00001b11 	.word	0x00001b11

00001bf0 <prvSampleTimeNow>:
{
    1bf0:	b570      	push	{r4, r5, r6, lr}
    1bf2:	0005      	movs	r5, r0
	xTimeNow = xTaskGetTickCount();
    1bf4:	4b08      	ldr	r3, [pc, #32]	; (1c18 <prvSampleTimeNow+0x28>)
    1bf6:	4798      	blx	r3
    1bf8:	0004      	movs	r4, r0
	if( xTimeNow < xLastTime )
    1bfa:	4b08      	ldr	r3, [pc, #32]	; (1c1c <prvSampleTimeNow+0x2c>)
    1bfc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1bfe:	4298      	cmp	r0, r3
    1c00:	d305      	bcc.n	1c0e <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
    1c02:	2300      	movs	r3, #0
    1c04:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
    1c06:	4b05      	ldr	r3, [pc, #20]	; (1c1c <prvSampleTimeNow+0x2c>)
    1c08:	639c      	str	r4, [r3, #56]	; 0x38
}
    1c0a:	0020      	movs	r0, r4
    1c0c:	bd70      	pop	{r4, r5, r6, pc}
		prvSwitchTimerLists();
    1c0e:	4b04      	ldr	r3, [pc, #16]	; (1c20 <prvSampleTimeNow+0x30>)
    1c10:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
    1c12:	2301      	movs	r3, #1
    1c14:	602b      	str	r3, [r5, #0]
    1c16:	e7f6      	b.n	1c06 <prvSampleTimeNow+0x16>
    1c18:	00001519 	.word	0x00001519
    1c1c:	20004410 	.word	0x20004410
    1c20:	00001b7d 	.word	0x00001b7d

00001c24 <prvProcessExpiredTimer>:
{
    1c24:	b570      	push	{r4, r5, r6, lr}
    1c26:	b082      	sub	sp, #8
    1c28:	0005      	movs	r5, r0
    1c2a:	000e      	movs	r6, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1c2c:	4b11      	ldr	r3, [pc, #68]	; (1c74 <prvProcessExpiredTimer+0x50>)
    1c2e:	681b      	ldr	r3, [r3, #0]
    1c30:	68db      	ldr	r3, [r3, #12]
    1c32:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1c34:	1d20      	adds	r0, r4, #4
    1c36:	4b10      	ldr	r3, [pc, #64]	; (1c78 <prvProcessExpiredTimer+0x54>)
    1c38:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1c3a:	69e3      	ldr	r3, [r4, #28]
    1c3c:	2b01      	cmp	r3, #1
    1c3e:	d004      	beq.n	1c4a <prvProcessExpiredTimer+0x26>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1c40:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1c42:	0020      	movs	r0, r4
    1c44:	4798      	blx	r3
}
    1c46:	b002      	add	sp, #8
    1c48:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1c4a:	69a3      	ldr	r3, [r4, #24]
    1c4c:	1959      	adds	r1, r3, r5
    1c4e:	002b      	movs	r3, r5
    1c50:	0032      	movs	r2, r6
    1c52:	0020      	movs	r0, r4
    1c54:	4e09      	ldr	r6, [pc, #36]	; (1c7c <prvProcessExpiredTimer+0x58>)
    1c56:	47b0      	blx	r6
    1c58:	2800      	cmp	r0, #0
    1c5a:	d0f1      	beq.n	1c40 <prvProcessExpiredTimer+0x1c>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1c5c:	2300      	movs	r3, #0
    1c5e:	9300      	str	r3, [sp, #0]
    1c60:	002a      	movs	r2, r5
    1c62:	2100      	movs	r1, #0
    1c64:	0020      	movs	r0, r4
    1c66:	4d06      	ldr	r5, [pc, #24]	; (1c80 <prvProcessExpiredTimer+0x5c>)
    1c68:	47a8      	blx	r5
			configASSERT( xResult );
    1c6a:	2800      	cmp	r0, #0
    1c6c:	d1e8      	bne.n	1c40 <prvProcessExpiredTimer+0x1c>
    1c6e:	b672      	cpsid	i
    1c70:	e7fe      	b.n	1c70 <prvProcessExpiredTimer+0x4c>
    1c72:	46c0      	nop			; (mov r8, r8)
    1c74:	20004410 	.word	0x20004410
    1c78:	00000375 	.word	0x00000375
    1c7c:	00001a1d 	.word	0x00001a1d
    1c80:	00001b11 	.word	0x00001b11

00001c84 <prvProcessTimerOrBlockTask>:
{
    1c84:	b570      	push	{r4, r5, r6, lr}
    1c86:	b082      	sub	sp, #8
    1c88:	0005      	movs	r5, r0
    1c8a:	000c      	movs	r4, r1
	vTaskSuspendAll();
    1c8c:	4b16      	ldr	r3, [pc, #88]	; (1ce8 <prvProcessTimerOrBlockTask+0x64>)
    1c8e:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1c90:	a801      	add	r0, sp, #4
    1c92:	4b16      	ldr	r3, [pc, #88]	; (1cec <prvProcessTimerOrBlockTask+0x68>)
    1c94:	4798      	blx	r3
    1c96:	0006      	movs	r6, r0
		if( xTimerListsWereSwitched == pdFALSE )
    1c98:	9b01      	ldr	r3, [sp, #4]
    1c9a:	2b00      	cmp	r3, #0
    1c9c:	d121      	bne.n	1ce2 <prvProcessTimerOrBlockTask+0x5e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1c9e:	2c00      	cmp	r4, #0
    1ca0:	d101      	bne.n	1ca6 <prvProcessTimerOrBlockTask+0x22>
    1ca2:	42a8      	cmp	r0, r5
    1ca4:	d213      	bcs.n	1cce <prvProcessTimerOrBlockTask+0x4a>
				if( xListWasEmpty != pdFALSE )
    1ca6:	2c00      	cmp	r4, #0
    1ca8:	d005      	beq.n	1cb6 <prvProcessTimerOrBlockTask+0x32>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1caa:	4b11      	ldr	r3, [pc, #68]	; (1cf0 <prvProcessTimerOrBlockTask+0x6c>)
    1cac:	685b      	ldr	r3, [r3, #4]
    1cae:	681c      	ldr	r4, [r3, #0]
    1cb0:	4263      	negs	r3, r4
    1cb2:	415c      	adcs	r4, r3
    1cb4:	b2e4      	uxtb	r4, r4
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1cb6:	1ba9      	subs	r1, r5, r6
    1cb8:	4b0d      	ldr	r3, [pc, #52]	; (1cf0 <prvProcessTimerOrBlockTask+0x6c>)
    1cba:	6898      	ldr	r0, [r3, #8]
    1cbc:	0022      	movs	r2, r4
    1cbe:	4b0d      	ldr	r3, [pc, #52]	; (1cf4 <prvProcessTimerOrBlockTask+0x70>)
    1cc0:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    1cc2:	4b0d      	ldr	r3, [pc, #52]	; (1cf8 <prvProcessTimerOrBlockTask+0x74>)
    1cc4:	4798      	blx	r3
    1cc6:	2800      	cmp	r0, #0
    1cc8:	d008      	beq.n	1cdc <prvProcessTimerOrBlockTask+0x58>
}
    1cca:	b002      	add	sp, #8
    1ccc:	bd70      	pop	{r4, r5, r6, pc}
				( void ) xTaskResumeAll();
    1cce:	4b0a      	ldr	r3, [pc, #40]	; (1cf8 <prvProcessTimerOrBlockTask+0x74>)
    1cd0:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    1cd2:	0031      	movs	r1, r6
    1cd4:	0028      	movs	r0, r5
    1cd6:	4b09      	ldr	r3, [pc, #36]	; (1cfc <prvProcessTimerOrBlockTask+0x78>)
    1cd8:	4798      	blx	r3
    1cda:	e7f6      	b.n	1cca <prvProcessTimerOrBlockTask+0x46>
					portYIELD_WITHIN_API();
    1cdc:	4b08      	ldr	r3, [pc, #32]	; (1d00 <prvProcessTimerOrBlockTask+0x7c>)
    1cde:	4798      	blx	r3
    1ce0:	e7f3      	b.n	1cca <prvProcessTimerOrBlockTask+0x46>
			( void ) xTaskResumeAll();
    1ce2:	4b05      	ldr	r3, [pc, #20]	; (1cf8 <prvProcessTimerOrBlockTask+0x74>)
    1ce4:	4798      	blx	r3
}
    1ce6:	e7f0      	b.n	1cca <prvProcessTimerOrBlockTask+0x46>
    1ce8:	00001509 	.word	0x00001509
    1cec:	00001bf1 	.word	0x00001bf1
    1cf0:	20004410 	.word	0x20004410
    1cf4:	0000110d 	.word	0x0000110d
    1cf8:	00001631 	.word	0x00001631
    1cfc:	00001c25 	.word	0x00001c25
    1d00:	00000939 	.word	0x00000939

00001d04 <prvProcessReceivedCommands>:
{
    1d04:	b530      	push	{r4, r5, lr}
    1d06:	b087      	sub	sp, #28
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1d08:	4b27      	ldr	r3, [pc, #156]	; (1da8 <prvProcessReceivedCommands+0xa4>)
    1d0a:	6898      	ldr	r0, [r3, #8]
    1d0c:	2200      	movs	r2, #0
    1d0e:	a903      	add	r1, sp, #12
    1d10:	4b26      	ldr	r3, [pc, #152]	; (1dac <prvProcessReceivedCommands+0xa8>)
    1d12:	4798      	blx	r3
    1d14:	2800      	cmp	r0, #0
    1d16:	d045      	beq.n	1da4 <prvProcessReceivedCommands+0xa0>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1d18:	9b03      	ldr	r3, [sp, #12]
    1d1a:	2b00      	cmp	r3, #0
    1d1c:	dbf4      	blt.n	1d08 <prvProcessReceivedCommands+0x4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1d1e:	9c05      	ldr	r4, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    1d20:	6963      	ldr	r3, [r4, #20]
    1d22:	2b00      	cmp	r3, #0
    1d24:	d002      	beq.n	1d2c <prvProcessReceivedCommands+0x28>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1d26:	1d20      	adds	r0, r4, #4
    1d28:	4b21      	ldr	r3, [pc, #132]	; (1db0 <prvProcessReceivedCommands+0xac>)
    1d2a:	4798      	blx	r3
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1d2c:	a802      	add	r0, sp, #8
    1d2e:	4b21      	ldr	r3, [pc, #132]	; (1db4 <prvProcessReceivedCommands+0xb0>)
    1d30:	4798      	blx	r3
			switch( xMessage.xMessageID )
    1d32:	9b03      	ldr	r3, [sp, #12]
    1d34:	2b09      	cmp	r3, #9
    1d36:	d8e7      	bhi.n	1d08 <prvProcessReceivedCommands+0x4>
    1d38:	009b      	lsls	r3, r3, #2
    1d3a:	4a1f      	ldr	r2, [pc, #124]	; (1db8 <prvProcessReceivedCommands+0xb4>)
    1d3c:	58d3      	ldr	r3, [r2, r3]
    1d3e:	469f      	mov	pc, r3
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1d40:	9b04      	ldr	r3, [sp, #16]
    1d42:	69a2      	ldr	r2, [r4, #24]
    1d44:	4694      	mov	ip, r2
    1d46:	4463      	add	r3, ip
    1d48:	0019      	movs	r1, r3
    1d4a:	9b04      	ldr	r3, [sp, #16]
    1d4c:	0002      	movs	r2, r0
    1d4e:	0020      	movs	r0, r4
    1d50:	4d1a      	ldr	r5, [pc, #104]	; (1dbc <prvProcessReceivedCommands+0xb8>)
    1d52:	47a8      	blx	r5
    1d54:	2800      	cmp	r0, #0
    1d56:	d0d7      	beq.n	1d08 <prvProcessReceivedCommands+0x4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1d58:	0020      	movs	r0, r4
    1d5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1d5c:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1d5e:	69e3      	ldr	r3, [r4, #28]
    1d60:	2b01      	cmp	r3, #1
    1d62:	d1d1      	bne.n	1d08 <prvProcessReceivedCommands+0x4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1d64:	9b04      	ldr	r3, [sp, #16]
    1d66:	69a1      	ldr	r1, [r4, #24]
    1d68:	468c      	mov	ip, r1
    1d6a:	4463      	add	r3, ip
    1d6c:	001a      	movs	r2, r3
    1d6e:	2300      	movs	r3, #0
    1d70:	9300      	str	r3, [sp, #0]
    1d72:	2100      	movs	r1, #0
    1d74:	0020      	movs	r0, r4
    1d76:	4c12      	ldr	r4, [pc, #72]	; (1dc0 <prvProcessReceivedCommands+0xbc>)
    1d78:	47a0      	blx	r4
							configASSERT( xResult );
    1d7a:	2800      	cmp	r0, #0
    1d7c:	d1c4      	bne.n	1d08 <prvProcessReceivedCommands+0x4>
    1d7e:	b672      	cpsid	i
    1d80:	e7fe      	b.n	1d80 <prvProcessReceivedCommands+0x7c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1d82:	9904      	ldr	r1, [sp, #16]
    1d84:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1d86:	2900      	cmp	r1, #0
    1d88:	d006      	beq.n	1d98 <prvProcessReceivedCommands+0x94>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1d8a:	1841      	adds	r1, r0, r1
    1d8c:	0003      	movs	r3, r0
    1d8e:	0002      	movs	r2, r0
    1d90:	0020      	movs	r0, r4
    1d92:	4c0a      	ldr	r4, [pc, #40]	; (1dbc <prvProcessReceivedCommands+0xb8>)
    1d94:	47a0      	blx	r4
					break;
    1d96:	e7b7      	b.n	1d08 <prvProcessReceivedCommands+0x4>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1d98:	b672      	cpsid	i
    1d9a:	e7fe      	b.n	1d9a <prvProcessReceivedCommands+0x96>
						vPortFree( pxTimer );
    1d9c:	0020      	movs	r0, r4
    1d9e:	4b09      	ldr	r3, [pc, #36]	; (1dc4 <prvProcessReceivedCommands+0xc0>)
    1da0:	4798      	blx	r3
					break;
    1da2:	e7b1      	b.n	1d08 <prvProcessReceivedCommands+0x4>
}
    1da4:	b007      	add	sp, #28
    1da6:	bd30      	pop	{r4, r5, pc}
    1da8:	20004410 	.word	0x20004410
    1dac:	00000f8d 	.word	0x00000f8d
    1db0:	00000375 	.word	0x00000375
    1db4:	00001bf1 	.word	0x00001bf1
    1db8:	000021a4 	.word	0x000021a4
    1dbc:	00001a1d 	.word	0x00001a1d
    1dc0:	00001b11 	.word	0x00001b11
    1dc4:	000002c9 	.word	0x000002c9

00001dc8 <prvTimerTask>:
{
    1dc8:	b500      	push	{lr}
    1dca:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    1dcc:	a801      	add	r0, sp, #4
    1dce:	4b04      	ldr	r3, [pc, #16]	; (1de0 <prvTimerTask+0x18>)
    1dd0:	4798      	blx	r3
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    1dd2:	9901      	ldr	r1, [sp, #4]
    1dd4:	4b03      	ldr	r3, [pc, #12]	; (1de4 <prvTimerTask+0x1c>)
    1dd6:	4798      	blx	r3
		prvProcessReceivedCommands();
    1dd8:	4b03      	ldr	r3, [pc, #12]	; (1de8 <prvTimerTask+0x20>)
    1dda:	4798      	blx	r3
    1ddc:	e7f6      	b.n	1dcc <prvTimerTask+0x4>
    1dde:	46c0      	nop			; (mov r8, r8)
    1de0:	000019fd 	.word	0x000019fd
    1de4:	00001c85 	.word	0x00001c85
    1de8:	00001d05 	.word	0x00001d05

00001dec <initUART>:
/* Replace with your library code */
void initUART(void) {

	/* APBCMASK */
   /* SERCOM 0 enable*/
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0;
    1dec:	4a1f      	ldr	r2, [pc, #124]	; (1e6c <initUART+0x80>)
    1dee:	6a13      	ldr	r3, [r2, #32]
    1df0:	2104      	movs	r1, #4
    1df2:	430b      	orrs	r3, r1
    1df4:	6213      	str	r3, [r2, #32]

	/*GCLK configuration for sercom0 module: using generic clock generator 0, ID for sercom0, enable GCLK*/
    GCLK->GENCTRL.reg=GCLK_GENCTRL_SRC_OSC8M|GCLK_GENCTRL_ID(0)|
    1df6:	4b1e      	ldr	r3, [pc, #120]	; (1e70 <initUART+0x84>)
    1df8:	2283      	movs	r2, #131	; 0x83
    1dfa:	0252      	lsls	r2, r2, #9
    1dfc:	605a      	str	r2, [r3, #4]
	GCLK_GENCTRL_GENEN;

	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE) |
    1dfe:	4a1d      	ldr	r2, [pc, #116]	; (1e74 <initUART+0x88>)
    1e00:	805a      	strh	r2, [r3, #2]
	GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);

  /*CONFIGURAR PA10 y PA11 como salidas tipo C (SERCOM 0) */
  PORT->Group[0].PINCFG[PIN_PA10].reg= PA10_TX;
    1e02:	4b1d      	ldr	r3, [pc, #116]	; (1e78 <initUART+0x8c>)
    1e04:	3903      	subs	r1, #3
    1e06:	224a      	movs	r2, #74	; 0x4a
    1e08:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PINCFG[PIN_PA11].reg= PA11_RX;
    1e0a:	3106      	adds	r1, #6
    1e0c:	3201      	adds	r2, #1
    1e0e:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PMUX[5].bit.PMUXE=Type_C;
    1e10:	312e      	adds	r1, #46	; 0x2e
    1e12:	5c5a      	ldrb	r2, [r3, r1]
    1e14:	200f      	movs	r0, #15
    1e16:	4382      	bics	r2, r0
    1e18:	2002      	movs	r0, #2
    1e1a:	4302      	orrs	r2, r0
    1e1c:	545a      	strb	r2, [r3, r1]
  PORT->Group[0].PMUX[5].bit.PMUXO=Type_C;
    1e1e:	5c58      	ldrb	r0, [r3, r1]
    1e20:	220f      	movs	r2, #15
    1e22:	4002      	ands	r2, r0
    1e24:	2020      	movs	r0, #32
    1e26:	4302      	orrs	r2, r0
    1e28:	545a      	strb	r2, [r3, r1]
	
	//desahibilitar UART para inicializacion
	SERCOM0->USART.CTRLA.bit.ENABLE=0;
    1e2a:	4b14      	ldr	r3, [pc, #80]	; (1e7c <initUART+0x90>)
    1e2c:	6819      	ldr	r1, [r3, #0]
    1e2e:	2202      	movs	r2, #2
    1e30:	4391      	bics	r1, r2
    1e32:	6019      	str	r1, [r3, #0]
   
   DEFINES:
   1)SERCOM_USART_CTRLA_DORD (_U(0x1) << SERCOM_USART_CTRLA_DORD_Pos)
   2)SERCOM_USART_CTRLA_MODE_USART_INT_CLK (0x1 << 2)
   3)SERCOM_USART_CTRLA_RXPO(value) (SERCOM_USART_CTRLA_RXPO_Msk & ((value) << SERCOM_USART_CTRLA_RXPO_Pos) */
	SERCOM0->USART.CTRLA.reg =
    1e34:	4a12      	ldr	r2, [pc, #72]	; (1e80 <initUART+0x94>)
    1e36:	601a      	str	r2, [r3, #0]
	SERCOM_USART_CTRLA_DORD | SERCOM_USART_CTRLA_MODE_USART_INT_CLK |
	SERCOM_USART_CTRLA_RXPO(3) | SERCOM_USART_CTRLA_TXPO(1);
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1e38:	4b10      	ldr	r3, [pc, #64]	; (1e7c <initUART+0x90>)
    1e3a:	69db      	ldr	r3, [r3, #28]
    1e3c:	2b00      	cmp	r3, #0
    1e3e:	d1fb      	bne.n	1e38 <initUART+0x4c>
	uint64_t br = (uint64_t)65536 * (8000000 - 16 * 9600) / 8000000;

	SERCOM0->USART.BAUD.reg = (uint16_t)br;
    1e40:	4a10      	ldr	r2, [pc, #64]	; (1e84 <initUART+0x98>)
    1e42:	4b0e      	ldr	r3, [pc, #56]	; (1e7c <initUART+0x90>)
    1e44:	819a      	strh	r2, [r3, #12]
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1e46:	4b0d      	ldr	r3, [pc, #52]	; (1e7c <initUART+0x90>)
    1e48:	69db      	ldr	r3, [r3, #28]
    1e4a:	2b00      	cmp	r3, #0
    1e4c:	d1fb      	bne.n	1e46 <initUART+0x5a>
	SERCOM0->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_CHSIZE(0/*8 bits*/);
    1e4e:	22c0      	movs	r2, #192	; 0xc0
    1e50:	0292      	lsls	r2, r2, #10
    1e52:	4b0a      	ldr	r3, [pc, #40]	; (1e7c <initUART+0x90>)
    1e54:	605a      	str	r2, [r3, #4]
    while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1e56:	4b09      	ldr	r3, [pc, #36]	; (1e7c <initUART+0x90>)
    1e58:	69db      	ldr	r3, [r3, #28]
    1e5a:	2b00      	cmp	r3, #0
    1e5c:	d1fb      	bne.n	1e56 <initUART+0x6a>
	SERCOM0->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    1e5e:	4a07      	ldr	r2, [pc, #28]	; (1e7c <initUART+0x90>)
    1e60:	6813      	ldr	r3, [r2, #0]
    1e62:	2102      	movs	r1, #2
    1e64:	430b      	orrs	r3, r1
    1e66:	6013      	str	r3, [r2, #0]
}
    1e68:	4770      	bx	lr
    1e6a:	46c0      	nop			; (mov r8, r8)
    1e6c:	40000400 	.word	0x40000400
    1e70:	40000c00 	.word	0x40000c00
    1e74:	00004014 	.word	0x00004014
    1e78:	41004400 	.word	0x41004400
    1e7c:	42000800 	.word	0x42000800
    1e80:	40310004 	.word	0x40310004
    1e84:	fffffb15 	.word	0xfffffb15

00001e88 <__libc_init_array>:
    1e88:	b570      	push	{r4, r5, r6, lr}
    1e8a:	4e0d      	ldr	r6, [pc, #52]	; (1ec0 <__libc_init_array+0x38>)
    1e8c:	4d0d      	ldr	r5, [pc, #52]	; (1ec4 <__libc_init_array+0x3c>)
    1e8e:	2400      	movs	r4, #0
    1e90:	1bad      	subs	r5, r5, r6
    1e92:	10ad      	asrs	r5, r5, #2
    1e94:	d005      	beq.n	1ea2 <__libc_init_array+0x1a>
    1e96:	00a3      	lsls	r3, r4, #2
    1e98:	58f3      	ldr	r3, [r6, r3]
    1e9a:	3401      	adds	r4, #1
    1e9c:	4798      	blx	r3
    1e9e:	42a5      	cmp	r5, r4
    1ea0:	d1f9      	bne.n	1e96 <__libc_init_array+0xe>
    1ea2:	f000 f99d 	bl	21e0 <_init>
    1ea6:	4e08      	ldr	r6, [pc, #32]	; (1ec8 <__libc_init_array+0x40>)
    1ea8:	4d08      	ldr	r5, [pc, #32]	; (1ecc <__libc_init_array+0x44>)
    1eaa:	2400      	movs	r4, #0
    1eac:	1bad      	subs	r5, r5, r6
    1eae:	10ad      	asrs	r5, r5, #2
    1eb0:	d005      	beq.n	1ebe <__libc_init_array+0x36>
    1eb2:	00a3      	lsls	r3, r4, #2
    1eb4:	58f3      	ldr	r3, [r6, r3]
    1eb6:	3401      	adds	r4, #1
    1eb8:	4798      	blx	r3
    1eba:	42a5      	cmp	r5, r4
    1ebc:	d1f9      	bne.n	1eb2 <__libc_init_array+0x2a>
    1ebe:	bd70      	pop	{r4, r5, r6, pc}
    1ec0:	000021ec 	.word	0x000021ec
    1ec4:	000021ec 	.word	0x000021ec
    1ec8:	000021ec 	.word	0x000021ec
    1ecc:	000021f4 	.word	0x000021f4

00001ed0 <memcpy>:
    1ed0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ed2:	0005      	movs	r5, r0
    1ed4:	2a0f      	cmp	r2, #15
    1ed6:	d92f      	bls.n	1f38 <memcpy+0x68>
    1ed8:	000b      	movs	r3, r1
    1eda:	4303      	orrs	r3, r0
    1edc:	079b      	lsls	r3, r3, #30
    1ede:	d134      	bne.n	1f4a <memcpy+0x7a>
    1ee0:	0016      	movs	r6, r2
    1ee2:	000c      	movs	r4, r1
    1ee4:	0003      	movs	r3, r0
    1ee6:	3e10      	subs	r6, #16
    1ee8:	0935      	lsrs	r5, r6, #4
    1eea:	3501      	adds	r5, #1
    1eec:	012d      	lsls	r5, r5, #4
    1eee:	1945      	adds	r5, r0, r5
    1ef0:	6827      	ldr	r7, [r4, #0]
    1ef2:	601f      	str	r7, [r3, #0]
    1ef4:	6867      	ldr	r7, [r4, #4]
    1ef6:	605f      	str	r7, [r3, #4]
    1ef8:	68a7      	ldr	r7, [r4, #8]
    1efa:	609f      	str	r7, [r3, #8]
    1efc:	68e7      	ldr	r7, [r4, #12]
    1efe:	3410      	adds	r4, #16
    1f00:	60df      	str	r7, [r3, #12]
    1f02:	3310      	adds	r3, #16
    1f04:	429d      	cmp	r5, r3
    1f06:	d1f3      	bne.n	1ef0 <memcpy+0x20>
    1f08:	230f      	movs	r3, #15
    1f0a:	439e      	bics	r6, r3
    1f0c:	3610      	adds	r6, #16
    1f0e:	1985      	adds	r5, r0, r6
    1f10:	1989      	adds	r1, r1, r6
    1f12:	4013      	ands	r3, r2
    1f14:	2b03      	cmp	r3, #3
    1f16:	d91a      	bls.n	1f4e <memcpy+0x7e>
    1f18:	1f1e      	subs	r6, r3, #4
    1f1a:	2300      	movs	r3, #0
    1f1c:	08b4      	lsrs	r4, r6, #2
    1f1e:	3401      	adds	r4, #1
    1f20:	00a4      	lsls	r4, r4, #2
    1f22:	58cf      	ldr	r7, [r1, r3]
    1f24:	50ef      	str	r7, [r5, r3]
    1f26:	3304      	adds	r3, #4
    1f28:	42a3      	cmp	r3, r4
    1f2a:	d1fa      	bne.n	1f22 <memcpy+0x52>
    1f2c:	2403      	movs	r4, #3
    1f2e:	43a6      	bics	r6, r4
    1f30:	1d33      	adds	r3, r6, #4
    1f32:	4022      	ands	r2, r4
    1f34:	18c9      	adds	r1, r1, r3
    1f36:	18ed      	adds	r5, r5, r3
    1f38:	2a00      	cmp	r2, #0
    1f3a:	d005      	beq.n	1f48 <memcpy+0x78>
    1f3c:	2300      	movs	r3, #0
    1f3e:	5ccc      	ldrb	r4, [r1, r3]
    1f40:	54ec      	strb	r4, [r5, r3]
    1f42:	3301      	adds	r3, #1
    1f44:	4293      	cmp	r3, r2
    1f46:	d1fa      	bne.n	1f3e <memcpy+0x6e>
    1f48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1f4a:	0005      	movs	r5, r0
    1f4c:	e7f6      	b.n	1f3c <memcpy+0x6c>
    1f4e:	001a      	movs	r2, r3
    1f50:	e7f2      	b.n	1f38 <memcpy+0x68>
    1f52:	46c0      	nop			; (mov r8, r8)

00001f54 <memset>:
    1f54:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f56:	0783      	lsls	r3, r0, #30
    1f58:	d043      	beq.n	1fe2 <memset+0x8e>
    1f5a:	1e54      	subs	r4, r2, #1
    1f5c:	2a00      	cmp	r2, #0
    1f5e:	d03f      	beq.n	1fe0 <memset+0x8c>
    1f60:	b2ce      	uxtb	r6, r1
    1f62:	0002      	movs	r2, r0
    1f64:	2503      	movs	r5, #3
    1f66:	e002      	b.n	1f6e <memset+0x1a>
    1f68:	001a      	movs	r2, r3
    1f6a:	3c01      	subs	r4, #1
    1f6c:	d338      	bcc.n	1fe0 <memset+0x8c>
    1f6e:	1c53      	adds	r3, r2, #1
    1f70:	7016      	strb	r6, [r2, #0]
    1f72:	422b      	tst	r3, r5
    1f74:	d1f8      	bne.n	1f68 <memset+0x14>
    1f76:	2c03      	cmp	r4, #3
    1f78:	d92a      	bls.n	1fd0 <memset+0x7c>
    1f7a:	22ff      	movs	r2, #255	; 0xff
    1f7c:	400a      	ands	r2, r1
    1f7e:	0215      	lsls	r5, r2, #8
    1f80:	4315      	orrs	r5, r2
    1f82:	042a      	lsls	r2, r5, #16
    1f84:	4315      	orrs	r5, r2
    1f86:	2c0f      	cmp	r4, #15
    1f88:	d914      	bls.n	1fb4 <memset+0x60>
    1f8a:	0027      	movs	r7, r4
    1f8c:	001a      	movs	r2, r3
    1f8e:	3f10      	subs	r7, #16
    1f90:	093e      	lsrs	r6, r7, #4
    1f92:	3601      	adds	r6, #1
    1f94:	0136      	lsls	r6, r6, #4
    1f96:	199e      	adds	r6, r3, r6
    1f98:	6015      	str	r5, [r2, #0]
    1f9a:	6055      	str	r5, [r2, #4]
    1f9c:	6095      	str	r5, [r2, #8]
    1f9e:	60d5      	str	r5, [r2, #12]
    1fa0:	3210      	adds	r2, #16
    1fa2:	4296      	cmp	r6, r2
    1fa4:	d1f8      	bne.n	1f98 <memset+0x44>
    1fa6:	220f      	movs	r2, #15
    1fa8:	4397      	bics	r7, r2
    1faa:	3710      	adds	r7, #16
    1fac:	19db      	adds	r3, r3, r7
    1fae:	4014      	ands	r4, r2
    1fb0:	2c03      	cmp	r4, #3
    1fb2:	d90d      	bls.n	1fd0 <memset+0x7c>
    1fb4:	001a      	movs	r2, r3
    1fb6:	1f27      	subs	r7, r4, #4
    1fb8:	08be      	lsrs	r6, r7, #2
    1fba:	3601      	adds	r6, #1
    1fbc:	00b6      	lsls	r6, r6, #2
    1fbe:	199e      	adds	r6, r3, r6
    1fc0:	c220      	stmia	r2!, {r5}
    1fc2:	42b2      	cmp	r2, r6
    1fc4:	d1fc      	bne.n	1fc0 <memset+0x6c>
    1fc6:	2203      	movs	r2, #3
    1fc8:	4397      	bics	r7, r2
    1fca:	3704      	adds	r7, #4
    1fcc:	19db      	adds	r3, r3, r7
    1fce:	4014      	ands	r4, r2
    1fd0:	2c00      	cmp	r4, #0
    1fd2:	d005      	beq.n	1fe0 <memset+0x8c>
    1fd4:	b2c9      	uxtb	r1, r1
    1fd6:	191c      	adds	r4, r3, r4
    1fd8:	7019      	strb	r1, [r3, #0]
    1fda:	3301      	adds	r3, #1
    1fdc:	429c      	cmp	r4, r3
    1fde:	d1fb      	bne.n	1fd8 <memset+0x84>
    1fe0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1fe2:	0014      	movs	r4, r2
    1fe4:	0003      	movs	r3, r0
    1fe6:	e7c6      	b.n	1f76 <memset+0x22>

00001fe8 <register_fini>:
    1fe8:	4b03      	ldr	r3, [pc, #12]	; (1ff8 <register_fini+0x10>)
    1fea:	b510      	push	{r4, lr}
    1fec:	2b00      	cmp	r3, #0
    1fee:	d002      	beq.n	1ff6 <register_fini+0xe>
    1ff0:	4802      	ldr	r0, [pc, #8]	; (1ffc <register_fini+0x14>)
    1ff2:	f000 f805 	bl	2000 <atexit>
    1ff6:	bd10      	pop	{r4, pc}
    1ff8:	00000000 	.word	0x00000000
    1ffc:	00002011 	.word	0x00002011

00002000 <atexit>:
    2000:	b510      	push	{r4, lr}
    2002:	0001      	movs	r1, r0
    2004:	2300      	movs	r3, #0
    2006:	2200      	movs	r2, #0
    2008:	2000      	movs	r0, #0
    200a:	f000 f81f 	bl	204c <__register_exitproc>
    200e:	bd10      	pop	{r4, pc}

00002010 <__libc_fini_array>:
    2010:	b570      	push	{r4, r5, r6, lr}
    2012:	4b09      	ldr	r3, [pc, #36]	; (2038 <__libc_fini_array+0x28>)
    2014:	4c09      	ldr	r4, [pc, #36]	; (203c <__libc_fini_array+0x2c>)
    2016:	1ae4      	subs	r4, r4, r3
    2018:	10a4      	asrs	r4, r4, #2
    201a:	d009      	beq.n	2030 <__libc_fini_array+0x20>
    201c:	4a08      	ldr	r2, [pc, #32]	; (2040 <__libc_fini_array+0x30>)
    201e:	18a5      	adds	r5, r4, r2
    2020:	00ad      	lsls	r5, r5, #2
    2022:	18ed      	adds	r5, r5, r3
    2024:	682b      	ldr	r3, [r5, #0]
    2026:	3c01      	subs	r4, #1
    2028:	4798      	blx	r3
    202a:	3d04      	subs	r5, #4
    202c:	2c00      	cmp	r4, #0
    202e:	d1f9      	bne.n	2024 <__libc_fini_array+0x14>
    2030:	f000 f8e0 	bl	21f4 <_fini>
    2034:	bd70      	pop	{r4, r5, r6, pc}
    2036:	46c0      	nop			; (mov r8, r8)
    2038:	00002200 	.word	0x00002200
    203c:	00002204 	.word	0x00002204
    2040:	3fffffff 	.word	0x3fffffff

00002044 <__retarget_lock_acquire_recursive>:
    2044:	4770      	bx	lr
    2046:	46c0      	nop			; (mov r8, r8)

00002048 <__retarget_lock_release_recursive>:
    2048:	4770      	bx	lr
    204a:	46c0      	nop			; (mov r8, r8)

0000204c <__register_exitproc>:
    204c:	b5f0      	push	{r4, r5, r6, r7, lr}
    204e:	464e      	mov	r6, r9
    2050:	4645      	mov	r5, r8
    2052:	46de      	mov	lr, fp
    2054:	4657      	mov	r7, sl
    2056:	b5e0      	push	{r5, r6, r7, lr}
    2058:	4d36      	ldr	r5, [pc, #216]	; (2134 <__register_exitproc+0xe8>)
    205a:	b083      	sub	sp, #12
    205c:	0006      	movs	r6, r0
    205e:	6828      	ldr	r0, [r5, #0]
    2060:	4698      	mov	r8, r3
    2062:	000f      	movs	r7, r1
    2064:	4691      	mov	r9, r2
    2066:	f7ff ffed 	bl	2044 <__retarget_lock_acquire_recursive>
    206a:	4b33      	ldr	r3, [pc, #204]	; (2138 <__register_exitproc+0xec>)
    206c:	681c      	ldr	r4, [r3, #0]
    206e:	23a4      	movs	r3, #164	; 0xa4
    2070:	005b      	lsls	r3, r3, #1
    2072:	58e0      	ldr	r0, [r4, r3]
    2074:	2800      	cmp	r0, #0
    2076:	d052      	beq.n	211e <__register_exitproc+0xd2>
    2078:	6843      	ldr	r3, [r0, #4]
    207a:	2b1f      	cmp	r3, #31
    207c:	dc13      	bgt.n	20a6 <__register_exitproc+0x5a>
    207e:	1c5a      	adds	r2, r3, #1
    2080:	9201      	str	r2, [sp, #4]
    2082:	2e00      	cmp	r6, #0
    2084:	d128      	bne.n	20d8 <__register_exitproc+0x8c>
    2086:	9a01      	ldr	r2, [sp, #4]
    2088:	3302      	adds	r3, #2
    208a:	009b      	lsls	r3, r3, #2
    208c:	6042      	str	r2, [r0, #4]
    208e:	501f      	str	r7, [r3, r0]
    2090:	6828      	ldr	r0, [r5, #0]
    2092:	f7ff ffd9 	bl	2048 <__retarget_lock_release_recursive>
    2096:	2000      	movs	r0, #0
    2098:	b003      	add	sp, #12
    209a:	bc3c      	pop	{r2, r3, r4, r5}
    209c:	4690      	mov	r8, r2
    209e:	4699      	mov	r9, r3
    20a0:	46a2      	mov	sl, r4
    20a2:	46ab      	mov	fp, r5
    20a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    20a6:	4b25      	ldr	r3, [pc, #148]	; (213c <__register_exitproc+0xf0>)
    20a8:	2b00      	cmp	r3, #0
    20aa:	d03d      	beq.n	2128 <__register_exitproc+0xdc>
    20ac:	20c8      	movs	r0, #200	; 0xc8
    20ae:	0040      	lsls	r0, r0, #1
    20b0:	e000      	b.n	20b4 <__register_exitproc+0x68>
    20b2:	bf00      	nop
    20b4:	2800      	cmp	r0, #0
    20b6:	d037      	beq.n	2128 <__register_exitproc+0xdc>
    20b8:	22a4      	movs	r2, #164	; 0xa4
    20ba:	2300      	movs	r3, #0
    20bc:	0052      	lsls	r2, r2, #1
    20be:	58a1      	ldr	r1, [r4, r2]
    20c0:	6043      	str	r3, [r0, #4]
    20c2:	6001      	str	r1, [r0, #0]
    20c4:	50a0      	str	r0, [r4, r2]
    20c6:	3240      	adds	r2, #64	; 0x40
    20c8:	5083      	str	r3, [r0, r2]
    20ca:	3204      	adds	r2, #4
    20cc:	5083      	str	r3, [r0, r2]
    20ce:	3301      	adds	r3, #1
    20d0:	9301      	str	r3, [sp, #4]
    20d2:	2300      	movs	r3, #0
    20d4:	2e00      	cmp	r6, #0
    20d6:	d0d6      	beq.n	2086 <__register_exitproc+0x3a>
    20d8:	009a      	lsls	r2, r3, #2
    20da:	4692      	mov	sl, r2
    20dc:	4482      	add	sl, r0
    20de:	464a      	mov	r2, r9
    20e0:	2188      	movs	r1, #136	; 0x88
    20e2:	4654      	mov	r4, sl
    20e4:	5062      	str	r2, [r4, r1]
    20e6:	22c4      	movs	r2, #196	; 0xc4
    20e8:	0052      	lsls	r2, r2, #1
    20ea:	4691      	mov	r9, r2
    20ec:	4481      	add	r9, r0
    20ee:	464a      	mov	r2, r9
    20f0:	3987      	subs	r1, #135	; 0x87
    20f2:	4099      	lsls	r1, r3
    20f4:	6812      	ldr	r2, [r2, #0]
    20f6:	468b      	mov	fp, r1
    20f8:	430a      	orrs	r2, r1
    20fa:	4694      	mov	ip, r2
    20fc:	464a      	mov	r2, r9
    20fe:	4661      	mov	r1, ip
    2100:	6011      	str	r1, [r2, #0]
    2102:	2284      	movs	r2, #132	; 0x84
    2104:	4641      	mov	r1, r8
    2106:	0052      	lsls	r2, r2, #1
    2108:	50a1      	str	r1, [r4, r2]
    210a:	2e02      	cmp	r6, #2
    210c:	d1bb      	bne.n	2086 <__register_exitproc+0x3a>
    210e:	0002      	movs	r2, r0
    2110:	465c      	mov	r4, fp
    2112:	328d      	adds	r2, #141	; 0x8d
    2114:	32ff      	adds	r2, #255	; 0xff
    2116:	6811      	ldr	r1, [r2, #0]
    2118:	430c      	orrs	r4, r1
    211a:	6014      	str	r4, [r2, #0]
    211c:	e7b3      	b.n	2086 <__register_exitproc+0x3a>
    211e:	0020      	movs	r0, r4
    2120:	304d      	adds	r0, #77	; 0x4d
    2122:	30ff      	adds	r0, #255	; 0xff
    2124:	50e0      	str	r0, [r4, r3]
    2126:	e7a7      	b.n	2078 <__register_exitproc+0x2c>
    2128:	6828      	ldr	r0, [r5, #0]
    212a:	f7ff ff8d 	bl	2048 <__retarget_lock_release_recursive>
    212e:	2001      	movs	r0, #1
    2130:	4240      	negs	r0, r0
    2132:	e7b1      	b.n	2098 <__register_exitproc+0x4c>
    2134:	20000438 	.word	0x20000438
    2138:	000021dc 	.word	0x000021dc
    213c:	00000000 	.word	0x00000000
    2140:	6174530a 	.word	0x6174530a
    2144:	6f206574 	.word	0x6f206574
    2148:	6e69206e 	.word	0x6e69206e
    214c:	726f7020 	.word	0x726f7020
    2150:	64252074 	.word	0x64252074
    2154:	0000000a 	.word	0x0000000a
    2158:	74747542 	.word	0x74747542
    215c:	31206e6f 	.word	0x31206e6f
    2160:	00000000 	.word	0x00000000
    2164:	74747542 	.word	0x74747542
    2168:	32206e6f 	.word	0x32206e6f
    216c:	00000000 	.word	0x00000000
    2170:	74747542 	.word	0x74747542
    2174:	33206e6f 	.word	0x33206e6f
    2178:	00000000 	.word	0x00000000
    217c:	74747542 	.word	0x74747542
    2180:	34206e6f 	.word	0x34206e6f
    2184:	00000000 	.word	0x00000000
    2188:	006b6341 	.word	0x006b6341
    218c:	454c4449 	.word	0x454c4449
    2190:	00000000 	.word	0x00000000
    2194:	09632509 	.word	0x09632509
    2198:	25097525 	.word	0x25097525
    219c:	75250975 	.word	0x75250975
    21a0:	00000a0d 	.word	0x00000a0d
    21a4:	00001d40 	.word	0x00001d40
    21a8:	00001d40 	.word	0x00001d40
    21ac:	00001d40 	.word	0x00001d40
    21b0:	00001d08 	.word	0x00001d08
    21b4:	00001d82 	.word	0x00001d82
    21b8:	00001d9c 	.word	0x00001d9c
    21bc:	00001d40 	.word	0x00001d40
    21c0:	00001d40 	.word	0x00001d40
    21c4:	00001d08 	.word	0x00001d08
    21c8:	00001d82 	.word	0x00001d82
    21cc:	51726d54 	.word	0x51726d54
    21d0:	00000000 	.word	0x00000000
    21d4:	20726d54 	.word	0x20726d54
    21d8:	00637653 	.word	0x00637653

000021dc <_global_impure_ptr>:
    21dc:	20000010                                ... 

000021e0 <_init>:
    21e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    21e2:	46c0      	nop			; (mov r8, r8)
    21e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    21e6:	bc08      	pop	{r3}
    21e8:	469e      	mov	lr, r3
    21ea:	4770      	bx	lr

000021ec <__init_array_start>:
    21ec:	00001fe9 	.word	0x00001fe9

000021f0 <__frame_dummy_init_array_entry>:
    21f0:	000000dd                                ....

000021f4 <_fini>:
    21f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    21f6:	46c0      	nop			; (mov r8, r8)
    21f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    21fa:	bc08      	pop	{r3}
    21fc:	469e      	mov	lr, r3
    21fe:	4770      	bx	lr

00002200 <__fini_array_start>:
    2200:	000000b5 	.word	0x000000b5
